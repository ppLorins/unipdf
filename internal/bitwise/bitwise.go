//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_df "encoding/binary";_b "errors";_f "github.com/pplorins/unipdf/v3/common";_e "github.com/pplorins/unipdf/v3/internal/jbig2/errors";_d "io";);func (_dfc *Reader )ReadUint32 ()(uint32 ,error ){_fdg :=make ([]byte ,4);_ ,_dce :=_dfc .Read (_fdg );if _dce !=nil {return 0,_dce ;};return _df .BigEndian .Uint32 (_fdg ),nil ;};func (_ed *BufferedWriter )fullOffset ()int {_ge :=_ed ._eac ;if _ed ._ae !=0{_ge ++;};return _ge ;};func (_ede *Writer )UseMSB ()bool {return _ede ._gce };func (_gdf *Reader )ReadBool ()(bool ,error ){return _gdf .readBool ()};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_dc :true }};func (_bee *Writer )FinishByte (){if _bee ._aabd ==0{return ;};_bee ._aabd =0;_bee ._ggb ++;};func (_eeb *SubstreamReader )Read (b []byte )(_db int ,_ebc error ){if _eeb ._gbb >=_eeb ._bfe {_f .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_eeb ._gbb ,_eeb ._bfe );return 0,_d .EOF ;};for ;_db < len (b );_db ++{if b [_db ],_ebc =_eeb .readUnalignedByte ();_ebc !=nil {if _ebc ==_d .EOF {return _db ,nil ;};return 0,_ebc ;};};return _db ,nil ;};var _ _d .Writer =&BufferedWriter {};type SubstreamReader struct{_gbb uint64 ;_bca StreamReader ;_fe uint64 ;_bfe uint64 ;_cage []byte ;_cec uint64 ;_ebf uint64 ;_cggg byte ;_fgc byte ;_gbe uint64 ;_cbda byte ;};func (_ca *BufferedWriter )Write (d []byte )(int ,error ){_ca .expandIfNeeded (len (d ));if _ca ._ae ==0{return _ca .writeFullBytes (d ),nil ;};return _ca .writeShiftedBytes (d ),nil ;};func (_fd *BufferedWriter )WriteBits (bits uint64 ,number int )(_egb int ,_gg error ){const _afb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_e .Errorf (_afb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_ab :=number /8;if _ab > 0{_dg :=number -_ab *8;for _cf :=_ab -1;_cf >=0;_cf --{_ac :=byte ((bits >>uint (_cf *8+_dg ))&0xff);if _gg =_fd .WriteByte (_ac );_gg !=nil {return _egb ,_e .Wrapf (_gg ,_afb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ab -_cf +1);};};number -=_ab *8;if number ==0{return _ab ,nil ;};};var _gf int ;for _cg :=0;_cg < number ;_cg ++{if _fd ._dc {_gf =int ((bits >>uint (number -1-_cg ))&0x1);}else {_gf =int (bits &0x1);bits >>=1;};if _gg =_fd .WriteBit (_gf );_gg !=nil {return _egb ,_e .Wrapf (_gg ,_afb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cg );};};return _ab ,nil ;};func (_dfe *BufferedWriter )Data ()[]byte {return _dfe ._af };type BufferedWriter struct{_af []byte ;_ae uint8 ;_eac int ;_dc bool ;};func (_agaa *SubstreamReader )ReadBit ()(_cfe int ,_dgab error ){_ddbf ,_dgab :=_agaa .readBool ();if _dgab !=nil {return 0,_dgab ;};if _ddbf {_cfe =1;};return _cfe ,nil ;};func (_cag *Reader )Read (p []byte )(_edc int ,_cbe error ){if _cag ._bef ==0{return _cag .read (p );};for ;_edc < len (p );_edc ++{if p [_edc ],_cbe =_cag .readUnalignedByte ();_cbe !=nil {return 0,_cbe ;};};return _edc ,nil ;};func (_afg *Reader )readBool ()(_eae bool ,_afdf error ){if _afg ._bef ==0{_afg ._gfbb ,_afdf =_afg .readBufferByte ();if _afdf !=nil {return false ,_afdf ;};_eae =(_afg ._gfbb &0x80)!=0;_afg ._gfbb ,_afg ._bef =_afg ._gfbb &0x7f,7;return _eae ,nil ;};_afg ._bef --;_eae =(_afg ._gfbb &(1<<_afg ._bef ))!=0;_afg ._gfbb &=1<<_afg ._bef -1;return _eae ,nil ;};type Reader struct{_afde []byte ;_gfbb byte ;_bef byte ;_eb int64 ;_ffc int ;_acb int ;_ded int64 ;_acd byte ;};func (_afd *BufferedWriter )Reset (){_afd ._af =_afd ._af [:0];_afd ._eac =0;_afd ._ae =0};var _ _d .ByteWriter =&BufferedWriter {};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_dffg byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_cc *SubstreamReader )Offset ()uint64 {return _cc ._fe };func (_fde *SubstreamReader )StreamPosition ()int64 {return int64 (_fde ._gbb )};type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;Data ()[]byte ;};func (_acaf *SubstreamReader )readUnalignedByte ()(_bce byte ,_dba error ){_agf :=_acaf ._fgc ;_bce =_acaf ._cggg <<(8-_agf );_acaf ._cggg ,_dba =_acaf .readBufferByte ();if _dba !=nil {return 0,_dba ;};_bce |=_acaf ._cggg >>_agf ;_acaf ._cggg &=1<<_agf -1;return _bce ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_b .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_f .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_bca :r ,_fe :offset ,_bfe :length ,_cage :make ([]byte ,length )},nil ;};func (_fg *BufferedWriter )writeByte (_aeb byte ){switch {case _fg ._ae ==0:_fg ._af [_fg ._eac ]=_aeb ;_fg ._eac ++;case _fg ._dc :_fg ._af [_fg ._eac ]|=_aeb >>_fg ._ae ;_fg ._eac ++;_fg ._af [_fg ._eac ]=byte (uint16 (_aeb )<<(8-_fg ._ae )&0xff);default:_fg ._af [_fg ._eac ]|=byte (uint16 (_aeb )<<_fg ._ae &0xff);_fg ._eac ++;_fg ._af [_fg ._eac ]=_aeb >>(8-_fg ._ae );};};func (_bed *Reader )readBufferByte ()(byte ,error ){if _bed ._eb >=int64 (len (_bed ._afde )){return 0,_d .EOF ;};_bed ._acb =-1;_geg :=_bed ._afde [_bed ._eb ];_bed ._eb ++;_bed ._ffc =int (_geg );return _geg ,nil ;};func (_cdac *Reader )Reset (){_cdac ._eb =_cdac ._ded ;_cdac ._bef =_cdac ._acd };func (_ef *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _e .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_ef ._af )-1< _ef ._eac {_ef .expandIfNeeded (1);};_caf :=_ef ._ae ;if _ef ._dc {_caf =7-_ef ._ae ;};_ef ._af [_ef ._eac ]|=byte (uint16 (bit <<_caf )&0xff);_ef ._ae ++;if _ef ._ae ==8{_ef ._eac ++;_ef ._ae =0;};return nil ;};func (_ffde *SubstreamReader )ReadBool ()(bool ,error ){return _ffde .readBool ()};func (_eg *BufferedWriter )FinishByte (){if _eg ._ae ==0{return ;};_eg ._ae =0;_eg ._eac ++;};func (_dfb *BufferedWriter )writeShiftedBytes (_gc []byte )int {for _ ,_cff :=range _gc {_dfb .writeByte (_cff );};return len (_gc );};func (_bf *Reader )ReadByte ()(byte ,error ){if _bf ._bef ==0{return _bf .readBufferByte ();};return _bf .readUnalignedByte ();};func (_dcb *BufferedWriter )Len ()int {return _dcb .byteCapacity ()};const (_a =64;_c =int (^uint (0)>>1););func (_aaf *Reader )Mark (){_aaf ._ded =_aaf ._eb ;_aaf ._acd =_aaf ._bef };func (_agd *SubstreamReader )ReadUint32 ()(uint32 ,error ){_aagb :=make ([]byte ,4);_ ,_acf :=_agd .Read (_aagb );if _acf !=nil {return 0,_acf ;};return _df .BigEndian .Uint32 (_aagb ),nil ;};func (_dda *SubstreamReader )readBool ()(_bgc bool ,_fagd error ){if _dda ._fgc ==0{_dda ._cggg ,_fagd =_dda .readBufferByte ();if _fagd !=nil {return false ,_fagd ;};_bgc =(_dda ._cggg &0x80)!=0;_dda ._cggg ,_dda ._fgc =_dda ._cggg &0x7f,7;return _bgc ,nil ;};_dda ._fgc --;_bgc =(_dda ._cggg &(1<<_dda ._fgc ))!=0;_dda ._cggg &=1<<_dda ._fgc -1;return _bgc ,nil ;};func NewReader (data []byte )*Reader {return &Reader {_afde :data }};func (_dga *SubstreamReader )Mark (){_dga ._gbe =_dga ._gbb ;_dga ._cbda =_dga ._fgc };func (_ffb *BufferedWriter )grow (_ad int ){if _ffb ._af ==nil &&_ad < _a {_ffb ._af =make ([]byte ,_ad ,_a );return ;};_ada :=len (_ffb ._af );if _ffb ._ae !=0{_ada ++;};_ag :=cap (_ffb ._af );switch {case _ad <=_ag /2-_ada :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ffb ._af ),cap (_ffb ._af ),_ad );_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ag ,_ada );copy (_ffb ._af ,_ffb ._af [_ffb .fullOffset ():]);case _ag > _c -_ag -_ad :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_da :=make ([]byte ,2*_ag +_ad );copy (_da ,_ffb ._af );_ffb ._af =_da ;};_ffb ._af =_ffb ._af [:_ada +_ad ];};func (_gd *Reader )ReadBits (n byte )(_egca uint64 ,_aga error ){if n < _gd ._bef {_cdf :=_gd ._bef -n ;_egca =uint64 (_gd ._gfbb >>_cdf );_gd ._gfbb &=1<<_cdf -1;_gd ._bef =_cdf ;return _egca ,nil ;};if n > _gd ._bef {if _gd ._bef > 0{_egca =uint64 (_gd ._gfbb );n -=_gd ._bef ;};for n >=8{_caa ,_gbd :=_gd .readBufferByte ();if _gbd !=nil {return 0,_gbd ;};_egca =_egca <<8+uint64 (_caa );n -=8;};if n > 0{if _gd ._gfbb ,_aga =_gd .readBufferByte ();_aga !=nil {return 0,_aga ;};_deg :=8-n ;_egca =_egca <<n +uint64 (_gd ._gfbb >>_deg );_gd ._gfbb &=1<<_deg -1;_gd ._bef =_deg ;}else {_gd ._bef =0;};return _egca ,nil ;};_gd ._bef =0;return uint64 (_gd ._gfbb ),nil ;};var _ BinaryWriter =&Writer {};func (_bcc *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _d .SeekStart :_bcc ._gbb =uint64 (offset );case _d .SeekCurrent :_bcc ._gbb +=uint64 (offset );case _d .SeekEnd :_bcc ._gbb =_bcc ._bfe +uint64 (offset );default:return 0,_b .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_bcc ._fgc =0;return int64 (_bcc ._gbb ),nil ;};func (_cd *BufferedWriter )ResetBitIndex (){_cd ._ae =0};var _ BinaryWriter =&BufferedWriter {};func (_gdc *SubstreamReader )readBufferByte ()(byte ,error ){if _gdc ._gbb >=_gdc ._bfe {return 0,_d .EOF ;};if _gdc ._gbb >=_gdc ._ebf ||_gdc ._gbb < _gdc ._cec {if _agfd :=_gdc .fillBuffer ();_agfd !=nil {return 0,_agfd ;};};_fb :=_gdc ._cage [_gdc ._gbb -_gdc ._cec ];_gdc ._gbb ++;return _fb ,nil ;};func (_cfa *Writer )WriteBits (bits uint64 ,number int )(_acc int ,_dbac error ){const _degd ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_e .Errorf (_degd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_ecc :=number /8;if _ecc > 0{_bbcg :=number -_ecc *8;for _bfd :=_ecc -1;_bfd >=0;_bfd --{_bdd :=byte ((bits >>uint (_bfd *8+_bbcg ))&0xff);if _dbac =_cfa .WriteByte (_bdd );_dbac !=nil {return _acc ,_e .Wrapf (_dbac ,_degd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ecc -_bfd +1);};};number -=_ecc *8;if number ==0{return _ecc ,nil ;};};var _abcg int ;for _dgef :=0;_dgef < number ;_dgef ++{if _cfa ._gce {_abcg =int ((bits >>uint (number -1-_dgef ))&0x1);}else {_abcg =int (bits &0x1);bits >>=1;};if _dbac =_cfa .WriteBit (_abcg );_dbac !=nil {return _acc ,_e .Wrapf (_dbac ,_degd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dgef );};};return _ecc ,nil ;};func (_dge *SubstreamReader )fillBuffer ()error {if uint64 (_dge ._bca .StreamPosition ())!=_dge ._gbb +_dge ._fe {_ ,_bbc :=_dge ._bca .Seek (int64 (_dge ._gbb +_dge ._fe ),_d .SeekStart );if _bbc !=nil {return _bbc ;};};_dge ._cec =_dge ._gbb ;_egf :=_cee (uint64 (len (_dge ._cage )),_dge ._bfe -_dge ._gbb );_bbdg :=make ([]byte ,_egf );_ffe ,_dgf :=_dge ._bca .Read (_bbdg );if _dgf !=nil {return _dgf ;};for _aab :=uint64 (0);_aab < _egf ;_aab ++{_dge ._cage [_aab ]=_bbdg [_aab ];};_dge ._ebf =_dge ._cec +uint64 (_ffe );return nil ;};func (_cba *SubstreamReader )BitPosition ()int {return int (_cba ._fgc )};func (_ecf *Reader )BitPosition ()int {return int (_ecf ._bef )};type Writer struct{_fec []byte ;_aabd uint8 ;_ggb int ;_gce bool ;};func (_egg *Writer )writeBit (_ceb uint8 )error {if len (_egg ._fec )-1< _egg ._ggb {return _d .EOF ;};_fcf :=_egg ._aabd ;if _egg ._gce {_fcf =7-_egg ._aabd ;};_egg ._fec [_egg ._ggb ]|=byte (uint16 (_ceb <<_fcf )&0xff);_egg ._aabd ++;if _egg ._aabd ==8{_egg ._ggb ++;_egg ._aabd =0;};return nil ;};func (_aba *Writer )ResetBit (){_aba ._aabd =0};func (_gfb *BufferedWriter )byteCapacity ()int {_ff :=len (_gfb ._af )-_gfb ._eac ;if _gfb ._ae !=0{_ff --;};return _ff ;};func (_cda *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ee :=int (_cda ._ae )+skip ;if _ee >=0&&_ee < 8{_cda ._ae =uint8 (_ee );return nil ;};_ee =int (_cda ._ae )+_cda ._eac *8+skip ;if _ee < 0{return _e .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_de :=_ee /8;_aec :=_ee %8;_cda ._ae =uint8 (_aec );if _egc :=_de -_cda ._eac ;_egc > 0&&len (_cda ._af )-1< _de {if _cda ._ae !=0{_egc ++;};_cda .expandIfNeeded (_egc );};_cda ._eac =_de ;return nil ;};func (_be *BufferedWriter )WriteByte (bt byte )error {if _be ._eac > len (_be ._af )-1||(_be ._eac ==len (_be ._af )-1&&_be ._ae !=0){_be .expandIfNeeded (1);};_be .writeByte (bt );return nil ;};func (_acg *Writer )byteCapacity ()int {_fc :=len (_acg ._fec )-_acg ._ggb ;if _acg ._aabd !=0{_fc --;};return _fc ;};func (_aa *BufferedWriter )writeFullBytes (_fdc []byte )int {_add :=copy (_aa ._af [_aa .fullOffset ():],_fdc );_aa ._eac +=_add ;return _add ;};func (_deaa *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _deaa .writeBit (uint8 (bit ));};return _e .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_gb *Reader )ConsumeRemainingBits (){if _gb ._bef !=0{_ ,_aag :=_gb .ReadBits (_gb ._bef );if _aag !=nil {_f .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_aag );};};};func (_dff *BufferedWriter )tryGrowByReslice (_dea int )bool {if _ace :=len (_dff ._af );_dea <=cap (_dff ._af )-_ace {_dff ._af =_dff ._af [:_ace +_dea ];return true ;};return false ;};func (_fdge *SubstreamReader )ReadByte ()(byte ,error ){if _fdge ._fgc ==0{return _fdge .readBufferByte ();};return _fdge .readUnalignedByte ();};func (_ega *SubstreamReader )Length ()uint64 {return _ega ._bfe };func (_cb *BufferedWriter )expandIfNeeded (_cbd int ){if !_cb .tryGrowByReslice (_cbd ){_cb .grow (_cbd );};};type BitWriter interface{WriteBit (_dfg int )error ;WriteBits (_bg uint64 ,_gcd int )(_ced int ,_dd error );FinishByte ();SkipBits (_deaf int )error ;};func (_fff *Reader )readUnalignedByte ()(_abe byte ,_dfbg error ){_gbg :=_fff ._bef ;_abe =_fff ._gfbb <<(8-_gbg );_fff ._gfbb ,_dfbg =_fff .readBufferByte ();if _dfbg !=nil {return 0,_dfbg ;};_abe |=_fff ._gfbb >>_gbg ;_fff ._gfbb &=1<<_gbg -1;return _abe ,nil ;};func (_abc *SubstreamReader )Reset (){_abc ._gbb =_abc ._gbe ;_abc ._fgc =_abc ._cbda };func (_edb *SubstreamReader )Align ()(_aebg byte ){_aebg =_edb ._fgc ;_edb ._fgc =0;return _aebg };func (_ba *SubstreamReader )ReadBits (n byte )(_gedd uint64 ,_cbf error ){if n < _ba ._fgc {_bgd :=_ba ._fgc -n ;_gedd =uint64 (_ba ._cggg >>_bgd );_ba ._cggg &=1<<_bgd -1;_ba ._fgc =_bgd ;return _gedd ,nil ;};if n > _ba ._fgc {if _ba ._fgc > 0{_gedd =uint64 (_ba ._cggg );n -=_ba ._fgc ;};var _aea byte ;for n >=8{_aea ,_cbf =_ba .readBufferByte ();if _cbf !=nil {return 0,_cbf ;};_gedd =_gedd <<8+uint64 (_aea );n -=8;};if n > 0{if _ba ._cggg ,_cbf =_ba .readBufferByte ();_cbf !=nil {return 0,_cbf ;};_dcf :=8-n ;_gedd =_gedd <<n +uint64 (_ba ._cggg >>_dcf );_ba ._cggg &=1<<_dcf -1;_ba ._fgc =_dcf ;}else {_ba ._fgc =0;};return _gedd ,nil ;};_ba ._fgc =0;return uint64 (_ba ._cggg ),nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_fec :data ,_gce :true }};func _cee (_cga ,_fea uint64 )uint64 {if _cga < _fea {return _cga ;};return _fea ;};func (_ddc *Writer )Data ()[]byte {return _ddc ._fec };func (_cgg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cgg ._acb =-1;var _cge int64 ;switch whence {case _d .SeekStart :_cge =offset ;case _d .SeekCurrent :_cge =_cgg ._eb +offset ;case _d .SeekEnd :_cge =int64 (len (_cgg ._afde ))+offset ;default:return 0,_b .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _cge < 0{return 0,_b .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cgg ._eb =_cge ;_cgg ._bef =0;return _cge ,nil ;};func (_caaa *Writer )WriteByte (c byte )error {return _caaa .writeByte (c )};func (_cagd *Writer )Write (p []byte )(int ,error ){if len (p )> _cagd .byteCapacity (){return 0,_d .EOF ;};for _ ,_cbaa :=range p {if _acaa :=_cagd .writeByte (_cbaa );_acaa !=nil {return 0,_acaa ;};};return len (p ),nil ;};func (_ebb *Reader )Align ()(_fa byte ){_fa =_ebb ._bef ;_ebb ._bef =0;return _fa };var (_ _d .Reader =&Reader {};_ _d .ByteReader =&Reader {};_ _d .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ddb *Reader )ReadBit ()(_bc int ,_ffd error ){_fae ,_ffd :=_ddb .readBool ();if _ffd !=nil {return 0,_ffd ;};if _fae {_bc =1;};return _bc ,nil ;};func (_geb *Reader )Length ()uint64 {return uint64 (len (_geb ._afde ))};func NewWriter (data []byte )*Writer {return &Writer {_fec :data }};func (_ecd *Reader )read (_ged []byte )(int ,error ){if _ecd ._eb >=int64 (len (_ecd ._afde )){return 0,_d .EOF ;};_ecd ._acb =-1;_cbb :=copy (_ged ,_ecd ._afde [_ecd ._eb :]);_ecd ._eb +=int64 (_cbb );return _cbb ,nil ;};func (_dfed *Writer )writeByte (_bgf byte )error {if _dfed ._ggb > len (_dfed ._fec )-1{return _d .EOF ;};if _dfed ._ggb ==len (_dfed ._fec )-1&&_dfed ._aabd !=0{return _d .EOF ;};if _dfed ._aabd ==0{_dfed ._fec [_dfed ._ggb ]=_bgf ;_dfed ._ggb ++;return nil ;};if _dfed ._gce {_dfed ._fec [_dfed ._ggb ]|=_bgf >>_dfed ._aabd ;_dfed ._ggb ++;_dfed ._fec [_dfed ._ggb ]=byte (uint16 (_bgf )<<(8-_dfed ._aabd )&0xff);}else {_dfed ._fec [_dfed ._ggb ]|=byte (uint16 (_bgf )<<_dfed ._aabd &0xff);_dfed ._ggb ++;_dfed ._fec [_dfed ._ggb ]=_bgf >>(8-_dfed ._aabd );};return nil ;};func (_ddcd *Writer )SkipBits (skip int )error {const _ggba ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_gcg :=int (_ddcd ._aabd )+skip ;if _gcg >=0&&_gcg < 8{_ddcd ._aabd =uint8 (_gcg );return nil ;};_gcg =int (_ddcd ._aabd )+_ddcd ._ggb *8+skip ;if _gcg < 0{return _e .Errorf (_ggba ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_agg :=_gcg /8;_bga :=_gcg %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_ddcd ._aabd ,_ddcd ._ggb ,int (_ddcd ._aabd )+(_ddcd ._ggb )*8,len (_ddcd ._fec ),cap (_ddcd ._fec ));_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_gcg ,_bga );_ddcd ._aabd =uint8 (_bga );if _cbfg :=_agg -_ddcd ._ggb ;_cbfg > 0&&len (_ddcd ._fec )-1< _agg {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cbfg );return _e .Errorf (_ggba ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ddcd ._ggb =_agg ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_ddcd ._aabd ,_ddcd ._ggb );return nil ;};func (_gfg *Reader )StreamPosition ()int64 {return _gfg ._eb };