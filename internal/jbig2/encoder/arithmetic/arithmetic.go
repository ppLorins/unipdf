//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "bytes";_e "github.com/pplorins/unipdf/v3/common";_ac "github.com/pplorins/unipdf/v3/internal/jbig2/bitmap";_fc "github.com/pplorins/unipdf/v3/internal/jbig2/errors";_a "io";);type codingContext struct{_g []byte ;_ad []byte ;};var _cdce =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_fe *codingContext )mps (_c uint32 )int {return int (_fe ._ad [_c ])};const (_dca =65536;_fdb =20*1024;);func (_fff *Encoder )flush (){_fff .setBits ();_fff ._eef <<=_fff ._eefg ;_fff .byteOut ();_fff ._eef <<=_fff ._eefg ;_fff .byteOut ();_fff .emit ();if _fff ._ec !=0xff{_fff ._acf ++;_fff ._ec =0xff;_fff .emit ();};_fff ._acf ++;_fff ._ec =0xac;_fff ._acf ++;_fff .emit ();};func (_egg *Encoder )Refine (iTemp ,iTarget *_ac .Bitmap ,ox ,oy int )error {for _ba :=0;_ba < iTarget .Height ;_ba ++{var _cc int ;_ead :=_ba +oy ;var (_cbe ,_aeef ,_ccc ,_gf ,_cbc uint16 ;_dbf ,_aaa ,_dac ,_fge ,_gc byte ;);if _ead >=1&&(_ead -1)< iTemp .Height {_dbf =iTemp .Data [(_ead -1)*iTemp .RowStride ];};if _ead >=0&&_ead < iTemp .Height {_aaa =iTemp .Data [_ead *iTemp .RowStride ];};if _ead >=-1&&_ead +1< iTemp .Height {_dac =iTemp .Data [(_ead +1)*iTemp .RowStride ];};if _ba >=1{_fge =iTarget .Data [(_ba -1)*iTarget .RowStride ];};_gc =iTarget .Data [_ba *iTarget .RowStride ];_gd :=uint (6+ox );_cbe =uint16 (_dbf >>_gd );_aeef =uint16 (_aaa >>_gd );_ccc =uint16 (_dac >>_gd );_gf =uint16 (_fge >>6);_afb :=uint (2-ox );_dbf <<=_afb ;_aaa <<=_afb ;_dac <<=_afb ;_fge <<=2;for _cc =0;_cc < iTarget .Width ;_cc ++{_cfc :=(_cbe <<10)|(_aeef <<7)|(_ccc <<4)|(_gf <<1)|_cbc ;_ebc :=_gc >>7;_cfee :=_egg .encodeBit (_egg ._bc ,uint32 (_cfc ),_ebc );if _cfee !=nil {return _cfee ;};_cbe <<=1;_aeef <<=1;_ccc <<=1;_gf <<=1;_cbe |=uint16 (_dbf >>7);_aeef |=uint16 (_aaa >>7);_ccc |=uint16 (_dac >>7);_gf |=uint16 (_fge >>7);_cbc =uint16 (_ebc );_bae :=_cc %8;_abg :=_cc /8+1;if _bae ==5+ox {_dbf ,_aaa ,_dac =0,0,0;if _abg < iTemp .RowStride &&_ead >=1&&(_ead -1)< iTemp .Height {_dbf =iTemp .Data [(_ead -1)*iTemp .RowStride +_abg ];};if _abg < iTemp .RowStride &&_ead >=0&&_ead < iTemp .Height {_aaa =iTemp .Data [_ead *iTemp .RowStride +_abg ];};if _abg < iTemp .RowStride &&_ead >=-1&&(_ead +1)< iTemp .Height {_dac =iTemp .Data [(_ead +1)*iTemp .RowStride +_abg ];};}else {_dbf <<=1;_aaa <<=1;_dac <<=1;};if _bae ==5&&_ba >=1{_fge =0;if _abg < iTarget .RowStride {_fge =iTarget .Data [(_ba -1)*iTarget .RowStride +_abg ];};}else {_fge <<=1;};if _bae ==7{_gc =0;if _abg < iTarget .RowStride {_gc =iTarget .Data [_ba *iTarget .RowStride +_abg ];};}else {_gc <<=1;};_cbe &=7;_aeef &=7;_ccc &=7;_gf &=7;};};return nil ;};func (_dab *Encoder )Reset (){_dab ._cb =0x8000;_dab ._eef =0;_dab ._eefg =12;_dab ._acf =-1;_dab ._ec =0;_dab ._cfe =nil ;_dab ._bc =_eg (_dca );};func (_cefa *Encoder )emit (){if _cefa ._ge ==_fdb {_cefa ._cf =append (_cefa ._cf ,_cefa ._cg );_cefa ._cg =make ([]byte ,_fdb );_cefa ._ge =0;};_cefa ._cg [_cefa ._ge ]=_cefa ._ec ;_cefa ._ge ++;};func (_bbb *Encoder )EncodeBitmap (bm *_ac .Bitmap ,duplicateLineRemoval bool )error {_e .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_ae ,_af uint8 ;_ggg ,_dae ,_ea uint16 ;_bbe ,_ce ,_bbg byte ;_gbb ,_aa ,_cdg int ;_adf ,_bbc []byte ;);for _fg :=0;_fg < bm .Height ;_fg ++{_bbe ,_ce =0,0;if _fg >=2{_bbe =bm .Data [(_fg -2)*bm .RowStride ];};if _fg >=1{_ce =bm .Data [(_fg -1)*bm .RowStride ];if duplicateLineRemoval {_aa =_fg *bm .RowStride ;_adf =bm .Data [_aa :_aa +bm .RowStride ];_cdg =(_fg -1)*bm .RowStride ;_bbc =bm .Data [_cdg :_cdg +bm .RowStride ];if _d .Equal (_adf ,_bbc ){_af =_ae ^1;_ae =1;}else {_af =_ae ;_ae =0;};};};if duplicateLineRemoval {if _fdf :=_bbb .encodeBit (_bbb ._bc ,_da ,_af );_fdf !=nil {return _fdf ;};if _ae !=0{continue ;};};_bbg =bm .Data [_fg *bm .RowStride ];_ggg =uint16 (_bbe >>5);_dae =uint16 (_ce >>4);_bbe <<=3;_ce <<=4;_ea =0;for _gbb =0;_gbb < bm .Width ;_gbb ++{_dbc :=uint32 (_ggg <<11|_dae <<4|_ea );_gbg :=(_bbg &0x80)>>7;_aca :=_bbb .encodeBit (_bbb ._bc ,_dbc ,_gbg );if _aca !=nil {return _aca ;};_ggg <<=1;_dae <<=1;_ea <<=1;_ggg |=uint16 ((_bbe &0x80)>>7);_dae |=uint16 ((_ce &0x80)>>7);_ea |=uint16 (_gbg );_bd :=_gbb %8;_dag :=_gbb /8+1;if _bd ==4&&_fg >=2{_bbe =0;if _dag < bm .RowStride {_bbe =bm .Data [(_fg -2)*bm .RowStride +_dag ];};}else {_bbe <<=1;};if _bd ==3&&_fg >=1{_ce =0;if _dag < bm .RowStride {_ce =bm .Data [(_fg -1)*bm .RowStride +_dag ];};}else {_ce <<=1;};if _bd ==7{_bbg =0;if _dag < bm .RowStride {_bbg =bm .Data [_fg *bm .RowStride +_dag ];};}else {_bbg <<=1;};_ggg &=31;_dae &=127;_ea &=15;};};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_gff *Encoder )encodeBit (_bcf *codingContext ,_fb uint32 ,_bgcc uint8 )error {const _eefe ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_gff ._ca ++;if _fb >=uint32 (len (_bcf ._g )){return _fc .Errorf (_eefe ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fb );};_fef :=_bcf ._g [_fb ];_afe :=_bcf .mps (_fb );_bccb :=_cdce [_fef ]._ecg ;_e .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gff ._ca ,_bgcc ,_fef ,_afe ,_bccb ,_gff ._cb ,_gff ._eef ,_gff ._eefg ,_gff ._ec ,_gff ._acf );if _bgcc ==0{_gff .code0 (_bcf ,_fb ,_bccb ,_fef );}else {_gff .code1 (_bcf ,_fb ,_bccb ,_fef );};return nil ;};func (_gge *Encoder )code1 (_bbaa *codingContext ,_feg uint32 ,_fdc uint16 ,_cab byte ){if _bbaa .mps (_feg )==1{_gge .codeMPS (_bbaa ,_feg ,_fdc ,_cab );}else {_gge .codeLPS (_bbaa ,_feg ,_fdc ,_cab );};};var _ab =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_agb *Encoder )lBlock (){if _agb ._acf >=0{_agb .emit ();};_agb ._acf ++;_agb ._ec =uint8 (_agb ._eef >>19);_agb ._eef &=0x7ffff;_agb ._eefg =8;};func New ()*Encoder {_gb :=&Encoder {};_gb .Init ();return _gb };func (_ecda *Encoder )encodeIAID (_egb ,_cff int )error {if _ecda ._cfe ==nil {_ecda ._cfe =_eg (1<<uint (_egb ));};_cafe :=uint32 (1<<uint32 (_egb +1))-1;_cff <<=uint (32-_egb );_ecdb :=uint32 (1);for _fefb :=0;_fefb < _egb ;_fefb ++{_cgbg :=_ecdb &_cafe ;_bcg :=uint8 ((uint32 (_cff )&0x80000000)>>31);if _bf :=_ecda .encodeBit (_ecda ._cfe ,_cgbg ,_bcg );_bf !=nil {return _bf ;};_ecdb =(_ecdb <<1)|uint32 (_bcg );_cff <<=1;};return nil ;};type Encoder struct{_eef uint32 ;_cb uint16 ;_eefg ,_ec uint8 ;_acf int ;_ca int ;_cf [][]byte ;_cg []byte ;_ge int ;_bc *codingContext ;_cd [13]*codingContext ;_cfe *codingContext ;};func (_adg *Encoder )byteOut (){if _adg ._ec ==0xff{_adg .rBlock ();return ;};if _adg ._eef < 0x8000000{_adg .lBlock ();return ;};_adg ._ec ++;if _adg ._ec !=0xff{_adg .lBlock ();return ;};_adg ._eef &=0x7ffffff;_adg .rBlock ();};func (_dbgb *Encoder )encodeInteger (_gea Class ,_gcbc int )error {const _caf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gcbc > 2000000000||_gcbc < -2000000000{return _fc .Errorf (_caf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gcbc );};_edd :=_dbgb ._cd [_gea ];_bdg :=uint32 (1);var _agg int ;for ;;_agg ++{if _ab [_agg ]._eb <=_gcbc &&_ab [_agg ]._bg >=_gcbc {break ;};};if _gcbc < 0{_gcbc =-_gcbc ;};_gcbc -=int (_ab [_agg ]._bbd );_baeb :=_ab [_agg ]._bb ;for _ff :=uint8 (0);_ff < _ab [_agg ]._acg ;_ff ++{_aae :=_baeb &1;if _ddd :=_dbgb .encodeBit (_edd ,_bdg ,_aae );_ddd !=nil {return _fc .Wrap (_ddd ,_caf ,"");};_baeb >>=1;if _bdg &0x100> 0{_bdg =(((_bdg <<1)|uint32 (_aae ))&0x1ff)|0x100;}else {_bdg =(_bdg <<1)|uint32 (_aae );};};_gcbc <<=32-_ab [_agg ]._be ;for _ddf :=uint8 (0);_ddf < _ab [_agg ]._be ;_ddf ++{_gde :=uint8 ((uint32 (_gcbc )&0x80000000)>>31);if _fgb :=_dbgb .encodeBit (_edd ,_bdg ,_gde );_fgb !=nil {return _fc .Wrap (_fgb ,_caf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_gcbc <<=1;if _bdg &0x100!=0{_bdg =(((_bdg <<1)|uint32 (_gde ))&0x1ff)|0x100;}else {_bdg =(_bdg <<1)|uint32 (_gde );};};return nil ;};func (_daa *Encoder )codeLPS (_gcb *codingContext ,_gcc uint32 ,_egf uint16 ,_fad byte ){_daa ._cb -=_egf ;if _daa ._cb < _egf {_daa ._eef +=uint32 (_egf );}else {_daa ._cb =_egf ;};if _cdce [_fad ]._ccd ==1{_gcb .flipMps (_gcc );};_gcb ._g [_gcc ]=_cdce [_fad ]._bgg ;_daa .renormalize ();};type Class int ;func (_ecd *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _gcd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _bba int64 ;for _ecb ,_dbg :=range _ecd ._cf {_bgc ,_cef :=w .Write (_dbg );if _cef !=nil {return 0,_fc .Wrapf (_cef ,_gcd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ecb );};_bba +=int64 (_bgc );};_ecd ._cg =_ecd ._cg [:_ecd ._ge ];_fa ,_dd :=w .Write (_ecd ._cg );if _dd !=nil {return 0,_fc .Wrap (_dd ,_gcd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bba +=int64 (_fa );return _bba ,nil ;};func (_cdc *Encoder )encodeOOB (_gdeb Class )error {_dagf :=_cdc ._cd [_gdeb ];_aga :=_cdc .encodeBit (_dagf ,1,1);if _aga !=nil {return _aga ;};_aga =_cdc .encodeBit (_dagf ,3,0);if _aga !=nil {return _aga ;};_aga =_cdc .encodeBit (_dagf ,6,0);if _aga !=nil {return _aga ;};_aga =_cdc .encodeBit (_dagf ,12,0);if _aga !=nil {return _aga ;};return nil ;};func (_bcc *Encoder )code0 (_fac *codingContext ,_aea uint32 ,_cde uint16 ,_afd byte ){if _fac .mps (_aea )==0{_bcc .codeMPS (_fac ,_aea ,_cde ,_afd );}else {_bcc .codeLPS (_fac ,_aea ,_cde ,_afd );};};func (_fd *Encoder )DataSize ()int {return _fd .dataSize ()};const _da =0x9b25;func (_db *Encoder )Init (){_db ._bc =_eg (_dca );_db ._cb =0x8000;_db ._eef =0;_db ._eefg =12;_db ._acf =-1;_db ._ec =0;_db ._ge =0;_db ._cg =make ([]byte ,_fdb );for _gg :=0;_gg < len (_db ._cd );_gg ++{_db ._cd [_gg ]=_eg (512);};_db ._cfe =nil ;};var _ _a .WriterTo =&Encoder {};func (_ef *Encoder )setBits (){_dfe :=_ef ._eef +uint32 (_ef ._cb );_ef ._eef |=0xffff;if _ef ._eef >=_dfe {_ef ._eef -=0x8000;};};func (_ag *codingContext )flipMps (_ee uint32 ){_ag ._ad [_ee ]=1-_ag ._ad [_ee ]};type intEncRangeS struct{_eb ,_bg int ;_bb ,_acg uint8 ;_bbd uint16 ;_be uint8 ;};func (_fdg *Encoder )rBlock (){if _fdg ._acf >=0{_fdg .emit ();};_fdg ._acf ++;_fdg ._ec =uint8 (_fdg ._eef >>20);_fdg ._eef &=0xfffff;_fdg ._eefg =7;};func (_bee *Encoder )codeMPS (_fab *codingContext ,_cgd uint32 ,_cdeb uint16 ,_ggd byte ){_bee ._cb -=_cdeb ;if _bee ._cb &0x8000!=0{_bee ._eef +=uint32 (_cdeb );return ;};if _bee ._cb < _cdeb {_bee ._cb =_cdeb ;}else {_bee ._eef +=uint32 (_cdeb );};_fab ._g [_cgd ]=_cdce [_ggd ]._cdeg ;_bee .renormalize ();};func (_cgb *Encoder )Flush (){_cgb ._ge =0;_cgb ._cf =nil ;_cgb ._acf =-1};func (_aee *Encoder )EncodeInteger (proc Class ,value int )(_gec error ){_e .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _gec =_aee .encodeInteger (proc ,value );_gec !=nil {return _fc .Wrap (_gec ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_df *Encoder )EncodeIAID (symbolCodeLength ,value int )(_eaa error ){_e .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _eaa =_df .encodeIAID (symbolCodeLength ,value );_eaa !=nil {return _fc .Wrap (_eaa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func _eg (_ed int )*codingContext {return &codingContext {_g :make ([]byte ,_ed ),_ad :make ([]byte ,_ed )};};func (_beed *Encoder )dataSize ()int {return _fdb *len (_beed ._cf )+_beed ._ge };func (_edb *Encoder )EncodeOOB (proc Class )(_eed error ){_e .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _eed =_edb .encodeOOB (proc );_eed !=nil {return _fc .Wrap (_eed ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type state struct{_ecg uint16 ;_cdeg ,_bgg uint8 ;_ccd uint8 ;};func (_b Class )String ()string {switch _b {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_gdd *Encoder )renormalize (){for {_gdd ._cb <<=1;_gdd ._eef <<=1;_gdd ._eefg --;if _gdd ._eefg ==0{_gdd .byteOut ();};if (_gdd ._cb &0x8000)!=0{break ;};};};func (_cdf *Encoder )Final (){_cdf .flush ()};