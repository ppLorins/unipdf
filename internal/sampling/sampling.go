//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_d "github.com/pplorins/unipdf/v3/internal/bitwise";_a "github.com/pplorins/unipdf/v3/internal/imageutil";_fd "io";);func NewWriter (img _a .ImageBase )*Writer {return &Writer {_ad :_d .NewWriterMSB (img .Data ),_cf :img ,_ee :img .ColorComponents ,_dcf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_db *Reader )ReadSamples (samples []uint32 )(_gd error ){for _cb :=0;_cb < len (samples );_cb ++{samples [_cb ],_gd =_db .ReadSample ();if _gd !=nil {return _gd ;};};return nil ;};func (_c *Reader )ReadSample ()(uint32 ,error ){if _c ._af ==_c ._e .Height {return 0,_fd .EOF ;};_ea ,_eb :=_c ._g .ReadBits (byte (_c ._e .BitsPerComponent ));if _eb !=nil {return 0,_eb ;};_c ._dg --;if _c ._dg ==0{_c ._dg =_c ._e .ColorComponents ;_c ._b ++;};if _c ._b ==_c ._e .Width {if _c ._dc {_c ._g .ConsumeRemainingBits ();};_c ._b =0;_c ._af ++;};return uint32 (_ea ),nil ;};func (_cca *Writer )WriteSamples (samples []uint32 )error {for _cd :=0;_cd < len (samples );_cd ++{if _fab :=_cca .WriteSample (samples [_cd ]);_fab !=nil {return _fab ;};};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_ff []uint32 )error ;};type Writer struct{_cf _a .ImageBase ;_ad *_d .Writer ;_gde ,_ee int ;_dcf bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _fba []uint32 ;_dfe :=bitsPerOutputSample ;var _aba uint32 ;var _abg uint32 ;_bc :=0;_bg :=0;_gb :=0;for _gb < len (data ){if _bc > 0{_ac :=_bc ;if _dfe < _ac {_ac =_dfe ;};_aba =(_aba <<uint (_ac ))|(_abg >>uint (bitsPerInputSample -_ac ));_bc -=_ac ;if _bc > 0{_abg =_abg <<uint (_ac );}else {_abg =0;};_dfe -=_ac ;if _dfe ==0{_fba =append (_fba ,_aba );_dfe =bitsPerOutputSample ;_aba =0;_bg ++;};}else {_ge :=data [_gb ];_gb ++;_gdd :=bitsPerInputSample ;if _dfe < _gdd {_gdd =_dfe ;};_bc =bitsPerInputSample -_gdd ;_aba =(_aba <<uint (_gdd ))|(_ge >>uint (_bc ));if _gdd < bitsPerInputSample {_abg =_ge <<uint (_gdd );};_dfe -=_gdd ;if _dfe ==0{_fba =append (_fba ,_aba );_dfe =bitsPerOutputSample ;_aba =0;_bg ++;};};};for _bc >=bitsPerOutputSample {_bd :=_bc ;if _dfe < _bd {_bd =_dfe ;};_aba =(_aba <<uint (_bd ))|(_abg >>uint (bitsPerInputSample -_bd ));_bc -=_bd ;if _bc > 0{_abg =_abg <<uint (_bd );}else {_abg =0;};_dfe -=_bd ;if _dfe ==0{_fba =append (_fba ,_aba );_dfe =bitsPerOutputSample ;_aba =0;_bg ++;};};if _dfe > 0&&_dfe < bitsPerOutputSample {_aba <<=uint (_dfe );_fba =append (_fba ,_aba );};return _fba ;};func NewReader (img _a .ImageBase )*Reader {return &Reader {_g :_d .NewReader (img .Data ),_e :img ,_dg :img .ColorComponents ,_dc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ab []uint32 ;_df :=bitsPerSample ;var _fe uint32 ;var _fb byte ;_fbd :=0;_ba :=0;_eag :=0;for _eag < len (data ){if _fbd > 0{_eg :=_fbd ;if _df < _eg {_eg =_df ;};_fe =(_fe <<uint (_eg ))|uint32 (_fb >>uint (8-_eg ));_fbd -=_eg ;if _fbd > 0{_fb =_fb <<uint (_eg );}else {_fb =0;};_df -=_eg ;if _df ==0{_ab =append (_ab ,_fe );_df =bitsPerSample ;_fe =0;_ba ++;};}else {_ffd :=data [_eag ];_eag ++;_feb :=8;if _df < _feb {_feb =_df ;};_fbd =8-_feb ;_fe =(_fe <<uint (_feb ))|uint32 (_ffd >>uint (_fbd ));if _feb < 8{_fb =_ffd <<uint (_feb );};_df -=_feb ;if _df ==0{_ab =append (_ab ,_fe );_df =bitsPerSample ;_fe =0;_ba ++;};};};for _fbd >=bitsPerSample {_fa :=_fbd ;if _df < _fa {_fa =_df ;};_fe =(_fe <<uint (_fa ))|uint32 (_fb >>uint (8-_fa ));_fbd -=_fa ;if _fbd > 0{_fb =_fb <<uint (_fa );}else {_fb =0;};_df -=_fa ;if _df ==0{_ab =append (_ab ,_fe );_df =bitsPerSample ;_fe =0;_ba ++;};};return _ab ;};type Reader struct{_e _a .ImageBase ;_g *_d .Reader ;_b ,_af ,_dg int ;_dc bool ;};type SampleWriter interface{WriteSample (_ga uint32 )error ;WriteSamples (_cc []uint32 )error ;};func (_ged *Writer )WriteSample (sample uint32 )error {if _ ,_cff :=_ged ._ad .WriteBits (uint64 (sample ),_ged ._cf .BitsPerComponent );_cff !=nil {return _cff ;};_ged ._ee --;if _ged ._ee ==0{_ged ._ee =_ged ._cf .ColorComponents ;_ged ._gde ++;};if _ged ._gde ==_ged ._cf .Width {if _ged ._dcf {_ged ._ad .FinishByte ();};_ged ._gde =0;};return nil ;};