//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_e "bytes";_c "errors";_f "fmt";_gd "github.com/pplorins/unipdf/v3/common";_gg "github.com/pplorins/unipdf/v3/contentstream";_gf "github.com/pplorins/unipdf/v3/contentstream/draw";_fc "github.com/pplorins/unipdf/v3/core";_ba "github.com/pplorins/unipdf/v3/internal/license";_be "github.com/pplorins/unipdf/v3/internal/transform";_a "github.com/pplorins/unipdf/v3/model";_eb "image";_dc "io";_bb "math";_cc "os";_b "sort";_g "strconv";_bd "strings";_ga "unicode";);

// SetMargins sets the margins TOC line.
func (_bdfd *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_bdfd ._abcc =left ;_bfafg :=&_bdfd ._cabdd ._gggf ;_bfafg .Left =_bdfd ._abcc +float64 (_bdfd ._fced -1)*_bdfd ._gfgc ;_bfafg .Right =right ;_bfafg .Top =top ;_bfafg .Bottom =bottom ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_gfdf *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_daca :=&_gfdf ._gfede ;_daca .Left =left ;_daca .Right =right ;_daca .Top =top ;_daca .Bottom =bottom ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_acgg *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _acgg ._eabg .Left ,_acgg ._eabg .Right ,_acgg ._eabg .Top ,_acgg ._eabg .Bottom ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_bgfcc *Invoice )TotalLines ()[][2]*InvoiceCell {_gefbe :=[][2]*InvoiceCell {_bgfcc ._beabb };_gefbe =append (_gefbe ,_bgfcc ._bbbe ...);return append (_gefbe ,_bgfcc ._dcdf );};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_ffab *Division )Width ()float64 {return 0};

// AddSection adds a new content section at the end of the invoice.
func (_bged *Invoice )AddSection (title ,content string ){_bged ._dagab =append (_bged ._dagab ,[2]string {title ,content });};func _cbcd (_dfga string ,_ffaa TextStyle )*Paragraph {_gbbfe :=&Paragraph {_aeea :_dfga ,_ebegd :_ffaa .Font ,_gadb :_ffaa .FontSize ,_dcfaad :1.0,_aabgd :true ,_fcgfg :true ,_dggge :TextAlignmentLeft ,_eaccb :0,_fdcf :1,_dfee :1,_aega :PositionRelative };_gbbfe .SetColor (_ffaa .Color );return _gbbfe ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_gab *Chapter )NewSubchapter (title string )*Chapter {_bbb :=_begg (_gab ._eafb ._ebegd );_bbb .FontSize =14;_gab ._gfg ++;_fbbfe :=_eca (_gab ,_gab ._dea ,_gab ._bfe ,title ,_gab ._gfg ,_bbb );_gab .Add (_fbbfe );return _fbbfe ;};

// Add adds a new Drawable to the chapter.
func (_bdcd *Chapter )Add (d Drawable )error {if Drawable (_bdcd )==d {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};switch _gbg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_bdcd ._gag =append (_bdcd ._gag ,d );case containerDrawable :_beee ,_gcfd :=_gbg .ContainerComponent (_bdcd );if _gcfd !=nil {return _gcfd ;};_bdcd ._gag =append (_bdcd ._gag ,_beee );default:_gd .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_ebf *Invoice )NoteStyle ()TextStyle {return _ebf ._cccb };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetBorderColor sets the cell's border color.
func (_dgea *TableCell )SetBorderColor (col Color ){_dgea ._dedeb =_a .NewPdfColorDeviceRGB (col .ToRGB ());_dgea ._edec =_a .NewPdfColorDeviceRGB (col .ToRGB ());_dgea ._beeb =_a .NewPdfColorDeviceRGB (col .ToRGB ());_dgea ._ecaf =_a .NewPdfColorDeviceRGB (col .ToRGB ());};

// SetBorderWidth sets the border width.
func (_abgg *Rectangle )SetBorderWidth (bw float64 ){_abgg ._gecfd =bw };

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_fbfa *TOC )SetLineStyle (style TextStyle ){_fbfa .SetLineNumberStyle (style );_fbfa .SetLineTitleStyle (style );_fbfa .SetLineSeparatorStyle (style );_fbfa .SetLinePageStyle (style );};

// Rows returns the total number of rows the table has.
func (_gabeb *Table )Rows ()int {return _gabeb ._deba };

// Scale scales Image by a constant factor, both width and height.
func (_gcbe *Image )Scale (xFactor ,yFactor float64 ){_gcbe ._baed =xFactor *_gcbe ._baed ;_gcbe ._dce =yFactor *_gcbe ._dce ;};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_gaec *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_gaec ._egb .Left =left ;_gaec ._egb .Right =right ;_gaec ._egb .Top =top ;_gaec ._egb .Bottom =bottom ;};func _dgffe (_dgbf ,_ggfcf ,_cafd TextChunk ,_dafbf uint ,_ccbbb TextStyle )*TOCLine {_deec :=_fdege (_ccbbb );_deec .SetEnableWrap (true );_deec .SetTextAlignment (TextAlignmentLeft );_deec .SetMargins (0,0,2,2);_cbae :=&TOCLine {_cabdd :_deec ,Number :_dgbf ,Title :_ggfcf ,Page :_cafd ,Separator :TextChunk {Text :"\u002e",Style :_ccbbb },_abcc :0,_fced :_dafbf ,_gfgc :10,_gdfa :PositionRelative };_deec ._gggf .Left =_cbae ._abcc +float64 (_cbae ._fced -1)*_cbae ._gfgc ;_deec ._ggdd =_cbae .prepareParagraph ;return _cbae ;};func (_eaaa *StyledParagraph )getTextLineWidth (_bddg []*TextChunk )float64 {var _fbeg float64 ;_cadb :=len (_bddg );for _dgec ,_ddbg :=range _bddg {_bdfcf :=&_ddbg .Style ;_ebaa :=len (_ddbg .Text );for _cebae ,_fgfa :=range _ddbg .Text {if _fgfa =='\u000A'{continue ;};_dfbcg ,_baebbd :=_bdfcf .Font .GetRuneMetrics (_fgfa );if !_baebbd {_gd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fgfa );return -1;};_fbeg +=_bdfcf .FontSize *_dfbcg .Wx ;if _fgfa !=' '&&(_dgec !=_cadb -1||_cebae !=_ebaa -1){_fbeg +=_bdfcf .CharSpacing *1000.0;};};};return _fbeg ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_ffcbf *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cfda :=_gf .Rectangle {Opacity :1.0,X :_ffcbf ._baca ,Y :ctx .PageHeight -_ffcbf ._aecea -_ffcbf ._dfdbc ,Height :_ffcbf ._dfdbc ,Width :_ffcbf ._acbc };if _ffcbf ._bdecg !=nil {_cfda .FillEnabled =true ;_cfda .FillColor =_ffcbf ._bdecg ;};if _ffcbf ._cefa !=nil &&_ffcbf ._gecfd > 0{_cfda .BorderEnabled =true ;_cfda .BorderColor =_ffcbf ._cefa ;_cfda .BorderWidth =_ffcbf ._gecfd ;};_egff ,_ddge :=_efce .setOpacity (_ffcbf ._dbdb ,_ffcbf ._dede );if _ddge !=nil {return nil ,ctx ,_ddge ;};_acaf ,_ ,_ddge :=_cfda .Draw (_egff );if _ddge !=nil {return nil ,ctx ,_ddge ;};if _ddge =_efce .addContentsByString (string (_acaf ));_ddge !=nil {return nil ,ctx ,_ddge ;};return []*Block {_efce },ctx ,nil ;};

// NewTOC creates a new table of contents.
func (_aace *Creator )NewTOC (title string )*TOC {_fgdc :=_aace .NewTextStyle ();_fgdc .Font =_aace ._aef ;return _ffebg (title ,_aace .NewTextStyle (),_fgdc );};

// NewColumn returns a new column for the line items invoice table.
func (_gcfbd *Invoice )NewColumn (description string )*InvoiceCell {return _gcfbd .newColumn (description ,CellHorizontalAlignmentLeft );};

// TitleStyle returns the style properties used to render the invoice title.
func (_cgca *Invoice )TitleStyle ()TextStyle {return _cgca ._adff };

// SkipCells skips over a specified number of cells in the table.
func (_eece *Table )SkipCells (num int ){if num < 0{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_eece ._adab +=num ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_eefe *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _cggf float64 ;var _dafe []*StyledParagraph ;for _ ,_fbbd :=range _eefe ._deaa {_fadc :=_fdege (_eefe ._gadf );_fadc .SetEnableWrap (false );_fadc .SetTextAlignment (TextAlignmentRight );_fadc .Append (_fbbd ._dcdfc .Text ).Style =_fbbd ._dcdfc .Style ;_faee :=_fadc .getTextWidth ()/1000.0/ctx .Width ;if _cggf < _faee {_cggf =_faee ;};_dafe =append (_dafe ,_fadc );};_cefge :=_gagg (2);_cefge .SetColumnWidths (_cggf ,1-_cggf );_cefge .SetMargins (_eefe ._dfbcd ,0,0,0);for _fbed ,_feec :=range _eefe ._deaa {_ebbad :=_cefge .NewCell ();_ebbad .SetIndent (0);_ebbad .SetContent (_dafe [_fbed ]);_ebbad =_cefge .NewCell ();_ebbad .SetIndent (0);_ebbad .SetContent (_feec ._gbab );};return _cefge .GeneratePageBlocks (ctx );};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetShowLinks sets visibility of links for the TOC lines.
func (_ggaeg *TOC )SetShowLinks (showLinks bool ){_ggaeg ._faef =showLinks };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gaf *Creator )NewStyledParagraph ()*StyledParagraph {return _fdege (_gaf .NewTextStyle ())};

// DrawHeader sets a function to draw a header on created output pages.
func (_fbcb *Creator )DrawHeader (drawHeaderFunc func (_egg *Block ,_ebbf HeaderFunctionArgs )){_fbcb ._ceg =drawHeaderFunc ;};

// NewDivision returns a new Division container component.
func (_cgag *Creator )NewDivision ()*Division {return _egge ()};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_egfe []_gf .CubicBezierCurve ;FillEnabled bool ;_ffgbb *_a .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;_dffb *_a .PdfColorDeviceRGB ;};func (_ecce *Invoice )generateNoteBlocks (_aefg DrawContext )([]*Block ,DrawContext ,error ){_cdeee :=_egge ();_gbgf :=append ([][2]string {_ecce ._cfge ,_ecce ._fagg },_ecce ._dagab ...);for _ ,_ddd :=range _gbgf {if _ddd [1]!=""{_begd :=_ecce .drawSection (_ddd [0],_ddd [1]);for _ ,_bead :=range _begd {_cdeee .Add (_bead );};_faeg :=_fdege (_ecce ._eeec );_faeg .SetMargins (0,0,10,0);_cdeee .Add (_faeg );};};return _cdeee .GeneratePageBlocks (_aefg );};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_edbe *Table )SetMargins (left ,right ,top ,bottom float64 ){_edbe ._cbabb .Left =left ;_edbe ._cbabb .Right =right ;_edbe ._cbabb .Top =top ;_edbe ._cbabb .Bottom =bottom ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_cfeb *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if endRow <=0{return _c .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");};_cfeb ._ccfg =true ;_cfeb ._ddegg =startRow ;_cfeb ._eecgb =endRow ;return nil ;};

// SetFillColor sets the fill color.
func (_cabe *Rectangle )SetFillColor (col Color ){_cabe ._bdecg =_a .NewPdfColorDeviceRGB (col .ToRGB ())};func _acbd (_age string )(*Image ,error ){_cfad ,_bcbaa :=_cc .Open (_age );if _bcbaa !=nil {return nil ,_bcbaa ;};defer _cfad .Close ();_gdbd ,_bcbaa :=_a .ImageHandling .Read (_cfad );if _bcbaa !=nil {_gd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bcbaa );return nil ,_bcbaa ;};return _caa (_gdbd );};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_abcd string ;_fefc *Image ;_ebgf *InvoiceAddress ;_fcbg *InvoiceAddress ;_afbg string ;_cdgc [2]*InvoiceCell ;_dfdb [2]*InvoiceCell ;_eebf [2]*InvoiceCell ;_aafaa [][2]*InvoiceCell ;_efag []*InvoiceCell ;_baa [][]*InvoiceCell ;_beabb [2]*InvoiceCell ;_dcdf [2]*InvoiceCell ;_bbbe [][2]*InvoiceCell ;_cfge [2]string ;_fagg [2]string ;_dagab [][2]string ;_eeec TextStyle ;_gee TextStyle ;_adff TextStyle ;_fgaeb TextStyle ;_baebc TextStyle ;_cccb TextStyle ;_ggf TextStyle ;_fcged InvoiceCellProps ;_bdgab InvoiceCellProps ;_gbgb InvoiceCellProps ;_gaaa InvoiceCellProps ;_cgbb Positioning ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_edgd *Paragraph )SetEnableWrap (enableWrap bool ){_edgd ._aabgd =enableWrap ;_edgd ._fcgfg =false ;};func (_efdc *FilledCurve )draw (_beea string )([]byte ,*_a .PdfRectangle ,error ){_ffd :=_gf .NewCubicBezierPath ();for _ ,_beaaa :=range _efdc ._egfe {_ffd =_ffd .AppendCurve (_beaaa );};creator :=_gg .NewContentCreator ();creator .Add_q ();if _efdc .FillEnabled {creator .Add_rg (_efdc ._ffgbb .R (),_efdc ._ffgbb .G (),_efdc ._ffgbb .B ());};if _efdc .BorderEnabled {creator .Add_RG (_efdc ._dffb .R (),_efdc ._dffb .G (),_efdc ._dffb .B ());creator .Add_w (_efdc .BorderWidth );};if len (_beea )> 1{creator .Add_gs (_fc .PdfObjectName (_beea ));};_gf .DrawBezierPathWithCreator (_ffd ,creator );creator .Add_h ();if _efdc .FillEnabled &&_efdc .BorderEnabled {creator .Add_B ();}else if _efdc .FillEnabled {creator .Add_f ();}else if _efdc .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_egd :=_ffd .GetBoundingBox ();if _efdc .BorderEnabled {_egd .Height +=_efdc .BorderWidth ;_egd .Width +=_efdc .BorderWidth ;_egd .X -=_efdc .BorderWidth /2;_egd .Y -=_efdc .BorderWidth /2;};_daab :=&_a .PdfRectangle {};_daab .Llx =_egd .X ;_daab .Lly =_egd .Y ;_daab .Urx =_egd .X +_egd .Width ;_daab .Ury =_egd .Y +_egd .Height ;return creator .Bytes (),_daab ,nil ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_bdeg *_gf .Polyline ;_bcgf float64 ;};

// SetWidthRight sets border width for right.
func (_cdfd *border )SetWidthRight (bw float64 ){_cdfd ._edea =bw };

// NewPageBreak create a new page break.
func (_aafc *Creator )NewPageBreak ()*PageBreak {return _ccbe ()};

// Margins.  Can be page Margins, or Margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};func (_cfce *Division )ctxHeight (_acag float64 )float64 {var _beafe float64 ;for _ ,_ccgb :=range _cfce ._fafc {switch _ccc :=_ccgb .(type ){case *Paragraph :if _ccc ._aabgd {_ccc .SetWidth (_acag );};_beafe +=_ccc .Height ()+_ccc ._bgfcg .Top +_ccc ._bgfcg .Bottom ;case *StyledParagraph :if _ccc ._bgeg {_ccc .SetWidth (_acag );};_beafe +=_ccc .Height ()+_ccc ._gggf .Top +_ccc ._gggf .Bottom ;default:_beafe +=_ccc .Height ();};};return _beafe ;};type border struct{_dde float64 ;_efdg float64 ;_fbbf float64 ;_bba float64 ;_bcd *_a .PdfColorDeviceRGB ;_aff *_a .PdfColorDeviceRGB ;_fdgd float64 ;_dbd *_a .PdfColorDeviceRGB ;_fdba float64 ;_ddbb *_a .PdfColorDeviceRGB ;_edea float64 ;_ac *_a .PdfColorDeviceRGB ;_abe float64 ;LineStyle _gf .LineStyle ;_gff CellBorderStyle ;_edf CellBorderStyle ;_aece CellBorderStyle ;_eefb CellBorderStyle ;};func _afbcb (_ecga []_gf .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_agde :&_gf .PolyBezierCurve {Curves :_ecga ,BorderColor :_a .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_aagbf :1.0,_gecf :1.0};};

// NewCellProps returns the default properties of an invoice cell.
func (_fceb *Invoice )NewCellProps ()InvoiceCellProps {_dafa :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_fceb ._eeec ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_dafa ,BorderColor :_dafa ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_dcfaab *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_fbgd ,_accga :=_dcfaab .Wrap (width );if _accga !=nil {return nil ,_accga ;};_ecgb :=int (height /_dcfaab .Style .FontSize );if _ecgb >=len (_fbgd ){return nil ,nil ;};_cecff :="\u000a";_dcfaab .Text =_bd .Replace (_bd .Join (_fbgd [:_ecgb ],"\u0020"),_cecff +"\u0020",_cecff ,-1);_dgaf :=_bd .Replace (_bd .Join (_fbgd [_ecgb :],"\u0020"),_cecff +"\u0020",_cecff ,-1);return NewTextChunk (_dgaf ,_dcfaab .Style ),nil ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_efbf *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _efdga (number ,title ,page ,level ,_efbf .NewTextStyle ());};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_cgcgg *Image )SetPos (x ,y float64 ){_cgcgg ._dbdg =PositionAbsolute ;_cgcgg ._afge =x ;_cgcgg ._ggbb =y ;};

// GetOptimizer returns current PDF optimizer.
func (_cbab *Creator )GetOptimizer ()_a .Optimizer {return _cbab ._fdef };

// Lines returns all the lines the table of contents has.
func (_ffeee *TOC )Lines ()[]*TOCLine {return _ffeee ._bfbf };

// Height returns the current page height.
func (_bgac *Creator )Height ()float64 {return _bgac ._aba };func (_dffd *Creator )getActivePage ()*_a .PdfPage {if _dffd ._bfge ==nil {if len (_dffd ._gcbc )==0{return nil ;};return _dffd ._gcbc [len (_dffd ._gcbc )-1];};return _dffd ._bfge ;};

// SetBorderWidth sets the border width.
func (_cecf *Polygon )SetBorderWidth (borderWidth float64 ){_cecf ._dfefg .BorderWidth =borderWidth };

// SetIndent sets the cell's left indent.
func (_feacg *TableCell )SetIndent (indent float64 ){_feacg ._efde =indent };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_aagb *Creator )SetOptimizer (optimizer _a .Optimizer ){_aagb ._fdef =optimizer };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_beff *Invoice )SetNoteStyle (style TextStyle ){_beff ._cccb =style };

// SetBorderColor sets the border color.
func (_aaag *Polygon )SetBorderColor (color Color ){_aaag ._dfefg .BorderColor =_a .NewPdfColorDeviceRGB (color .ToRGB ());};func (_fdec *Image )makeXObject ()error {_fdeg :=_fdec ._gdda ;if _fdeg ==nil {_fdeg =_fc .NewFlateEncoder ();};_fdcb ,_egad :=_a .NewXObjectImageFromImage (_fdec ._bgffc ,nil ,_fdeg );if _egad !=nil {_gd .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_egad );return _egad ;};_fdec ._efed =_fdcb ;return nil ;};

// SetWidth sets line width.
func (_fgae *Curve )SetWidth (width float64 ){_fgae ._gdde =width };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_gfac *Creator )SetPageLabels (pageLabels _fc .PdfObject ){_gfac ._cae =pageLabels };

// SkipRows skips over a specified number of rows in the table.
func (_ccfce *Table )SkipRows (num int ){_beac :=num *_ccfce ._ddgf -1;if _beac < 0{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_ccfce ._adab +=_beac ;};

// Logo returns the logo of the invoice.
func (_cgff *Invoice )Logo ()*Image {return _cgff ._fefc };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_gbgg *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gbgg ._bgfcg .Left ,_gbgg ._bgfcg .Right ,_gbgg ._bgfcg .Top ,_gbgg ._bgfcg .Bottom ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// ColorRGBFrom8bit creates a Color from 8bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {_fede :=rgbColor {};_fede ._ceb =float64 (r )/255.0;_fede ._aggg =float64 (g )/255.0;_fede ._dfa =float64 (b )/255.0;return _fede ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetHeight sets the Image's document height to specified h.
func (_fged *Image )SetHeight (h float64 ){_fged ._dce =h };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};func _dfed (_gffg ,_fdefe ,_egeg ,_edaa float64 )*Line {_cea :=&Line {};_cea ._dfeb =_gffg ;_cea ._aabe =_fdefe ;_cea ._ffcc =_egeg ;_cea ._aafdf =_edaa ;_cea ._feegg =_a .NewPdfColorDeviceRGB (0,0,0);_cea ._ccgba =1.0;return _cea ;};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_cgfdf *Ellipse )GetCoords ()(float64 ,float64 ){return _cgfdf ._caf ,_cgfdf ._dbff };

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_cde *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_cde ._ebbg =toc ;};

// Text sets the text content of the Paragraph.
func (_fffa *Paragraph )Text ()string {return _fffa ._aeea };

// MoveY moves the drawing context to absolute position y.
func (_gffc *Creator )MoveY (y float64 ){_gffc ._aaa .Y =y };

// SetMargins sets the margins of the paragraph.
func (_egfg *List )SetMargins (left ,right ,top ,bottom float64 ){_egfg ._eacf .Left =left ;_egfg ._eacf .Right =right ;_egfg ._eacf .Top =top ;_egfg ._eacf .Bottom =bottom ;};

// Write output of creator to io.Writer interface.
func (_acaa *Creator )Write (ws _dc .Writer )error {if _febbe :=_acaa .Finalize ();_febbe !=nil {return _febbe ;};_cffa :=_a .NewPdfWriter ();_cffa .SetOptimizer (_acaa ._fdef );if _acaa ._dcbf !=nil {_fgcf :=_cffa .SetForms (_acaa ._dcbf );if _fgcf !=nil {_gd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fgcf );return _fgcf ;};};if _acaa ._eceb !=nil {_cffa .AddOutlineTree (_acaa ._eceb );}else if _acaa ._gbbd !=nil &&_acaa .AddOutlines {_cffa .AddOutlineTree (&_acaa ._gbbd .ToPdfOutline ().PdfOutlineTreeNode );};if _acaa ._cae !=nil {if _dfdc :=_cffa .SetPageLabels (_acaa ._cae );_dfdc !=nil {_gd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_dfdc );return _dfdc ;};};if _acaa ._ffag !=nil {for _ ,_adg :=range _acaa ._ffag {_gcbb :=_adg .SubsetRegistered ();if _gcbb !=nil {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_gcbb );return _gcbb ;};};};if _acaa ._bbad !=nil {_cade :=_acaa ._bbad (&_cffa );if _cade !=nil {_gd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_cade );return _cade ;};};for _ ,_egac :=range _acaa ._gcbc {_cgb :=_cffa .AddPage (_egac );if _cgb !=nil {_gd .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_cgb );return _cgb ;};};_fba :=_cffa .Write (ws );if _fba !=nil {return _fba ;};return nil ;};

// Scale block by specified factors in the x and y directions.
func (_gcf *Block )Scale (sx ,sy float64 ){_bga :=_gg .NewContentCreator ().Scale (sx ,sy ).Operations ();*_gcf ._cd =append (*_bga ,*_gcf ._cd ...);_gcf ._cd .WrapIfNeeded ();_gcf ._gc *=sx ;_gcf ._bg *=sy ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_cdg *Creator )NewParagraph (text string )*Paragraph {return _cbcd (text ,_cdg .NewTextStyle ())};

// GeneratePageBlocks generates a page break block.
func (_cgcb *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abeb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_gbga :=ctx ;_gbga .Y =ctx .Margins .Top ;_gbga .X =ctx .Margins .Left ;_gbga .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_gbga .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_gbga ;return _abeb ,ctx ,nil ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_bdaa *Paragraph )SetColor (col Color ){_ebdc :=_a .NewPdfColorDeviceRGB (col .ToRGB ());_bdaa ._aegd =*_ebdc ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_cdegb *TOC )SetLineSeparatorStyle (style TextStyle ){_cdegb ._egada =style };

// SetTitle sets the title of the invoice.
func (_eccfg *Invoice )SetTitle (title string ){_eccfg ._abcd =title };

// GeneratePageBlocks draws the curve onto page blocks.
func (_aagef *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ced :=NewBlock (ctx .PageWidth ,ctx .PageHeight );var _gabb []string ;_gabb =append (_gabb ,_f .Sprintf ("\u0025\u002e\u0032\u0066\u0020\u0077",_aagef ._gdde ));_gabb =append (_gabb ,_f .Sprintf ("\u0025\u002e\u0033\u0066\u0020\u0025\u002e\u0033\u0066\u0020\u0025\u002e3\u0066\u0020\u0052\u0047",_aagef ._aabd [0],_aagef ._aabd [1],_aagef ._aabd [2]));_gabb =append (_gabb ,_f .Sprintf ("%\u002e\u0032\u0066\u0020\u0025\u002e\u0032\u0066\u0020\u006d",_aagef ._dcfa ,ctx .PageHeight -_aagef ._agga ));_gabb =append (_gabb ,_f .Sprintf ("\u0025\u002e\u0035f \u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0025\u002e\u0035\u0066\u0020\u0076\u0020\u0053",_aagef ._baeb ,ctx .PageHeight -_aagef ._bcfd ,_aagef ._eddb ,ctx .PageHeight -_aagef ._bdcc ));_bffg :=_ced .addContentsByString (_bd .Join (_gabb ,"\u000a"));if _bffg !=nil {return nil ,ctx ,_bffg ;};return []*Block {_ced },ctx ,nil ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_ddca *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _ccf (xc ,yc ,width ,height );};func (_ebdd *StyledParagraph )getLineHeight (_ffdgb int )(_ebcg ,_dgba float64 ){if _ebdd ._aaccf ==nil ||len (_ebdd ._aaccf )==0{_ebdd .wrapText ();};if _ffdgb < 0||_ffdgb > len (_ebdd ._aaccf )-1{_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_ffdgb );return 0,0;};_caefg :=_ebdd ._aaccf [_ffdgb ];for _ ,_bddf :=range _caefg {_bcdf ,_cbcb :=_bddf .Style .Font .GetFontDescriptor ();if _cbcb !=nil {_gd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");};var _fcga float64 ;if _bcdf !=nil {if _fcga ,_cbcb =_bcdf .GetCapHeight ();_cbcb !=nil {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_cbcb );};};if int (_fcga )<=0{_gd .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");_fcga =1000;};_abdg :=_fcga /1000.0*_bddf .Style .FontSize *_ebdd ._dbdfb ;if _abdg > _ebcg {_ebcg =_abdg ;};_abdg =_ebdd ._dbdfb *_bddf .Style .FontSize ;if _abdg > _dgba {_dgba =_abdg ;};};return _ebcg ,_dgba ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_ffed *Creator )NewPage ()*_a .PdfPage {_ebedd :=_ffed .newPage ();_ffed ._gcbc =append (_ffed ._gcbc ,_ebedd );_ffed ._aaa .Page ++;return _ebedd ;};

// SetOpacity sets opacity for Image.
func (_agec *Image )SetOpacity (opacity float64 ){_agec ._addg =opacity };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_efda *Creator )RotateDeg (angleDeg int64 )error {_adfg :=_efda .getActivePage ();if _adfg ==nil {_gd .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_gd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _aaff int64 ;if _adfg .Rotate !=nil {_aaff =*(_adfg .Rotate );};_aaff +=angleDeg ;_adfg .Rotate =&_aaff ;return nil ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_bccbe *TOCLine )SetLink (page int64 ,x ,y float64 ){_bccbe ._agddb =x ;_bccbe ._cbabbc =y ;_bccbe ._becg =page ;_egfcf :=_bccbe ._cabdd ._baba .Color ;_bccbe .Number .Style .Color =_egfcf ;_bccbe .Title .Style .Color =_egfcf ;_bccbe .Separator .Style .Color =_egfcf ;_bccbe .Page .Style .Color =_egfcf ;};

// SetSubtotal sets the subtotal of the invoice.
func (_bbbb *Invoice )SetSubtotal (value string ){_bbbb ._beabb [1].Value =value };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_bfcc *Invoice )SetAddressHeadingStyle (style TextStyle ){_bfcc ._baebc =style };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_gcg *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_gcg ._ddgf {_gd .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gcg ._bdfba =widths ;return nil ;};

// SkipOver skips over a specified number of rows and cols.
func (_aebb *Table )SkipOver (rows ,cols int ){_bdagb :=rows *_aebb ._ddgf +cols -1;if _bdagb < 0{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");return ;};_aebb ._adab +=_bdagb ;};func (_eagc *Invoice )newCell (_fea string ,_agea InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_agea ,_fea };};func (_eacg *Invoice )setCellBorder (_agag *TableCell ,_fff *InvoiceCell ){for _ ,_cgee :=range _fff .BorderSides {_agag .SetBorder (_cgee ,CellBorderStyleSingle ,_fff .BorderWidth );};_agag .SetBorderColor (_fff .BorderColor );};

// SetSellerAddress sets the seller address of the invoice.
func (_bfgae *Invoice )SetSellerAddress (address *InvoiceAddress ){_bfgae ._fcbg =address };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);func _caeff (_cfca int64 ,_eagd ,_dgde ,_cfcaa float64 )*_a .PdfAnnotation {_cdcbf :=_a .NewPdfAnnotationLink ();_bece :=_a .NewBorderStyle ();_bece .SetBorderWidth (0);_cdcbf .BS =_bece .ToPdfObject ();if _cfca < 0{_cfca =0;};_cdcbf .Dest =_fc .MakeArray (_fc .MakeInteger (_cfca ),_fc .MakeName ("\u0058\u0059\u005a"),_fc .MakeFloat (_eagd ),_fc .MakeFloat (_dgde ),_fc .MakeFloat (_cfcaa ));return _cdcbf .PdfAnnotation ;};

// SetPos sets absolute positioning with specified coordinates.
func (_accb *StyledParagraph )SetPos (x ,y float64 ){_accb ._efdbe =PositionAbsolute ;_accb ._gcbf =x ;_accb ._dgfc =y ;};

// SetStyleRight sets border style for right side.
func (_bdg *border )SetStyleRight (style CellBorderStyle ){_bdg ._edf =style };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_ccaa *StyledParagraph ;_bfbf []*TOCLine ;_dcaeb TextStyle ;_bdgb TextStyle ;_egada TextStyle ;_fdff TextStyle ;_debda string ;_eebg float64 ;_gfede Margins ;_bfdfg Positioning ;_acba TextStyle ;_faef bool ;};func (_egfc *InvoiceAddress )fmtLine (_dfbbg ,_efc string ,_gacg bool )string {if _gacg {_efc ="";};return _f .Sprintf ("\u0025\u0073\u0025s\u000a",_efc ,_dfbbg );};

// SetLogo sets the logo of the invoice.
func (_beb *Invoice )SetLogo (logo *Image ){_beb ._fefc =logo };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_dfbb *Creator )MoveRight (dx float64 ){_dfbb ._aaa .X +=dx };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// Width returns the width of the Paragraph.
func (_cgcf *StyledParagraph )Width ()float64 {if _cgcf ._bgeg &&int (_cgcf ._eeeac )> 0{return _cgcf ._eeeac ;};return _cgcf .getTextWidth ()/1000.0;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};func (_cbgc *StyledParagraph )split (_fbaa DrawContext )(_fbgb ,_cdbea *StyledParagraph ,_gbgdf error ){if _gbgdf =_cbgc .wrapChunks (false );_gbgdf !=nil {return nil ,nil ,_gbgdf ;};_edfa :=func (_addae []*TextChunk ,_cdge []*TextChunk )[]*TextChunk {if len (_cdge )==0{return _addae ;};_edcg :=len (_addae );if _edcg ==0{return append (_addae ,_cdge ...);};_addae [_edcg -1].Text +=_cdge [0].Text ;return append (_addae ,_cdge [1:]...);};_fdbb :=func (_aefd *StyledParagraph ,_eebc []*TextChunk )*StyledParagraph {if len (_eebc )==0{return nil ;};_eeece :=*_aefd ;_eeece ._cebe =_eebc ;return &_eeece ;};var (_aaba float64 ;_afa []*TextChunk ;_gffef []*TextChunk ;);for _ ,_daaec :=range _cbgc ._aaccf {var _fbbfbg float64 ;_dgda :=make ([]*TextChunk ,0,len (_daaec ));for _ ,_cggfa :=range _daaec {if _gbge :=_cggfa .Style .FontSize ;_gbge > _fbbfbg {_fbbfbg =_gbge ;};_dgda =append (_dgda ,_cggfa .clone ());};_fbbfbg *=_cbgc ._dbdfb ;if _cbgc ._efdbe .IsRelative (){if _aaba +_fbbfbg > _fbaa .Height {_gffef =_edfa (_gffef ,_dgda );}else {_afa =_edfa (_afa ,_dgda );};};_aaba +=_fbbfbg ;};_cbgc ._aaccf =nil ;if len (_gffef )==0{return _cbgc ,nil ,nil ;};return _fdbb (_cbgc ,_afa ),_fdbb (_cbgc ,_gffef ),nil ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_ffef *Invoice )SetTerms (title ,content string ){_ffef ._fagg =[2]string {title ,content }};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_bdd *Division )Height ()float64 {var _ddga float64 ;for _ ,_gfbd :=range _bdd ._fafc {switch _dbgc :=_gfbd .(type ){case *Paragraph :_ddga +=_dbgc .Height ()+_dbgc ._bgfcg .Top +_dbgc ._bgfcg .Bottom ;case *StyledParagraph :_ddga +=_dbgc .Height ()+_dbgc ._gggf .Top +_dbgc ._gggf .Bottom ;default:_ddga +=_dbgc .Height ();};};return _ddga ;};

// SetLineColor sets the line color.
func (_fcfb *Polyline )SetLineColor (color Color ){_fcfb ._bdeg .LineColor =_a .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_deee *Creator )SetOutlineTree (outlineTree *_a .PdfOutlineTreeNode ){_deee ._eceb =outlineTree };func (_ebea *TableCell )width (_aacde []float64 ,_dceb float64 )float64 {_gfad :=float64 (0.0);for _afbb :=0;_afbb < _ebea ._gfegb ;_afbb ++{_gfad +=_aacde [_ebea ._gdfe +_afbb -1];};return _gfad *_dceb ;};

// SetLineHeight sets the line height (1.0 default).
func (_fbdf *Paragraph )SetLineHeight (lineheight float64 ){_fbdf ._dcfaad =lineheight };

// SetAngle sets Image rotation angle in degrees.
func (_gfee *Image )SetAngle (angle float64 ){_gfee ._efgf =angle };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_abgf *Invoice )SetColumns (cols []*InvoiceCell ){_abgf ._efag =cols };func _gged (_gcbgb *Block ,_dgbgc *StyledParagraph ,_gbc [][]*TextChunk ,_fegc DrawContext )(DrawContext ,[][]*TextChunk ,error ){_gaegf :=1;_defa :=_fc .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gaegf ));for _gcbgb ._ef .HasFontByName (_defa ){_gaegf ++;_defa =_fc .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gaegf ));};_aggge :=_gcbgb ._ef .SetFontByName (_defa ,_dgbgc ._fefe .Font .ToPdfObject ());if _aggge !=nil {return _fegc ,nil ,_aggge ;};_gaegf ++;_fabe :=_defa ;_gaeb :=_dgbgc ._fefe .FontSize ;_bccb :=_dgbgc ._efdbe .IsRelative ();var _defd [][]_fc .PdfObjectName ;var _fgcd float64 ;var _gaga [][]*TextChunk ;var _ddbe float64 ;for _cgbg ,_cecc :=range _gbc {var _bbgef []_fc .PdfObjectName ;var _fdfab float64 ;for _ ,_dda :=range _cecc {_abab :=_dda .Style ;if _cgbg ==0&&_abab .FontSize > _fgcd {_fgcd =_abab .FontSize ;};if _abab .FontSize > _fdfab {_fdfab =_abab .FontSize ;};_defa =_fc .PdfObjectName (_f .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gaegf ));_afcdf :=_gcbgb ._ef .SetFontByName (_defa ,_abab .Font .ToPdfObject ());if _afcdf !=nil {return _fegc ,nil ,_afcdf ;};_bbgef =append (_bbgef ,_defa );_gaegf ++;};_fdfab *=_dgbgc ._dbdfb ;if _bccb &&_ddbe +_fdfab > _fegc .Height {_gaga =_gbc [_cgbg :];_gbc =_gbc [:_cgbg ];break ;};_ddbe +=_fdfab ;_defd =append (_defd ,_bbgef );};_bdfb :=_gg .NewContentCreator ();_bdfb .Add_q ();_gbad :=_fegc .PageHeight -_fegc .Y -_fgcd *_dgbgc ._dbdfb ;_bdfb .Translate (_fegc .X ,_gbad );_bagg :=_gbad ;if _dgbgc ._gada !=0{_bdfb .RotateDeg (_dgbgc ._gada );};_bdfb .Add_BT ();var _cgbf []*_gf .BasicLine ;for _bdece ,_cecd :=range _gbc {_fdgf :=_fegc .X ;if _bdece !=0{_bdfb .Add_Tstar ();};_dadd :=_bdece ==len (_gbc )-1;var (_badf float64 ;_fgdab float64 ;_ggddb float64 ;_bfgba uint ;);var _eccg []float64 ;for _ ,_ebdea :=range _cecd {_bdca :=&_ebdea .Style ;if _bdca .FontSize > _fgdab {_fgdab =_bdca .FontSize ;};_bafdc ,_efga :=_bdca .Font .GetRuneMetrics (' ');if !_efga {return _fegc ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};var _febf uint ;var _dbb float64 ;_edcc :=len (_ebdea .Text );for _afbe ,_fddg :=range _ebdea .Text {if _fddg ==' '{_febf ++;continue ;};if _fddg =='\u000A'{continue ;};_egga ,_ebaff :=_bdca .Font .GetRuneMetrics (_fddg );if !_ebaff {_gd .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_fddg );return _fegc ,nil ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dbb +=_bdca .FontSize *_egga .Wx ;if _afbe !=_edcc -1{_dbb +=_bdca .CharSpacing *1000.0;};};_eccg =append (_eccg ,_dbb );_badf +=_dbb ;_ggddb +=float64 (_febf )*_bafdc .Wx *_bdca .FontSize ;_bfgba +=_febf ;};_fgdab *=_dgbgc ._dbdfb ;var _babfc []_fc .PdfObject ;_bfbbf :=_dgbgc ._eeeac *1000.0;if _dgbgc ._acga ==TextAlignmentJustify {if _bfgba > 0&&!_dadd {_ggddb =(_bfbbf -_badf )/float64 (_bfgba )/_gaeb ;};}else if _dgbgc ._acga ==TextAlignmentCenter {_aeaae :=(_bfbbf -_badf -_ggddb )/2;_fbegg :=_aeaae /_gaeb ;_babfc =append (_babfc ,_fc .MakeFloat (-_fbegg ));_fdgf +=_aeaae /1000.0;}else if _dgbgc ._acga ==TextAlignmentRight {_agdg :=(_bfbbf -_badf -_ggddb );_ddcb :=_agdg /_gaeb ;_babfc =append (_babfc ,_fc .MakeFloat (-_ddcb ));_fdgf +=_agdg /1000.0;};if len (_babfc )> 0{_bdfb .Add_Tf (_fabe ,_gaeb ).Add_TL (_gaeb *_dgbgc ._dbdfb ).Add_TJ (_babfc ...);};var _bagad float64 ;for _daddd ,_dbgeg :=range _cecd {_cfbc :=&_dbgeg .Style ;if _cfbc .FontSize > _bagad {_bagad =_cfbc .FontSize ;};_dbgb ,_efdfb ,_fdfabe :=_cfbc .Color .ToRGB ();_ebeb :=_fabe ;_badfe :=_gaeb ;_bdfb .Add_Tr (int64 (_cfbc .RenderingMode ));_bdfb .Add_Tc (_cfbc .CharSpacing );if _dgbgc ._acga !=TextAlignmentJustify ||_dadd {_gdf ,_gccf :=_cfbc .Font .GetRuneMetrics (' ');if !_gccf {return _fegc ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_ebeb =_defd [_bdece ][_daddd ];_badfe =_cfbc .FontSize ;_ggddb =_gdf .Wx ;};_ffbgc :=_cfbc .Font .Encoder ();var _dgff []byte ;for _ ,_aefba :=range _dbgeg .Text {if _dbgb =='\u000A'{continue ;};if _aefba ==' '{if len (_dgff )> 0{_bdfb .Add_rg (_dbgb ,_efdfb ,_fdfabe ).Add_Tf (_defd [_bdece ][_daddd ],_cfbc .FontSize ).Add_TJ ([]_fc .PdfObject {_fc .MakeStringFromBytes (_dgff )}...);_dgff =nil ;};_bdfb .Add_Tf (_ebeb ,_badfe ).Add_TJ ([]_fc .PdfObject {_fc .MakeFloat (-_ggddb )}...);_eccg [_daddd ]+=_ggddb *_badfe ;}else {if _ ,_ebdda :=_ffbgc .RuneToCharcode (_aefba );!_ebdda {_gd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_aefba ,_aefba );continue ;};_dgff =append (_dgff ,_ffbgc .Encode (string (_aefba ))...);};};if len (_dgff )> 0{_bdfb .Add_rg (_dbgb ,_efdfb ,_fdfabe ).Add_Tf (_defd [_bdece ][_daddd ],_cfbc .FontSize ).Add_TJ ([]_fc .PdfObject {_fc .MakeStringFromBytes (_dgff )}...);};_gadfd :=_eccg [_daddd ]/1000.0;if _cfbc .Underline {_ceab :=_cfbc .UnderlineStyle .Color ;if _ceab ==nil {_ceab =_dbgeg .Style .Color ;};_badc ,_fdcc ,_ggeb :=_ceab .ToRGB ();_ccgd ,_dbdbb :=_fdgf -_fegc .X ,_bagg -_gbad -_cfbc .UnderlineStyle .Offset ;_cgbf =append (_cgbf ,&_gf .BasicLine {X1 :_ccgd ,Y1 :_dbdbb ,X2 :_ccgd +_gadfd ,Y2 :_dbdbb ,LineWidth :_dbgeg .Style .UnderlineStyle .Thickness ,LineColor :_a .NewPdfColorDeviceRGB (_badc ,_fdcc ,_ggeb )});};if _dbgeg ._gfda !=nil {var _fddf *_fc .PdfObjectArray ;if !_dbgeg ._ggfc {switch _dbebg :=_dbgeg ._gfda .GetContext ().(type ){case *_a .PdfAnnotationLink :_fddf =_fc .MakeArray ();_dbebg .Rect =_fddf ;_adcf ,_ggdf :=_dbebg .Dest .(*_fc .PdfObjectArray );if _ggdf &&_adcf .Len ()==5{_fbega ,_gdga :=_adcf .Get (1).(*_fc .PdfObjectName );if _gdga &&_fbega .String ()=="\u0058\u0059\u005a"{_dbae ,_cbef :=_fc .GetNumberAsFloat (_adcf .Get (3));if _cbef ==nil {_adcf .Set (3,_fc .MakeFloat (_fegc .PageHeight -_dbae ));};};};};_dbgeg ._ggfc =true ;};if _fddf !=nil {_ffbbc :=_gf .NewPoint (_fdgf -_fegc .X ,_bagg -_gbad ).Rotate (_dgbgc ._gada );_ffbbc .X +=_fegc .X ;_ffbbc .Y +=_gbad ;_effb ,_bebg ,_dafac ,_cbeb :=_cgfac (_gadfd ,_fgdab ,_dgbgc ._gada );_ffbbc .X +=_effb ;_ffbbc .Y +=_bebg ;_fddf .Clear ();_fddf .Append (_fc .MakeFloat (_ffbbc .X ));_fddf .Append (_fc .MakeFloat (_ffbbc .Y ));_fddf .Append (_fc .MakeFloat (_ffbbc .X +_dafac ));_fddf .Append (_fc .MakeFloat (_ffbbc .Y +_cbeb ));};_gcbgb .AddAnnotation (_dbgeg ._gfda );};_fdgf +=_gadfd ;_bdfb .Add_Tr (int64 (TextRenderingModeFill ));_bdfb .Add_Tc (0);};_bdfb .Add_TL (_bagad *_dgbgc ._dbdfb );_bagg -=_fgdab ;};_bdfb .Add_ET ();for _ ,_efae :=range _cgbf {_ggdgd :=_efae .LineColor ;_bdfb .Add_RG (_ggdgd .R (),_ggdgd .G (),_ggdgd .B ()).Add_w (_efae .LineWidth ).Add_m (_efae .X1 ,_efae .Y1 ).Add_l (_efae .X2 ,_efae .Y2 ).Add_s ();};_bdfb .Add_Q ();_eafeb :=_bdfb .Operations ();_eafeb .WrapIfNeeded ();_gcbgb .addContents (_eafeb );if _bccb {_dfea :=_ddbe +_dgbgc ._gggf .Bottom ;_fegc .Y +=_dfea ;_fegc .Height -=_dfea ;if _fegc .Inline {_fegc .X +=_dgbgc .Width ()+_dgbgc ._gggf .Right ;};};return _fegc ,_gaga ,nil ;};func (_dbdge *TableCell )height (_ffcbc float64 )float64 {var _bdcg float64 ;switch _dedg :=_dbdge ._abgfd .(type ){case *Paragraph :if _dedg ._aabgd {_dedg .SetWidth (_ffcbc -_dbdge ._efde -_dedg ._bgfcg .Left -_dedg ._bgfcg .Right );};_bdcg =_dedg .Height ()+_dedg ._bgfcg .Top +_dedg ._bgfcg .Bottom +0.5*_dedg ._gadb *_dedg ._dcfaad ;case *StyledParagraph :if _dedg ._bgeg {_dedg .SetWidth (_ffcbc -_dbdge ._efde -_dedg ._gggf .Left -_dedg ._gggf .Right );};_bdcg =_dedg .Height ()+_dedg ._gggf .Top +_dedg ._gggf .Bottom +0.5*_dedg .getTextHeight ();case *Image :_bdcg =_dedg .Height ()+_dedg ._eabg .Top +_dedg ._eabg .Bottom ;case *Table :_bdcg =_dedg .Height ()+_dedg ._cbabb .Top +_dedg ._cbabb .Bottom ;case *List :_bdcg =_dedg .tableHeight (_ffcbc -_dbdge ._efde )+_dedg ._eacf .Top +_dedg ._eacf .Bottom ;case *Division :_bdcg =_dedg .ctxHeight (_ffcbc -_dbdge ._efde )+_dedg ._bfgc .Top +_dedg ._bfgc .Bottom ;};return _bdcg ;};

// CreateFrontPage sets a function to generate a front Page.
func (_bdfc *Creator )CreateFrontPage (genFrontPageFunc func (_aeb FrontpageFunctionArgs )){_bdfc ._bbgf =genFrontPageFunc ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ececc *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gdbc :=ctx ;_dcag :=[]func (_bgef DrawContext )([]*Block ,DrawContext ,error ){_ececc .generateHeaderBlocks ,_ececc .generateInformationBlocks ,_ececc .generateLineBlocks ,_ececc .generateTotalBlocks ,_ececc .generateNoteBlocks };var _cgdb []*Block ;for _ ,_dafb :=range _dcag {_eadb ,_afcaf ,_agb :=_dafb (ctx );if _agb !=nil {return _cgdb ,ctx ,_agb ;};if len (_cgdb )==0{_cgdb =_eadb ;}else if len (_eadb )> 0{_cgdb [len (_cgdb )-1].mergeBlocks (_eadb [0]);_cgdb =append (_cgdb ,_eadb [1:]...);};ctx =_afcaf ;};if _ececc ._cgbb .IsRelative (){ctx .X =_gdbc .X ;};if _ececc ._cgbb .IsAbsolute (){return _cgdb ,_gdbc ,nil ;};return _cgdb ,ctx ,nil ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_gbe *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcg :=_gg .NewContentCreator ();_bcf ,_fde :=_gbe .Width (),_gbe .Height ();if _gbe ._dg .IsRelative (){_fcg .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_fde );}else {_fcg .Translate (_gbe ._df ,ctx .PageHeight -_gbe ._ce -_fde );};_ec :=_fde ;if _gbe ._bef !=0{_fcg .Translate (_bcf /2,_fde /2);_fcg .RotateDeg (_gbe ._bef );_fcg .Translate (-_bcf /2,-_fde /2);_ ,_ec =_gbe .RotatedSize ();};if _gbe ._dg .IsRelative (){ctx .Y +=_ec ;};_db :=_gbe .duplicate ();_fdab :=append (*_fcg .Operations (),*_db ._cd ...);_fdab .WrapIfNeeded ();_db ._cd =&_fdab ;return []*Block {_db },ctx ,nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_fedb *StyledParagraph )SetLineHeight (lineheight float64 ){_fedb ._dbdfb =lineheight };type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_bffa Drawable )(Drawable ,error );};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_fcggf :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_gd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcggf ;};var _bff ,_cab ,_daga int ;if len (hexStr )==4{var _efbb ,_beaf ,_bafe int ;_aafd ,_edgb :=_f .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_efbb ,&_beaf ,&_bafe );if _edgb !=nil {_gd .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_edgb );return _fcggf ;};if _aafd !=3{_gd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcggf ;};_bff =_efbb *16+_efbb ;_cab =_beaf *16+_beaf ;_daga =_bafe *16+_bafe ;}else {_eafe ,_ebab :=_f .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_bff ,&_cab ,&_daga );if _ebab !=nil {_gd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _fcggf ;};if _eafe !=3{_gd .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_eafe );return _fcggf ;};};_efdd :=float64 (_bff )/255.0;_aege :=float64 (_cab )/255.0;_dgdg :=float64 (_daga )/255.0;_fcggf ._ceb =_efdd ;_fcggf ._aggg =_aege ;_fcggf ._dfa =_dgdg ;return _fcggf ;};

// SetFillColor sets background color for border.
func (_dac *border )SetFillColor (col Color ){_dac ._bcd =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_gec *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_aeeb :=_gf .Circle {X :_gec ._caf -_gec ._dbeb /2,Y :ctx .PageHeight -_gec ._dbff -_gec ._dgfa /2,Width :_gec ._dbeb ,Height :_gec ._dgfa ,Opacity :1.0,BorderWidth :_gec ._fbdg };if _gec ._bacb !=nil {_aeeb .FillEnabled =true ;_aeeb .FillColor =_gec ._bacb ;};if _gec ._aggd !=nil {_aeeb .BorderEnabled =true ;_aeeb .BorderColor =_gec ._aggd ;_aeeb .BorderWidth =_gec ._fbdg ;};_gdgc ,_ ,_ffbg :=_aeeb .Draw ("");if _ffbg !=nil {return nil ,ctx ,_ffbg ;};_ffbg =_dfbd .addContentsByString (string (_gdgc ));if _ffbg !=nil {return nil ,ctx ,_ffbg ;};return []*Block {_dfbd },ctx ,nil ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_ggd *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _bafg (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_deba int ;_ddgf int ;_adab int ;_bdfba []float64 ;_cbdb []float64 ;_fedg float64 ;_adef []*TableCell ;_bacc Positioning ;_fggc ,_ffgg float64 ;_cbabb Margins ;_ccfg bool ;_ddegg int ;_eecgb int ;_fcea bool ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_adag *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _adag ._cbabb .Left ,_adag ._cbabb .Right ,_adag ._cbabb .Top ,_adag ._cbabb .Bottom ;};

// SetFillOpacity sets the fill opacity.
func (_bafgf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_bafgf ._aagbf =opacity };

// SetColor sets the line color.
func (_cdaf *Curve )SetColor (col Color ){_cdaf ._aabd =_a .NewPdfColorDeviceRGB (col .ToRGB ())};func (_ebfb *TOCLine )getLineLink ()*_a .PdfAnnotation {if _ebfb ._becg <=0{return nil ;};return _caeff (_ebfb ._becg -1,_ebfb ._agddb ,_ebfb ._cbabbc ,0);};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_cbea *Invoice )Terms ()(string ,string ){return _cbea ._fagg [0],_cbea ._fagg [1]};

// IsRelative checks if the positioning is relative.
func (_cgef Positioning )IsRelative ()bool {return _cgef ==PositionRelative };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_ebde *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ebef ,_aefb :=_fgba .setOpacity (_ebde ._bfdb ,_ebde ._gcfcg );if _aefb !=nil {return nil ,ctx ,_aefb ;};_bgea :=_ebde ._dfefg ;_bgea .FillEnabled =_bgea .FillColor !=nil ;_bgea .BorderEnabled =_bgea .BorderColor !=nil &&_bgea .BorderWidth > 0;_feac :=_bgea .Points ;for _efdb :=range _feac {for _fca :=range _feac [_efdb ]{_fbbcf :=&_feac [_efdb ][_fca ];_fbbcf .Y =ctx .PageHeight -_fbbcf .Y ;};};_bffe ,_ ,_aefb :=_bgea .Draw (_ebef );if _aefb !=nil {return nil ,ctx ,_aefb ;};if _aefb =_fgba .addContentsByString (string (_bffe ));_aefb !=nil {return nil ,ctx ,_aefb ;};return []*Block {_fgba },ctx ,nil ;};func (_eab *Creator )setActivePage (_aafa *_a .PdfPage ){_eab ._bfge =_aafa };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_caf float64 ;_dbff float64 ;_dbeb float64 ;_dgfa float64 ;_bacb *_a .PdfColorDeviceRGB ;_aggd *_a .PdfColorDeviceRGB ;_fbdg float64 ;};

// GetCoords returns coordinates of border.
func (_efg *border )GetCoords ()(float64 ,float64 ){return _efg ._dde ,_efg ._efdg };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// Width returns the current page width.
func (_fag *Creator )Width ()float64 {return _fag ._dbag };

// InsertColumn inserts a column in the line items table at the specified index.
func (_ceeg *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_fbbc :=uint (len (_ceeg ._efag ));if index > _fbbc {index =_fbbc ;};_adcd :=_ceeg .NewColumn (description );_ceeg ._efag =append (_ceeg ._efag [:index ],append ([]*InvoiceCell {_adcd },_ceeg ._efag [index :]...)...);return _adcd ;};func _caa (_egfa *_a .Image )(*Image ,error ){_acf :=float64 (_egfa .Width );_acca :=float64 (_egfa .Height );return &Image {_bgffc :_egfa ,_cdcg :_acf ,_gface :_acca ,_baed :_acf ,_dce :_acca ,_efgf :0,_addg :1.0,_dbdg :PositionRelative },nil ;};func _adfgc (_acgb ,_bgfaf ,_afea ,_beaad float64 )*Rectangle {return &Rectangle {_baca :_acgb ,_aecea :_bgfaf ,_acbc :_afea ,_dfdbc :_beaad ,_cefa :_a .NewPdfColorDeviceRGB (0,0,0),_gecfd :1.0,_dbdb :1.0,_dede :1.0};};

// ColorRGBFromArithmetic creates a Color from arithmetic (0-1.0) color values.
// Example:
//   green := ColorRGBFromArithmetic(0, 1.0, 0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {r =_bb .Max (_bb .Min (r ,1.0),0.0);g =_bb .Max (_bb .Min (g ,1.0),0.0);b =_bb .Max (_bb .Min (b ,1.0),0.0);_cbd :=rgbColor {};_cbd ._ceb =r ;_cbd ._aggg =g ;_cbd ._dfa =b ;return _cbd ;};

// Append adds a new text chunk to the paragraph.
func (_bbebg *StyledParagraph )Append (text string )*TextChunk {_dcaef :=NewTextChunk (text ,_bbebg ._fefe );return _bbebg .appendChunk (_dcaef );};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_acb *Creator )NewImageFromGoImage (goimg _eb .Image )(*Image ,error ){return _gbeb (goimg )};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_cabdd *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_abcc float64 ;_fced uint ;_gfgc float64 ;_gdfa Positioning ;_agddb float64 ;_cbabbc float64 ;_becg int64 ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_bgff *Chapter )SetIncludeInTOC (includeInTOC bool ){_bgff ._ebg =includeInTOC };func _ffcg (_ccdd TextStyle )*List {return &List {_aeae :TextChunk {Text :"\u2022\u0020",Style :_ccdd },_dfbcd :0,_faga :true ,_abdc :PositionRelative ,_gadf :_ccdd };};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_abge *TOC )SetLineLevelOffset (levelOffset float64 ){_abge ._eebg =levelOffset };func (_defb *StyledParagraph )appendChunk (_facd *TextChunk )*TextChunk {_defb ._cebe =append (_defb ._cebe ,_facd );_defb .wrapText ();return _facd ;};func _bag (_fbb *_gg .ContentStreamOperations ,_fbc *_a .PdfPageResources ,_ebb *_gg .ContentStreamOperations ,_cg *_a .PdfPageResources )error {_dba :=map[_fc .PdfObjectName ]_fc .PdfObjectName {};_cda :=map[_fc .PdfObjectName ]_fc .PdfObjectName {};_ebbc :=map[_fc .PdfObjectName ]_fc .PdfObjectName {};_dd :=map[_fc .PdfObjectName ]_fc .PdfObjectName {};_bad :=map[_fc .PdfObjectName ]_fc .PdfObjectName {};_agd :=map[_fc .PdfObjectName ]_fc .PdfObjectName {};for _ ,_ffbb :=range *_ebb {switch _ffbb .Operand {case "\u0044\u006f":if len (_ffbb .Params )==1{if _cb ,_ddc :=_ffbb .Params [0].(*_fc .PdfObjectName );_ddc {if _ ,_dggb :=_dba [*_cb ];!_dggb {var _cdb _fc .PdfObjectName ;_cfa ,_ :=_cg .GetXObjectByName (*_cb );if _cfa !=nil {_cdb =*_cb ;for {_aec ,_ :=_fbc .GetXObjectByName (_cdb );if _aec ==nil ||_aec ==_cfa {break ;};_cdb =_cdb +"\u0030";};};_fbc .SetXObjectByName (_cdb ,_cfa );_dba [*_cb ]=_cdb ;};_ead :=_dba [*_cb ];_ffbb .Params [0]=&_ead ;};};case "\u0054\u0066":if len (_ffbb .Params )==2{if _ddf ,_dggg :=_ffbb .Params [0].(*_fc .PdfObjectName );_dggg {if _ ,_beaa :=_cda [*_ddf ];!_beaa {_gae ,_cfd :=_cg .GetFontByName (*_ddf );_eee :=*_ddf ;if _cfd &&_gae !=nil {_eee =_ebed (_ddf .String (),_gae ,_fbc );};_fbc .SetFontByName (_eee ,_gae );_cda [*_ddf ]=_eee ;};_bgf :=_cda [*_ddf ];_ffbb .Params [0]=&_bgf ;};};case "\u0043\u0053","\u0063\u0073":if len (_ffbb .Params )==1{if _gfd ,_edge :=_ffbb .Params [0].(*_fc .PdfObjectName );_edge {if _ ,_ccb :=_ebbc [*_gfd ];!_ccb {var _bcb _fc .PdfObjectName ;_faa ,_cad :=_cg .GetColorspaceByName (*_gfd );if _cad {_bcb =*_gfd ;for {_fdb ,_ada :=_fbc .GetColorspaceByName (_bcb );if !_ada ||_faa ==_fdb {break ;};_bcb =_bcb +"\u0030";};_fbc .SetColorspaceByName (_bcb ,_faa );_ebbc [*_gfd ]=_bcb ;}else {_gd .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _fbd ,_dga :=_ebbc [*_gfd ];_dga {_ffbb .Params [0]=&_fbd ;}else {_gd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_gfd );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_ffbb .Params )==1{if _cbb ,_ebe :=_ffbb .Params [0].(*_fc .PdfObjectName );_ebe {if _ ,_fec :=_dd [*_cbb ];!_fec {var _gfef _fc .PdfObjectName ;_cba ,_bgec :=_cg .GetPatternByName (*_cbb );if _bgec {_gfef =*_cbb ;for {_edd ,_abgc :=_fbc .GetPatternByName (_gfef );if !_abgc ||_edd ==_cba {break ;};_gfef =_gfef +"\u0030";};_cdd :=_fbc .SetPatternByName (_gfef ,_cba .ToPdfObject ());if _cdd !=nil {return _cdd ;};_dd [*_cbb ]=_gfef ;};};if _fbcg ,_gfc :=_dd [*_cbb ];_gfc {_ffbb .Params [0]=&_fbcg ;};};};case "\u0073\u0068":if len (_ffbb .Params )==1{if _cdbe ,_ddg :=_ffbb .Params [0].(*_fc .PdfObjectName );_ddg {if _ ,_ecf :=_bad [*_cdbe ];!_ecf {var _gca _fc .PdfObjectName ;_dgab ,_cbbg :=_cg .GetShadingByName (*_cdbe );if _cbbg {_gca =*_cdbe ;for {_beae ,_bab :=_fbc .GetShadingByName (_gca );if !_bab ||_dgab ==_beae {break ;};_gca =_gca +"\u0030";};_cef :=_fbc .SetShadingByName (_gca ,_dgab .ToPdfObject ());if _cef !=nil {_gd .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_cef );return _cef ;};_bad [*_cdbe ]=_gca ;}else {_gd .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cge ,_bfg :=_bad [*_cdbe ];_bfg {_ffbb .Params [0]=&_cge ;}else {_gd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_cdbe );};};};case "\u0067\u0073":if len (_ffbb .Params )==1{if _ffbe ,_aafe :=_ffbb .Params [0].(*_fc .PdfObjectName );_aafe {if _ ,_bdc :=_agd [*_ffbe ];!_bdc {var _bbe _fc .PdfObjectName ;_dab ,_ccd :=_cg .GetExtGState (*_ffbe );if _ccd {_bbe =*_ffbe ;_fdg :=1;for {_cgd ,_af :=_fbc .GetExtGState (_bbe );if !_af ||_dab ==_cgd {break ;};_bbe =_fc .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_fdg ));_fdg ++;};};_fbc .AddExtGState (_bbe ,_dab );_agd [*_ffbe ]=_bbe ;};_eefa :=_agd [*_ffbe ];_ffbb .Params [0]=&_eefa ;};};};*_fbb =append (*_fbb ,_ffbb );};return nil ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_bgaa *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fbbag :=ctx ;if _bgaa ._fbba .IsRelative (){ctx .X +=_bgaa ._egb .Left ;ctx .Y +=_bgaa ._egb .Top ;ctx .Width -=_bgaa ._egb .Left +_bgaa ._egb .Right ;ctx .Height -=_bgaa ._egb .Top ;};_ffec ,_abef ,_ebd :=_bgaa ._eafb .GeneratePageBlocks (ctx );if _ebd !=nil {return _ffec ,ctx ,_ebd ;};ctx =_abef ;_fgb :=ctx .X ;_beab :=ctx .Y -_bgaa ._eafb .Height ();_bfd :=int64 (ctx .Page );_cfc :=_bgaa .headingNumber ();_fgd :=_bgaa .headingText ();if _bgaa ._ebg {_fecg :=_bgaa ._dea .Add (_cfc ,_bgaa ._gbf ,_g .FormatInt (_bfd ,10),_bgaa ._faac );if _bgaa ._dea ._faef {_fecg .SetLink (_bfd ,_fgb ,_beab );};};if _bgaa ._cggd ==nil {_bgaa ._cggd =_a .NewOutlineItem (_fgd ,_a .NewOutlineDest (_bfd -1,_fgb ,_beab ));if _bgaa ._ccg !=nil {_bgaa ._ccg ._cggd .Add (_bgaa ._cggd );}else {_bgaa ._bfe .Add (_bgaa ._cggd );};}else {_cce :=&_bgaa ._cggd .Dest ;_cce .Page =_bfd -1;_cce .X =_fgb ;_cce .Y =_beab ;};for _ ,_gggb :=range _bgaa ._gag {_cgf ,_egba ,_aea :=_gggb .GeneratePageBlocks (ctx );if _aea !=nil {return _ffec ,ctx ,_aea ;};if len (_cgf )< 1{continue ;};_ffec [len (_ffec )-1].mergeBlocks (_cgf [0]);_ffec =append (_ffec ,_cgf [1:]...);ctx =_egba ;};if _bgaa ._fbba .IsRelative (){ctx .X =_fbbag .X ;};if _bgaa ._fbba .IsAbsolute (){return _ffec ,_fbbag ,nil ;};return _ffec ,ctx ,nil ;};func (_eccc *Block )mergeBlocks (_ffc *Block )error {_def :=_bag (_eccc ._cd ,_eccc ._ef ,_ffc ._cd ,_ffc ._ef );if _def !=nil {return _def ;};for _ ,_dag :=range _ffc ._aa {_eccc .AddAnnotation (_dag );};return nil ;};func (_ebec *Invoice )drawSection (_cedga ,_dfg string )[]*StyledParagraph {var _bbfc []*StyledParagraph ;if _cedga !=""{_aadf :=_fdege (_ebec ._ggf );_aadf .SetMargins (0,0,0,5);_aadf .Append (_cedga );_bbfc =append (_bbfc ,_aadf );};if _dfg !=""{_gaag :=_fdege (_ebec ._cccb );_gaag .Append (_dfg );_bbfc =append (_bbfc ,_gaag );};return _bbfc ;};

// NewPolygon creates a new polygon.
func (_afg *Creator )NewPolygon (points [][]_gf .Point )*Polygon {return _egfdb (points )};

// Level returns the indentation level of the TOC line.
func (_aacdea *TOCLine )Level ()uint {return _aacdea ._fced };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_bbge *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bbag ,_abdac :=_afce .setOpacity (_bbge ._aagbf ,_bbge ._gecf );if _abdac !=nil {return nil ,ctx ,_abdac ;};_edeg :=_bbge ._agde ;_edeg .FillEnabled =_edeg .FillColor !=nil ;_acdg :=_edeg .Curves ;_bbgfd :=ctx .PageHeight ;for _efbe :=range _acdg {_gcbcf :=&_acdg [_efbe ];_gcbcf .P0 .Y =_bbgfd -_gcbcf .P0 .Y ;_gcbcf .P1 .Y =_bbgfd -_gcbcf .P1 .Y ;_gcbcf .P2 .Y =_bbgfd -_gcbcf .P2 .Y ;_gcbcf .P3 .Y =_bbgfd -_gcbcf .P3 .Y ;};_dfbe ,_ ,_abdac :=_edeg .Draw (_bbag );if _abdac !=nil {return nil ,ctx ,_abdac ;};if _abdac =_afce .addContentsByString (string (_dfbe ));_abdac !=nil {return nil ,ctx ,_abdac ;};return []*Block {_afce },ctx ,nil ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_cefg *Chapter )GetHeading ()*Paragraph {return _cefg ._eafb };var PPMM =float64 (72*1.0/25.4);

// SetBorderColor sets border color.
func (_befe *Rectangle )SetBorderColor (col Color ){_befe ._cefa =_a .NewPdfColorDeviceRGB (col .ToRGB ())};func (_bege *TextChunk )clone ()*TextChunk {_dcac :=*_bege ;_dcac ._gfda =_debaf (_bege ._gfda );return &_dcac ;};

// TOC returns the table of contents component of the creator.
func (_ddgb *Creator )TOC ()*TOC {return _ddgb ._ebbg };func _bdecc (_abbd ,_ageca TextStyle )*Invoice {_ege :=&Invoice {_abcd :"\u0049N\u0056\u004f\u0049\u0043\u0045",_afbg :"\u002c\u0020",_eeec :_abbd ,_gee :_ageca };_ege ._fcbg =&InvoiceAddress {Separator :_ege ._afbg };_ege ._ebgf =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_ege ._afbg };_cfefa :=ColorRGBFrom8bit (245,245,245);_aaac :=ColorRGBFrom8bit (155,155,155);_ege ._adff =_ageca ;_ege ._adff .Color =_aaac ;_ege ._adff .FontSize =20;_ege ._fgaeb =_abbd ;_ege ._baebc =_ageca ;_ege ._cccb =_abbd ;_ege ._ggf =_ageca ;_ege ._fcged =_ege .NewCellProps ();_ege ._fcged .BackgroundColor =_cfefa ;_ege ._fcged .TextStyle =_ageca ;_ege ._bdgab =_ege .NewCellProps ();_ege ._bdgab .TextStyle =_ageca ;_ege ._bdgab .BackgroundColor =_cfefa ;_ege ._bdgab .BorderColor =_cfefa ;_ege ._gbgb =_ege .NewCellProps ();_ege ._gbgb .BorderColor =_cfefa ;_ege ._gbgb .BorderSides =[]CellBorderSide {CellBorderSideBottom };_ege ._gbgb .Alignment =CellHorizontalAlignmentRight ;_ege ._gaaa =_ege .NewCellProps ();_ege ._gaaa .Alignment =CellHorizontalAlignmentRight ;_ege ._cdgc =[2]*InvoiceCell {_ege .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_ege ._fcged ),_ege .newCell ("",_ege ._fcged )};_ege ._dfdb =[2]*InvoiceCell {_ege .newCell ("\u0044\u0061\u0074\u0065",_ege ._fcged ),_ege .newCell ("",_ege ._fcged )};_ege ._eebf =[2]*InvoiceCell {_ege .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_ege ._fcged ),_ege .newCell ("",_ege ._fcged )};_ege ._beabb =[2]*InvoiceCell {_ege .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_ege ._gaaa ),_ege .newCell ("",_ege ._gaaa )};_cee :=_ege ._gaaa ;_cee .TextStyle =_ageca ;_cee .BackgroundColor =_cfefa ;_cee .BorderColor =_cfefa ;_ege ._dcdf =[2]*InvoiceCell {_ege .newCell ("\u0054\u006f\u0074a\u006c",_cee ),_ege .newCell ("",_cee )};_ege ._cfge =[2]string {"\u004e\u006f\u0074e\u0073",""};_ege ._fagg =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_ege ._efag =[]*InvoiceCell {_ege .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_ege .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_ege .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_ege .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};return _ege ;};

// NewImageFromFile creates an Image from a file.
func (_cdcf *Creator )NewImageFromFile (path string )(*Image ,error ){return _acbd (path )};

// SetBorderColor sets the border color.
func (_cdcd *PolyBezierCurve )SetBorderColor (color Color ){_cdcd ._agde .BorderColor =_a .NewPdfColorDeviceRGB (color .ToRGB ());};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gcfbb *TOCLine )SetStyle (style TextStyle ){_gcfbb .Number .Style =style ;_gcfbb .Title .Style =style ;_gcfbb .Separator .Style =style ;_gcfbb .Page .Style =style ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_aggb *Invoice )AddressHeadingStyle ()TextStyle {return _aggb ._gee };

// BuyerAddress returns the buyer address used in the invoice template.
func (_dcff *Invoice )BuyerAddress ()*InvoiceAddress {return _dcff ._ebgf };

// SetColorLeft sets border color for left.
func (_bda *border )SetColorLeft (col Color ){_bda ._aff =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_aaca *TOC )SetLineNumberStyle (style TextStyle ){_aaca ._dcaeb =style };func (_gfff *StyledParagraph )wrapText ()error {return _gfff .wrapChunks (true )};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_ebba *Image )ConvertToBinary ()error {return _ebba ._bgffc .ConvertToBinary ()};

// SetStyleBottom sets border style for bottom side.
func (_gad *border )SetStyleBottom (style CellBorderStyle ){_gad ._eefb =style };

// SetIndent sets the left offset of the list when nested into another list.
func (_aeaa *List )SetIndent (indent float64 ){_aeaa ._dfbcd =indent ;_aeaa ._faga =false };

// AddLine appends a new line to the invoice line items table.
func (_efac *Invoice )AddLine (values ...string )[]*InvoiceCell {_bfba :=len (_efac ._efag );var _gdcc []*InvoiceCell ;for _afcd ,_fbe :=range values {_dcge :=_efac .newCell (_fbe ,_efac ._gbgb );if _afcd < _bfba {_dcge .Alignment =_efac ._efag [_afcd ].Alignment ;};_gdcc =append (_gdcc ,_dcge );};_efac ._baa =append (_efac ._baa ,_gdcc );return _gdcc ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_adagb *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_facag :=ctx ;_cdda ,ctx ,_cffe :=_adagb ._cabdd .GeneratePageBlocks (ctx );if _cffe !=nil {return _cdda ,ctx ,_cffe ;};if _adagb ._gdfa .IsRelative (){ctx .X =_facag .X ;};if _adagb ._gdfa .IsAbsolute (){return _cdda ,_facag ,nil ;};return _cdda ,ctx ,nil ;};func _cffb (_gfdee *_a .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_gfdee ,FontSize :10,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_ebgg *List )Marker ()*TextChunk {return &_ebgg ._aeae };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_gcbc []*_a .PdfPage ;_dbea map[*_a .PdfPage ]*Block ;_gcfg map[*_a .PdfPage ]_be .Matrix ;_bfge *_a .PdfPage ;_adfb PageSize ;_aaa DrawContext ;_geg Margins ;_dbag ,_aba float64 ;_gfcg int ;_bbgf func (_bggd FrontpageFunctionArgs );_ebbcd func (_gdb *TOC )error ;_ceg func (_bcba *Block ,_cged HeaderFunctionArgs );_cefgb func (_cddd *Block ,_dfae FooterFunctionArgs );_bbad func (_ggga *_a .PdfWriter )error ;_ecb bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_ebbg *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gbbd *_a .Outline ;_eceb *_a .PdfOutlineTreeNode ;_dcbf *_a .PdfAcroForm ;_cae _fc .PdfObject ;_fdef _a .Optimizer ;_ffag []*_a .PdfFont ;_bffb *_a .PdfFont ;_aef *_a .PdfFont ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_gcad *Table )Width ()float64 {return 0};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_cdbc *Creator )EnableFontSubsetting (font *_a .PdfFont ){_cdbc ._ffag =append (_cdbc ._ffag ,font )};

// NewChapter creates a new chapter with the specified title as the heading.
func (_gfdb *Creator )NewChapter (title string )*Chapter {_gfdb ._gfcg ++;_gabg :=_gfdb .NewTextStyle ();_gabg .FontSize =16;return _eca (nil ,_gfdb ._ebbg ,_gfdb ._gbbd ,title ,_gfdb ._gfcg ,_gabg );};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_dbebgf *TableCell )SetBorderLineStyle (style _gf .LineStyle ){_dbebgf ._acfd =style };const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// SetLineOpacity sets the line opacity.
func (_bdgad *Polyline )SetLineOpacity (opacity float64 ){_bdgad ._bcgf =opacity };

// CurCol returns the currently active cell's column number.
func (_bbaff *Table )CurCol ()int {_dabf :=(_bbaff ._adab -1)%(_bbaff ._ddgf )+1;return _dabf };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_abfg *Image )ScaleToWidth (w float64 ){_fegg :=_abfg ._dce /_abfg ._baed ;_abfg ._baed =w ;_abfg ._dce =w *_fegg ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_fage *Invoice )SetBuyerAddress (address *InvoiceAddress ){_fage ._ebgf =address };

// NewPolyline creates a new polyline.
func (_cac *Creator )NewPolyline (points []_gf .Point )*Polyline {return _aefe (points )};func _ecec (_fcdf []byte )(*Image ,error ){_fbcbf :=_e .NewReader (_fcdf );_ecdg ,_eeea :=_a .ImageHandling .Read (_fbcbf );if _eeea !=nil {_gd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eeea );return nil ,_eeea ;};return _caa (_ecdg );};func (_gfga *Invoice )newColumn (_fagb string ,_febc CellHorizontalAlignment )*InvoiceCell {_aagfe :=&InvoiceCell {_gfga ._bdgab ,_fagb };_aagfe .Alignment =_febc ;return _aagfe ;};func _gggce (_adbc *Table ,_bbfg DrawContext )([]*Block ,DrawContext ,error ){var _dfdd []*Block ;_caaf :=NewBlock (_bbfg .PageWidth ,_bbfg .PageHeight );_bgfcf :=_bbfg ;if _adbc ._bacc .IsAbsolute (){_bbfg .X =_adbc ._fggc ;_bbfg .Y =_adbc ._ffgg ;}else {_bbfg .X +=_adbc ._cbabb .Left ;_bbfg .Y +=_adbc ._cbabb .Top ;_bbfg .Width -=_adbc ._cbabb .Left +_adbc ._cbabb .Right ;_bbfg .Height -=_adbc ._cbabb .Bottom +_adbc ._cbabb .Top ;};_ggeea :=_bbfg .Width ;_aacd :=_bbfg .X ;_fbga :=_bbfg .Y ;_bbfg .Height =_bbfg .PageHeight -_bbfg .Y -_bbfg .Margins .Bottom ;_bfca :=_bbfg .Height ;_afdc :=0;_afec ,_ffeg :=-1,-1;for _edae ,_egcd :=range _adbc ._adef {_dade :=_egcd .width (_adbc ._bdfba ,_ggeea );if _adbc ._ccfg {if _egcd ._dbgd >=_adbc ._ddegg &&_egcd ._dbgd <=_adbc ._eecgb {if _afec < 0{_afec =_edae ;};_ffeg =_edae ;};};_ecaa :=_adbc ._cbdb [_egcd ._dbgd +_egcd ._baccg -2];if _fafe :=_egcd .height (_dade );_fafe > _ecaa {_adbc ._cbdb [_egcd ._dbgd +_egcd ._baccg -2]=_fafe ;};};var (_gdba bool ;_dgggeb int ;_afab int ;_ccfc bool ;_cefb int ;_fdcbe error ;);for _fbae :=0;_fbae < len (_adbc ._adef );_fbae ++{_fdfaba :=_adbc ._adef [_fbae ];_bfeb :=_fdfaba .width (_adbc ._bdfba ,_ggeea );_cdcdae :=float64 (0.0);for _fedd :=0;_fedd < _fdfaba ._gdfe -1;_fedd ++{_cdcdae +=_adbc ._bdfba [_fedd ]*_ggeea ;};_cdff :=float64 (0.0);for _bbdc :=_afdc ;_bbdc < _fdfaba ._dbgd -1;_bbdc ++{_cdff +=_adbc ._cbdb [_bbdc ];};_bbfg .Height =_bfca -_cdff ;_ebcb :=float64 (0.0);for _ecge :=0;_ecge < _fdfaba ._baccg ;_ecge ++{_ebcb +=_adbc ._cbdb [_fdfaba ._dbgd +_ecge -1];};_fccg :=_ccfc &&_fdfaba ._dbgd !=_cefb ;_cefb =_fdfaba ._dbgd ;if _fccg ||_ebcb > _bbfg .Height {if _adbc ._fcea &&!_ccfc {_ccfc ,_fdcbe =_adbc .wrapRow (_fbae ,_bbfg ,_ggeea );if _fdcbe !=nil {return nil ,_bbfg ,_fdcbe ;};if _ccfc {_fbae --;continue ;};};_dfdd =append (_dfdd ,_caaf );_caaf =NewBlock (_bbfg .PageWidth ,_bbfg .PageHeight );_aacd =_bbfg .Margins .Left ;_fbga =_bbfg .Margins .Top ;_bbfg .Height =_bbfg .PageHeight -_bbfg .Margins .Top -_bbfg .Margins .Bottom ;_bbfg .Page ++;_bfca =_bbfg .Height ;_afdc =_fdfaba ._dbgd -1;_cdff =0;_ccfc =false ;if _adbc ._ccfg &&_afec >=0{_dgggeb =_fbae ;_fbae =_afec -1;_afab =_afdc ;_afdc =_adbc ._ddegg -1;_gdba =true ;continue ;};if _fccg {_fbae --;continue ;};};_bbfg .Width =_bfeb ;_bbfg .X =_aacd +_cdcdae ;_bbfg .Y =_fbga +_cdff ;_eefec :=_bbaa (_bbfg .X ,_bbfg .Y ,_bfeb ,_ebcb );if _fdfaba ._ffbc !=nil {_ccdgf :=_fdfaba ._ffbc .R ();_bbcac :=_fdfaba ._ffbc .G ();_fabec :=_fdfaba ._ffbc .B ();_eefec .SetFillColor (ColorRGBFromArithmetic (_ccdgf ,_bbcac ,_fabec ));};_eefec .LineStyle =_fdfaba ._acfd ;_eefec ._gff =_fdfaba ._afeca ;_eefec ._edf =_fdfaba ._dfede ;_eefec ._aece =_fdfaba ._babd ;_eefec ._eefb =_fdfaba ._aedfc ;if _fdfaba ._dedeb !=nil {_eefec .SetColorLeft (ColorRGBFromArithmetic (_fdfaba ._dedeb .R (),_fdfaba ._dedeb .G (),_fdfaba ._dedeb .B ()));};if _fdfaba ._edec !=nil {_eefec .SetColorBottom (ColorRGBFromArithmetic (_fdfaba ._edec .R (),_fdfaba ._edec .G (),_fdfaba ._edec .B ()));};if _fdfaba ._beeb !=nil {_eefec .SetColorRight (ColorRGBFromArithmetic (_fdfaba ._beeb .R (),_fdfaba ._beeb .G (),_fdfaba ._beeb .B ()));};if _fdfaba ._ecaf !=nil {_eefec .SetColorTop (ColorRGBFromArithmetic (_fdfaba ._ecaf .R (),_fdfaba ._ecaf .G (),_fdfaba ._ecaf .B ()));};_eefec .SetWidthBottom (_fdfaba ._cfbb );_eefec .SetWidthLeft (_fdfaba ._ebbaa );_eefec .SetWidthRight (_fdfaba ._acee );_eefec .SetWidthTop (_fdfaba ._gbdg );_cccde :=_caaf .Draw (_eefec );if _cccde !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cccde );};if _fdfaba ._abgfd !=nil {_fcdc :=_fdfaba ._abgfd .Width ();_cbgd :=_fdfaba ._abgfd .Height ();_gecd :=0.0;switch _fbcbe :=_fdfaba ._abgfd .(type ){case *Paragraph :if _fbcbe ._aabgd {_fcdc =_fbcbe .getMaxLineWidth ()/1000.0;};_fcdc +=_fbcbe ._bgfcg .Left +_fbcbe ._bgfcg .Right ;_cbgd +=_fbcbe ._bgfcg .Top +_fbcbe ._bgfcg .Bottom ;case *StyledParagraph :if _fbcbe ._bgeg {_fcdc =_fbcbe .getMaxLineWidth ()/1000.0;};_cbad ,_fbge :=_fbcbe .getLineHeight (0);if len (_fbcbe ._aaccf )==1{_cbgd =_cbad ;}else {_cbgd =_cbgd -_fbge +_cbad ;};_gecd =_cbad -_fbge ;switch _fdfaba ._gcba {case CellVerticalAlignmentTop :_gecd +=_cbad *0.5;case CellVerticalAlignmentBottom :_gecd -=_cbad *0.5;};_fcdc +=_fbcbe ._gggf .Left +_fbcbe ._gggf .Right ;_cbgd +=_fbcbe ._gggf .Top +_fbcbe ._gggf .Bottom ;case *Table :_fcdc =_bfeb ;case *List :_fcdc =_bfeb ;};switch _fdfaba ._bfda {case CellHorizontalAlignmentLeft :_bbfg .X +=_fdfaba ._efde ;_bbfg .Width -=_fdfaba ._efde ;case CellHorizontalAlignmentCenter :if _ebbfd :=_bfeb -_fcdc ;_ebbfd > 0{_bbfg .X +=_ebbfd /2;_bbfg .Width -=_ebbfd /2;};case CellHorizontalAlignmentRight :if _bfeb > _fcdc {_bbfg .X =_bbfg .X +_bfeb -_fcdc -_fdfaba ._efde ;_bbfg .Width -=_fdfaba ._efde ;};};_bbfg .Y +=_gecd ;switch _fdfaba ._gcba {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _gfab :=_ebcb -_cbgd ;_gfab > 0{_bbfg .Y +=_gfab /2;_bbfg .Height -=_gfab /2;};case CellVerticalAlignmentBottom :if _ebcb > _cbgd {_bbfg .Y =_bbfg .Y +_ebcb -_cbgd ;_bbfg .Height =_ebcb ;};};_adcdf :=_caaf .DrawWithContext (_fdfaba ._abgfd ,_bbfg );if _adcdf !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_adcdf );};_bbfg .Y -=_gecd ;};_bbfg .Y +=_ebcb ;_bbfg .Height -=_ebcb ;if _gdba &&_fbae +1> _ffeg {_fbga +=_cdff +_ebcb ;_bfca -=_ebcb +_cdff ;_afdc =_afab ;_fbae =_dgggeb -1;_gdba =false ;};};_dfdd =append (_dfdd ,_caaf );if _adbc ._bacc .IsAbsolute (){return _dfdd ,_bgfcf ,nil ;};_bbfg .X =_bgfcf .X ;_bbfg .Width =_bgfcf .Width ;_bbfg .Y +=_adbc ._cbabb .Bottom ;_bbfg .Height -=_adbc ._cbabb .Bottom ;return _dfdd ,_bbfg ,nil ;};

// SetAngle sets the rotation angle of the text.
func (_dfdg *Paragraph )SetAngle (angle float64 ){_dfdg ._eaccb =angle };

// CreateTableOfContents sets a function to generate table of contents.
func (_cfg *Creator )CreateTableOfContents (genTOCFunc func (_aafec *TOC )error ){_cfg ._ebbcd =genTOCFunc ;};

// Height returns the Block's height.
func (_ae *Block )Height ()float64 {return _ae ._bg };func _aefe (_adaa []_gf .Point )*Polyline {return &Polyline {_bdeg :&_gf .Polyline {Points :_adaa ,LineColor :_a .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_bcgf :1.0};};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_geff *List )Add (item VectorDrawable )(*TextChunk ,error ){_eccff :=&listItem {_gbab :item ,_dcdfc :_geff ._aeae };switch _cdec :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _cdec ._faga {_cdec ._dfbcd =15;};default:return nil ,_c .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");};_geff ._deaa =append (_geff ._deaa ,_eccff );return &_eccff ._dcdfc ,nil ;};

// RotatedSize returns the width and height of the rotated block.
func (_gcd *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_ecc ,_eg :=_cgfac (_gcd ._gc ,_gcd ._bg ,_gcd ._bef );return _ecc ,_eg ;};func (_fgdba *Paragraph )wrapText ()error {if !_fgdba ._aabgd ||int (_fgdba ._bfag )<=0{_fgdba ._abbb =[]string {_fgdba ._aeea };return nil ;};_ccdg :=NewTextChunk (_fgdba ._aeea ,TextStyle {Font :_fgdba ._ebegd ,FontSize :_fgdba ._gadb });_bbgb ,_fbbfb :=_ccdg .Wrap (_fgdba ._bfag );if _fbbfb !=nil {return _fbbfb ;};if _fgdba ._aggf > 0&&len (_bbgb )> _fgdba ._aggf {_bbgb =_bbgb [:_fgdba ._aggf ];};_fgdba ._abbb =_bbgb ;return nil ;};

// SetColorRight sets border color for right.
func (_bcc *border )SetColorRight (col Color ){_bcc ._ddbb =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetBorderOpacity sets the border opacity.
func (_effcd *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_effcd ._gecf =opacity };func (_gdccf *Table )newCell (_ccbf int )*TableCell {_gdccf ._adab ++;_eadg :=(_gdccf ._adab -1)/_gdccf ._ddgf +1;for _eadg > _gdccf ._deba {_gdccf ._deba ++;_gdccf ._cbdb =append (_gdccf ._cbdb ,_gdccf ._fedg );};_egce :=(_gdccf ._adab -1)%(_gdccf ._ddgf )+1;_afdb :=&TableCell {};_afdb ._dbgd =_eadg ;_afdb ._gdfe =_egce ;_afdb ._baccg =1;_afdb ._efde =5;_afdb ._afeca =CellBorderStyleNone ;_afdb ._acfd =_gf .LineStyleSolid ;_afdb ._bfda =CellHorizontalAlignmentLeft ;_afdb ._gcba =CellVerticalAlignmentTop ;_afdb ._ebbaa =0;_afdb ._cfbb =0;_afdb ._acee =0;_afdb ._gbdg =0;_fbad :=ColorBlack ;_afdb ._dedeb =_a .NewPdfColorDeviceRGB (_fbad .ToRGB ());_afdb ._edec =_a .NewPdfColorDeviceRGB (_fbad .ToRGB ());_afdb ._beeb =_a .NewPdfColorDeviceRGB (_fbad .ToRGB ());_afdb ._ecaf =_a .NewPdfColorDeviceRGB (_fbad .ToRGB ());if _ccbf < 1{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_ccbf );_ccbf =1;};_gdce :=_gdccf ._ddgf -(_afdb ._gdfe -1);if _ccbf > _gdce {_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_ccbf ,_gdce );_ccbf =_gdce ;};_afdb ._gfegb =_ccbf ;_gdccf ._adab +=_ccbf -1;_gdccf ._adef =append (_gdccf ._adef ,_afdb );_afdb ._gafce =_gdccf ;return _afdb ;};

// Length calculates and returns the line length.
func (_fbccg *Line )Length ()float64 {return _bb .Sqrt (_bb .Pow (_fbccg ._ffcc -_fbccg ._dfeb ,2.0)+_bb .Pow (_fbccg ._aafdf -_fbccg ._aabe ,2.0));};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _gefe ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_ega :=&Creator {};_ega ._gcbc =[]*_a .PdfPage {};_ega ._dbea =map[*_a .PdfPage ]*Block {};_ega .SetPageSize (PageSizeLetter );_bgfc :=0.1*_ega ._dbag ;_ega ._geg .Left =_bgfc ;_ega ._geg .Right =_bgfc ;_ega ._geg .Top =_bgfc ;_ega ._geg .Bottom =_bgfc ;var _ffce error ;_ega ._bffb ,_ffce =_a .NewStandard14Font (_a .HelveticaName );if _ffce !=nil {_ega ._bffb =_a .DefaultFont ();};_ega ._aef ,_ffce =_a .NewStandard14Font (_a .HelveticaBoldName );if _ffce !=nil {_ega ._bffb =_a .DefaultFont ();};_ega ._ebbg =_ega .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_ega .AddOutlines =true ;_ega ._gbbd =_a .NewOutline ();_ba .TrackUse (_gefe );return _ega ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dfag *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_gaed :=_fdege (_dfag ._gadf );_gaed .Append (text );_gddg ,_fedc :=_dfag .Add (_gaed );return _gaed ,_gddg ,_fedc ;};

// TextStyle is a collection of properties that can be assigned to a chunk of text.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// Font represents the font the text will use.
Font *_a .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_cd *_gg .ContentStreamOperations ;_ef *_a .PdfPageResources ;_dg Positioning ;_df ,_ce float64 ;_gc float64 ;_bg float64 ;_bef float64 ;_de Margins ;_aa []*_a .PdfAnnotation ;};func _begg (_bbgc *_a .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_bbgc ,FontSize :10,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_dcfa float64 ;_agga float64 ;_baeb float64 ;_bcfd float64 ;_eddb float64 ;_bdcc float64 ;_aabd *_a .PdfColorDeviceRGB ;_gdde float64 ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fbff *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _fbff ._beabb [0],_fbff ._beabb [1];};func (_ff *Block )transform (_dgc _be .Matrix ){_eff :=_gg .NewContentCreator ().Add_cm (_dgc [0],_dgc [1],_dgc [3],_dgc [4],_dgc [6],_dgc [7]).Operations ();*_ff ._cd =append (*_eff ,*_ff ._cd ...);_ff ._cd .WrapIfNeeded ();};func (_ebeg *Invoice )generateHeaderBlocks (_dcad DrawContext )([]*Block ,DrawContext ,error ){_aebad :=_fdege (_ebeg ._adff );_aebad .SetEnableWrap (true );_aebad .Append (_ebeg ._abcd );_aafcf :=_gagg (2);if _ebeg ._fefc !=nil {_cdga :=_aafcf .NewCell ();_cdga .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_cdga .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cdga .SetIndent (0);_cdga .SetContent (_ebeg ._fefc );_ebeg ._fefc .ScaleToHeight (_aebad .Height ()+20);}else {_aafcf .SkipCells (1);};_cccg :=_aafcf .NewCell ();_cccg .SetHorizontalAlignment (CellHorizontalAlignmentRight );_cccg .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cccg .SetContent (_aebad );return _aafcf .GeneratePageBlocks (_dcad );};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_aaf :=&Block {};_aaf ._cd =&_gg .ContentStreamOperations {};_aaf ._ef =_a .NewPdfPageResources ();_aaf ._gc =width ;_aaf ._bg =height ;return _aaf ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_agde *_gf .PolyBezierCurve ;_aagbf float64 ;_gecf float64 ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_gagf *List )Width ()float64 {return 0};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cgfa *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_eggd :=[2]*InvoiceCell {_cgfa .newCell (description ,_cgfa ._fcged ),_cgfa .newCell (value ,_cgfa ._fcged )};_cgfa ._aafaa =append (_cgfa ._aafaa ,_eggd );return _eggd [0],_eggd [1];};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_gfed *Division )Add (d VectorDrawable )error {switch _beg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image :case containerDrawable :_aedg ,_agda :=_beg .ContainerComponent (_gfed );if _agda !=nil {return _agda ;};_egcc ,_dfcg :=_aedg .(VectorDrawable );if !_dfcg {return _f .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_aedg );};d =_egcc ;default:return _c .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gfed ._fafc =append (_gfed ._fafc ,d );return nil ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_bagd *StyledParagraph )Insert (index uint ,text string )*TextChunk {_aced :=uint (len (_bagd ._cebe ));if index > _aced {index =_aced ;};_fgea :=NewTextChunk (text ,_bagd ._fefe );_bagd ._cebe =append (_bagd ._cebe [:index ],append ([]*TextChunk {_fgea },_bagd ._cebe [index :]...)...);_bagd .wrapText ();return _fgea ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dfdf *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dfdf ._bfda =halign };

// SetAnnotation sets a annotation on a TextChunk.
func (_ddbf *TextChunk )SetAnnotation (annotation *_a .PdfAnnotation ){_ddbf ._gfda =annotation };func _gfedf (_acgdb *_a .PdfRectangle ,_bace _be .Matrix )*_a .PdfRectangle {var _dfcgg _a .PdfRectangle ;_dfcgg .Llx ,_dfcgg .Lly =_bace .Transform (_acgdb .Llx ,_acgdb .Lly );_dfcgg .Urx ,_dfcgg .Ury =_bace .Transform (_acgdb .Urx ,_acgdb .Ury );_dfcgg .Normalize ();return &_dfcgg ;};func _efdga (_fbea ,_ecbc ,_bddac string ,_dfde uint ,_bdfbc TextStyle )*TOCLine {return _dgffe (TextChunk {Text :_fbea ,Style :_bdfbc },TextChunk {Text :_ecbc ,Style :_bdfbc },TextChunk {Text :_bddac ,Style :_bdfbc },_dfde ,_bdfbc );};func _ccbe ()*PageBreak {return &PageBreak {}};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_efbbe *Table )SetPos (x ,y float64 ){_efbbe ._bacc =PositionAbsolute ;_efbbe ._fggc =x ;_efbbe ._ffgg =y ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_a .PdfPage )(*Block ,error ){_fcb :=&Block {};_cdc ,_da :=page .GetAllContentStreams ();if _da !=nil {return nil ,_da ;};_ad :=_gg .NewContentStreamParser (_cdc );_fcf ,_da :=_ad .Parse ();if _da !=nil {return nil ,_da ;};_fcf .WrapIfNeeded ();_fcb ._cd =_fcf ;if page .Resources !=nil {_fcb ._ef =page .Resources ;}else {_fcb ._ef =_a .NewPdfPageResources ();};_ea ,_da :=page .GetMediaBox ();if _da !=nil {return nil ,_da ;};if _ea .Llx !=0||_ea .Lly !=0{_fcb .translate (-_ea .Llx ,_ea .Lly );};_fcb ._gc =_ea .Urx -_ea .Llx ;_fcb ._bg =_ea .Ury -_ea .Lly ;if page .Rotate !=nil {_fcb ._bef =-float64 (*page .Rotate );};return _fcb ,nil ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// SetNumber sets the number of the invoice.
func (_becc *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_becc ._cdgc [1].Value =number ;return _becc ._cdgc [0],_becc ._cdgc [1];};

// SetColorBottom sets border color for bottom.
func (_bbg *border )SetColorBottom (col Color ){_bbg ._dbd =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetWidthLeft sets border width for left.
func (_dee *border )SetWidthLeft (bw float64 ){_dee ._fdgd =bw };

// SetAngle sets the rotation angle of the text.
func (_ccbea *StyledParagraph )SetAngle (angle float64 ){_ccbea ._gada =angle };

// SetTitleStyle sets the style properties of the invoice title.
func (_addb *Invoice )SetTitleStyle (style TextStyle ){_addb ._adff =style };func (_daee *StyledParagraph )getTextWidth ()float64 {var _eegf float64 ;_fcce :=len (_daee ._cebe );for _acccb ,_afbd :=range _daee ._cebe {_daac :=&_afbd .Style ;_dgbac :=len (_afbd .Text );for _cdbd ,_gcdf :=range _afbd .Text {if _gcdf =='\u000A'{continue ;};_cabd ,_dagd :=_daac .Font .GetRuneMetrics (_gcdf );if !_dagd {_gd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_gcdf );return -1;};_eegf +=_daac .FontSize *_cabd .Wx ;if _gcdf !=' '&&(_acccb !=_fcce -1||_cdbd !=_dgbac -1){_eegf +=_daac .CharSpacing *1000.0;};};};return _eegf ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_daba *Invoice )NoteHeadingStyle ()TextStyle {return _daba ._ggf };

// SetLevel sets the indentation level of the TOC line.
func (_dgbb *TOCLine )SetLevel (level uint ){_dgbb ._fced =level ;_dgbb ._cabdd ._gggf .Left =_dgbb ._abcc +float64 (_dgbb ._fced -1)*_dgbb ._gfgc ;};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_dfeb float64 ;_aabe float64 ;_ffcc float64 ;_aafdf float64 ;_feegg *_a .PdfColorDeviceRGB ;_ccgba float64 ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fdaf *Creator )MoveDown (dy float64 ){_fdaf ._aaa .Y +=dy };func (_efgag *Table )clone ()*Table {_dbga :=*_efgag ;_dbga ._cbdb =make ([]float64 ,len (_efgag ._cbdb ));copy (_dbga ._cbdb ,_efgag ._cbdb );_dbga ._bdfba =make ([]float64 ,len (_efgag ._bdfba ));copy (_dbga ._bdfba ,_efgag ._bdfba );_dbga ._adef =make ([]*TableCell ,0,len (_efgag ._adef ));for _ ,_bdge :=range _efgag ._adef {_dcbff :=*_bdge ;_dcbff ._gafce =&_dbga ;_dbga ._adef =append (_dbga ._adef ,&_dcbff );};return &_dbga ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_fda *Block )duplicate ()*Block {_bf :=&Block {};*_bf =*_fda ;_gb :=_gg .ContentStreamOperations {};_gb =append (_gb ,*_fda ._cd ...);_bf ._cd =&_gb ;return _bf ;};

// SetMargins sets the Paragraph's margins.
func (_egcf *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_egcf ._gggf .Left =left ;_egcf ._gggf .Right =right ;_egcf ._gggf .Top =top ;_egcf ._gggf .Bottom =bottom ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_dcg *Image )SetEncoder (encoder _fc .StreamEncoder ){_dcg ._gdda =encoder };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_egae *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _egae ._eebf [0],_egae ._eebf [1]};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_dcdc *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdac :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_edb ,_bgeb :=_bdac .setOpacity (_dcdc ._bcgf ,_dcdc ._bcgf );if _bgeb !=nil {return nil ,ctx ,_bgeb ;};_bfcf :=_dcdc ._bdeg .Points ;for _gebd :=range _bfcf {_fabcf :=&_bfcf [_gebd ];_fabcf .Y =ctx .PageHeight -_fabcf .Y ;};_cdeed ,_ ,_bgeb :=_dcdc ._bdeg .Draw (_edb );if _bgeb !=nil {return nil ,ctx ,_bgeb ;};if _bgeb =_bdac .addContentsByString (string (_cdeed ));_bgeb !=nil {return nil ,ctx ,_bgeb ;};return []*Block {_bdac },ctx ,nil ;};

// SetStyleTop sets border style for top side.
func (_fed *border )SetStyleTop (style CellBorderStyle ){_fed ._aece =style };func (_dgge *Block )addContents (_abg *_gg .ContentStreamOperations ){_dgge ._cd .WrapIfNeeded ();_abg .WrapIfNeeded ();*_dgge ._cd =append (*_dgge ._cd ,*_abg ...);};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ffbc *_a .PdfColorDeviceRGB ;_acfd _gf .LineStyle ;_afeca CellBorderStyle ;_dedeb *_a .PdfColorDeviceRGB ;_ebbaa float64 ;_aedfc CellBorderStyle ;_edec *_a .PdfColorDeviceRGB ;_cfbb float64 ;_dfede CellBorderStyle ;_beeb *_a .PdfColorDeviceRGB ;_acee float64 ;_babd CellBorderStyle ;_ecaf *_a .PdfColorDeviceRGB ;_gbdg float64 ;_dbgd ,_gdfe int ;_baccg int ;_gfegb int ;_abgfd VectorDrawable ;_bfda CellHorizontalAlignment ;_gcba CellVerticalAlignment ;_efde float64 ;_gafce *Table ;};

// SetBorderWidth sets the border width.
func (_cec *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_cec ._agde .BorderWidth =borderWidth ;};type listItem struct{_gbab VectorDrawable ;_dcdfc TextChunk ;};func (_ggec *StyledParagraph )getMaxLineWidth ()float64 {if _ggec ._aaccf ==nil ||len (_ggec ._aaccf )==0{_ggec .wrapText ();};var _ggac float64 ;for _ ,_gacb :=range _ggec ._aaccf {_becd :=_ggec .getTextLineWidth (_gacb );if _becd > _ggac {_ggac =_becd ;};};return _ggac ;};

// SetBorderOpacity sets the border opacity.
func (_eega *Rectangle )SetBorderOpacity (opacity float64 ){_eega ._dede =opacity };

// Columns returns all the columns in the invoice line items table.
func (_dge *Invoice )Columns ()[]*InvoiceCell {return _dge ._efag };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_faca *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_edaaa :=NewTextChunk (text ,_faca ._baba );_edaaa ._gfda =_caeff (page -1,x ,y ,zoom );return _faca .appendChunk (_edaaa );};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_bacd *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_adgg :=range subtable ._adef {_gbggf :=&TableCell {};*_gbggf =*_adgg ;_gbggf ._gafce =_bacd ;_gbggf ._gdfe +=col -1;if _gecbg :=_bacd ._ddgf -(_gbggf ._gdfe -1);_gecbg < _gbggf ._gfegb {_bacd ._ddgf +=_gbggf ._gfegb -_gecbg ;_bacd .resetColumnWidths ();_gd .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_bacd ._ddgf );};_gbggf ._dbgd +=row -1;_fbgbe :=subtable ._cbdb [_adgg ._dbgd -1];if _gbggf ._dbgd > _bacd ._deba {for _gbggf ._dbgd > _bacd ._deba {_bacd ._deba ++;_bacd ._cbdb =append (_bacd ._cbdb ,_bacd ._fedg );};_bacd ._cbdb [_gbggf ._dbgd -1]=_fbgbe ;}else {_bacd ._cbdb [_gbggf ._dbgd -1]=_bb .Max (_bacd ._cbdb [_gbggf ._dbgd -1],_fbgbe );};_bacd ._adef =append (_bacd ._adef ,_gbggf );};_b .Slice (_bacd ._adef ,func (_cca ,_gbcb int )bool {_geffc :=_bacd ._adef [_cca ]._dbgd ;_ecfg :=_bacd ._adef [_gbcb ]._dbgd ;if _geffc < _ecfg {return true ;};if _geffc > _ecfg {return false ;};return _bacd ._adef [_cca ]._gdfe < _bacd ._adef [_gbcb ]._gdfe ;});};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_dbdff *TOC )SetHeading (text string ,style TextStyle ){_gdfc :=_dbdff .Heading ();_gdfc .Reset ();_ddad :=_gdfc .Append (text );_ddad .Style =style ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_efec *Paragraph )Height ()float64 {_efec .wrapText ();return float64 (len (_efec ._abbb ))*_efec ._dcfaad *_efec ._gadb ;};

// SetBorderWidth sets the border width.
func (_bdda *Ellipse )SetBorderWidth (bw float64 ){_bdda ._fbdg =bw };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gcb *Chapter )SetShowNumbering (show bool ){_gcb ._aagf =show ;_gcb ._eafb .SetText (_gcb .headingText ());};func (_egbae *StyledParagraph )wrapChunks (_beadd bool )error {if !_egbae ._bgeg ||int (_egbae ._eeeac )<=0{_egbae ._aaccf =[][]*TextChunk {_egbae ._cebe };return nil ;};_egbae ._aaccf =[][]*TextChunk {};var _adfe []*TextChunk ;var _bdag float64 ;_cebg :=_ga .IsSpace ;if !_beadd {_cebg =func (rune )bool {return false };};for _ ,_aecgg :=range _egbae ._cebe {_gdgb :=_aecgg .Style ;_facbe :=_aecgg ._gfda ;var (_eaac []rune ;_gdbb []float64 ;);for _ ,_cfcc :=range _aecgg .Text {if _cfcc =='\u000A'{_adfe =append (_adfe ,&TextChunk {Text :_bd .TrimRightFunc (string (_eaac ),_cebg ),Style :_gdgb ,_gfda :_debaf (_facbe )});_egbae ._aaccf =append (_egbae ._aaccf ,_adfe );_adfe =nil ;_bdag =0;_eaac =nil ;_gdbb =nil ;continue ;};_eaaac :=_cfcc ==' ';_deac ,_decg :=_gdgb .Font .GetRuneMetrics (_cfcc );if !_decg {_gd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cfcc );return _c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_cdadd :=_gdgb .FontSize *_deac .Wx ;_fdedf :=_cdadd ;if !_eaaac {_fdedf =_cdadd +_gdgb .CharSpacing *1000.0;};if _bdag +_cdadd > _egbae ._eeeac *1000.0{_gfbde :=-1;if !_eaaac {for _abaf :=len (_eaac )-1;_abaf >=0;_abaf --{if _eaac [_abaf ]==' '{_gfbde =_abaf ;break ;};};};_edce :=string (_eaac );if _gfbde >=0{_edce =string (_eaac [0:_gfbde +1]);_eaac =_eaac [_gfbde +1:];_eaac =append (_eaac ,_cfcc );_gdbb =_gdbb [_gfbde +1:];_gdbb =append (_gdbb ,_fdedf );_bdag =0;for _ ,_aeda :=range _gdbb {_bdag +=_aeda ;};}else {if _eaaac {_bdag =0;_eaac =[]rune {};_gdbb =[]float64 {};}else {_bdag =_fdedf ;_eaac =[]rune {_cfcc };_gdbb =[]float64 {_fdedf };};};if !_beadd &&_eaaac {_edce +="\u0020";};_adfe =append (_adfe ,&TextChunk {Text :_bd .TrimRightFunc (_edce ,_cebg ),Style :_gdgb ,_gfda :_debaf (_facbe )});_egbae ._aaccf =append (_egbae ._aaccf ,_adfe );_adfe =[]*TextChunk {};}else {_bdag +=_fdedf ;_eaac =append (_eaac ,_cfcc );_gdbb =append (_gdbb ,_fdedf );};};if len (_eaac )> 0{_adfe =append (_adfe ,&TextChunk {Text :string (_eaac ),Style :_gdgb ,_gfda :_debaf (_facbe )});};};if len (_adfe )> 0{_egbae ._aaccf =append (_egbae ._aaccf ,_adfe );};return nil ;};func (_fge *Block )setOpacity (_gdc float64 ,_fcd float64 )(string ,error ){if (_gdc < 0||_gdc >=1.0)&&(_fcd < 0||_fcd >=1.0){return "",nil ;};_adf :=0;_fd :=_f .Sprintf ("\u0047\u0053\u0025\u0064",_adf );for _fge ._ef .HasExtGState (_fc .PdfObjectName (_fd )){_adf ++;_fd =_f .Sprintf ("\u0047\u0053\u0025\u0064",_adf );};_bc :=_fc .MakeDict ();if _gdc >=0&&_gdc < 1.0{_bc .Set ("\u0063\u0061",_fc .MakeFloat (_gdc ));};if _fcd >=0&&_fcd < 1.0{_bc .Set ("\u0043\u0041",_fc .MakeFloat (_fcd ));};_bge :=_fge ._ef .AddExtGState (_fc .PdfObjectName (_fd ),_bc );if _bge !=nil {return "",_bge ;};return _fd ,nil ;};func (_afb *Creator )newPage ()*_a .PdfPage {_ffg :=_a .NewPdfPage ();_gfbbf :=_afb ._adfb [0];_ecca :=_afb ._adfb [1];_edgbd :=_a .PdfRectangle {Llx :0,Lly :0,Urx :_gfbbf ,Ury :_ecca };_ffg .MediaBox =&_edgbd ;_afb ._dbag =_gfbbf ;_afb ._aba =_ecca ;_afb .initContext ();return _ffg ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// IsAbsolute checks if the positioning is absolute.
func (_fdcg Positioning )IsAbsolute ()bool {return _fdcg ==PositionAbsolute };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_gebef *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_gebef ._gcba =valign };

// NewTable create a new Table with a specified number of columns.
func (_ddef *Creator )NewTable (cols int )*Table {return _gagg (cols )};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_cebe []*TextChunk ;_fefe TextStyle ;_baba TextStyle ;_acga TextAlignment ;_dbdfb float64 ;_bgeg bool ;_eeeac float64 ;_cccd bool ;_gada float64 ;_gggf Margins ;_efdbe Positioning ;_gcbf float64 ;_dgfc float64 ;_acfg float64 ;_dbgcg float64 ;_aaccf [][]*TextChunk ;_ggdd func (_dae *StyledParagraph ,_eaff DrawContext );};

// Margins returns the margins of the list: left, right, top, bottom.
func (_efdf *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _efdf ._eacf .Left ,_efdf ._eacf .Right ,_efdf ._eacf .Top ,_efdf ._eacf .Bottom ;};

// NewImageFromData creates an Image from image data.
func (_cdee *Creator )NewImageFromData (data []byte )(*Image ,error ){return _ecec (data )};

// SetWidthBottom sets border width for bottom.
func (_efa *border )SetWidthBottom (bw float64 ){_efa ._fdba =bw };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_ccda *TOC )SetLinePageStyle (style TextStyle ){_ccda ._fdff =style };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);func (_bce *Chapter )headingNumber ()string {var _acc string ;if _bce ._aagf {if _bce ._aabc !=0{_acc =_g .Itoa (_bce ._aabc )+"\u002e";};if _bce ._ccg !=nil {_afc :=_bce ._ccg .headingNumber ();if _afc !=""{_acc =_afc +_acc ;};};};return _acc ;};

// Reset removes all the text chunks the paragraph contains.
func (_cadf *StyledParagraph )Reset (){_cadf ._cebe =[]*TextChunk {}};

// SetBorderOpacity sets the border opacity.
func (_ecbb *Polygon )SetBorderOpacity (opacity float64 ){_ecbb ._gcfcg =opacity };

// The Image type is used to draw an image onto PDF.
type Image struct{_efed *_a .XObjectImage ;_bgffc *_a .Image ;_efgf float64 ;_baed ,_dce float64 ;_cdcg ,_gface float64 ;_dbdg Positioning ;_cfea HorizontalAlignment ;_afge float64 ;_ggbb float64 ;_addg float64 ;_eabg Margins ;_aae ,_beafc float64 ;_gdda _fc .StreamEncoder ;};

// Cols returns the total number of columns the table has.
func (_dbaga *Table )Cols ()int {return _dbaga ._ddgf };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_abee *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _abee ._egb .Left ,_abee ._egb .Right ,_abee ._egb .Top ,_abee ._egb .Bottom ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_daea *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_eecf :=&_daea ._cabdd ._gggf ;return _daea ._abcc ,_eecf .Right ,_eecf .Top ,_eecf .Bottom ;};

// Lines returns all the rows of the invoice line items table.
func (_cedg *Invoice )Lines ()[][]*InvoiceCell {return _cedg ._baa };

// Notes returns the notes section of the invoice as a title-content pair.
func (_fce *Invoice )Notes ()(string ,string ){return _fce ._cfge [0],_fce ._cfge [1]};

// Width returns the width of the Paragraph.
func (_bggaa *Paragraph )Width ()float64 {if _bggaa ._aabgd &&int (_bggaa ._bfag )> 0{return _bggaa ._bfag ;};return _bggaa .getTextWidth ()/1000.0;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};func _debaf (_gfea *_a .PdfAnnotation )*_a .PdfAnnotation {if _gfea ==nil {return nil ;};var _eggda *_a .PdfAnnotation ;switch _abeff :=_gfea .GetContext ().(type ){case *_a .PdfAnnotationLink :if _geag :=_decag (_abeff );_geag !=nil {_eggda =_geag .PdfAnnotation ;};};return _eggda ;};

// MoveX moves the drawing context to absolute position x.
func (_baef *Creator )MoveX (x float64 ){_baef ._aaa .X =x };

// SetLineWidth sets the line width.
func (_agaf *Polyline )SetLineWidth (lineWidth float64 ){_agaf ._bdeg .LineWidth =lineWidth };

// SetFillColor sets the fill color.
func (_eagg *Polygon )SetFillColor (color Color ){_eagg ._dfefg .FillColor =_a .NewPdfColorDeviceRGB (color .ToRGB ());};

// AddLine adds a new line with the provided style to the table of contents.
func (_fcgc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_fcgc ._bfbf =append (_fcgc ._bfbf ,line );return line ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_edca *Creator )Draw (d Drawable )error {if _edca .getActivePage ()==nil {_edca .NewPage ();};_aacb ,_cgfd ,_adae :=d .GeneratePageBlocks (_edca ._aaa );if _adae !=nil {return _adae ;};for _ffcb ,_fcgec :=range _aacb {if _ffcb > 0{_edca .NewPage ();};_gea :=_edca .getActivePage ();if _ace ,_acg :=_edca ._dbea [_gea ];_acg {if _gbd :=_ace .mergeBlocks (_fcgec );_gbd !=nil {return _gbd ;};if _daad :=_bae (_fcgec ._ef ,_ace ._ef );_daad !=nil {return _daad ;};}else {_edca ._dbea [_gea ]=_fcgec ;};};_edca ._aaa .X =_cgfd .X ;_edca ._aaa .Y =_cgfd .Y ;_edca ._aaa .Height =_cgfd .PageHeight -_cgfd .Y -_cgfd .Margins .Bottom ;return nil ;};func (_bfb *Block )drawToPage (_fe *_a .PdfPage )error {_bgg :=&_gg .ContentStreamOperations {};if _fe .Resources ==nil {_fe .Resources =_a .NewPdfPageResources ();};_fa :=_bag (_bgg ,_fe .Resources ,_bfb ._cd ,_bfb ._ef );if _fa !=nil {return _fa ;};if _fa =_bae (_bfb ._ef ,_fe .Resources );_fa !=nil {return _fa ;};if _fa =_fe .AppendContentBytes (_bgg .Bytes (),true );_fa !=nil {return _fa ;};for _ ,_ca :=range _bfb ._aa {_fe .AddAnnotation (_ca );};return nil ;};

// GetRowHeight returns the height of the specified row.
func (_fefa *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_fefa ._cbdb ){return 0,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _fefa ._cbdb [row -1],nil ;};func (_fgdg *Paragraph )getTextLineWidth (_babf string )float64 {var _bfaf float64 ;for _ ,_fcfc :=range _babf {if _fcfc =='\u000A'{continue ;};_fdbd ,_gfaag :=_fgdg ._ebegd .GetRuneMetrics (_fcfc );if !_gfaag {_gd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_fcfc ,_fcfc );return -1;};_bfaf +=_fgdg ._gadb *_fdbd .Wx ;};return _bfaf ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetAngle sets the rotation angle in degrees.
func (_fg *Block )SetAngle (angleDeg float64 ){_fg ._bef =angleDeg };

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_dacc *Creator )AddPage (page *_a .PdfPage )error {_dbf ,_baga :=page .GetMediaBox ();if _baga !=nil {_gd .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_baga );return _baga ;};_dbf .Normalize ();_fga ,_adb :=_dbf .Llx ,_dbf .Lly ;_bbf :=_be .IdentityMatrix ();_abc :=page .Rotate ;_ggb :=_abc !=nil &&*_abc %360!=0&&*_abc %90==0;if _ggb {_cgc :=float64 ((360+*page .Rotate %360)%360);if _cgc ==90{_bbf =_bbf .Translate (_dbf .Width (),0);}else if _cgc ==180{_bbf =_bbf .Translate (_dbf .Width (),_dbf .Height ());}else if _cgc ==270{_bbf =_bbf .Translate (0,_dbf .Height ());};_bbf =_bbf .Mult (_be .RotationMatrix (_cgc *_bb .Pi /180));_bbf =_bbf .Round (0.000001);_abb :=_gfedf (_dbf ,_bbf );_dbf =_abb ;_dbf .Normalize ();};if _fga !=0||_adb !=0{_bbf =_be .TranslationMatrix (_fga ,_adb ).Mult (_bbf );};if !_bbf .Identity (){if _dacc ._gcfg ==nil {_dacc ._gcfg =map[*_a .PdfPage ]_be .Matrix {};};_bbf =_bbf .Round (0.000001);_dacc ._gcfg [page ]=_bbf ;};_dacc ._dbag =_dbf .Width ();_dacc ._aba =_dbf .Height ();_dacc .initContext ();_dacc ._gcbc =append (_dacc ._gcbc ,page );_dacc ._aaa .Page ++;return nil ;};

// Angle returns the block rotation angle in degrees.
func (_ab *Block )Angle ()float64 {return _ab ._bef };

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_cfdf *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _adfgc (x ,y ,width ,height );};

// NewInvoice returns an instance of an empty invoice.
func (_fcbb *Creator )NewInvoice ()*Invoice {_gcff :=_fcbb .NewTextStyle ();_gcff .Font =_fcbb ._aef ;return _bdecc (_fcbb .NewTextStyle (),_gcff );};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_ggee *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_ggee ._geg .Left =left ;_ggee ._geg .Right =right ;_ggee ._geg .Top =top ;_ggee ._geg .Bottom =bottom ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_ggca *Creator )NewImage (img *_a .Image )(*Image ,error ){return _caa (img )};

// SellerAddress returns the seller address used in the invoice template.
func (_eacc *Invoice )SellerAddress ()*InvoiceAddress {return _eacc ._fcbg };func _egfdb (_adda [][]_gf .Point )*Polygon {return &Polygon {_dfefg :&_gf .Polygon {Points :_adda },_bfdb :1.0,_gcfcg :1.0};};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_abac *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cdea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eegc ,_ ,_bgfa :=_abac .draw ("");if _bgfa !=nil {return nil ,ctx ,_bgfa ;};_bgfa =_cdea .addContentsByString (string (_eegc ));if _bgfa !=nil {return nil ,ctx ,_bgfa ;};return []*Block {_cdea },ctx ,nil ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_ee *Block )ScaleToHeight (h float64 ){_ge :=h /_ee ._bg ;_ee .Scale (_ge ,_ge )};func _gbeb (_bded _eb .Image )(*Image ,error ){_bcbf ,_acae :=_a .ImageHandling .NewImageFromGoImage (_bded );if _acae !=nil {return nil ,_acae ;};return _caa (_bcbf );};func _gagg (_dedb int )*Table {_gfaccd :=&Table {_ddgf :_dedb ,_fedg :10.0,_bdfba :[]float64 {},_cbdb :[]float64 {},_adef :[]*TableCell {}};_gfaccd .resetColumnWidths ();return _gfaccd ;};func (_dfdcf *Invoice )generateLineBlocks (_dcgf DrawContext )([]*Block ,DrawContext ,error ){_agdca :=_gagg (len (_dfdcf ._efag ));_agdca .SetMargins (0,0,25,0);for _ ,_abda :=range _dfdcf ._efag {_efeb :=_fdege (_abda .TextStyle );_efeb .SetMargins (0,0,1,0);_efeb .Append (_abda .Value );_egag :=_agdca .NewCell ();_egag .SetHorizontalAlignment (_abda .Alignment );_egag .SetBackgroundColor (_abda .BackgroundColor );_dfdcf .setCellBorder (_egag ,_abda );_egag .SetContent (_efeb );};for _ ,_gebe :=range _dfdcf ._baa {for _ ,_faaeg :=range _gebe {_afca :=_fdege (_faaeg .TextStyle );_afca .SetMargins (0,0,3,2);_afca .Append (_faaeg .Value );_cgbbc :=_agdca .NewCell ();_cgbbc .SetHorizontalAlignment (_faaeg .Alignment );_cgbbc .SetBackgroundColor (_faaeg .BackgroundColor );_dfdcf .setCellBorder (_cgbbc ,_faaeg );_cgbbc .SetContent (_afca );};};return _agdca .GeneratePageBlocks (_dcgf );};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_fdd *Creator )SetPageSize (size PageSize ){_fdd ._adfb =size ;_fdd ._dbag =size [0];_fdd ._aba =size [1];_bfgb :=0.1*_fdd ._dbag ;_fdd ._geg .Left =_bfgb ;_fdd ._geg .Right =_bfgb ;_fdd ._geg .Top =_bfgb ;_fdd ._geg .Bottom =_bfgb ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fgcba *TOC )SetLineSeparator (separator string ){_fgcba ._debda =separator };func _egge ()*Division {return &Division {_fafc :[]VectorDrawable {}}};

// SetText replaces all the text of the paragraph with the specified one.
func (_fbde *StyledParagraph )SetText (text string )*TextChunk {_fbde .Reset ();return _fbde .Append (text );};func (_fgeb *StyledParagraph )getTextHeight ()float64 {var _cfee float64 ;for _ ,_ccbb :=range _fgeb ._cebe {_aggdg :=_ccbb .Style .FontSize *_fgeb ._dbdfb ;if _aggdg > _cfee {_cfee =_aggdg ;};};return _cfee ;};func _fega (_daae *Block ,_gggc *Image ,_fbcf DrawContext )(DrawContext ,error ){_fbce :=_fbcf ;_cbdf :=1;_fgdb :=_fc .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_cbdf ));for _daae ._ef .HasXObjectByName (_fgdb ){_cbdf ++;_fgdb =_fc .PdfObjectName (_f .Sprintf ("\u0049\u006d\u0067%\u0064",_cbdf ));};_caag :=_daae ._ef .SetXObjectImageByName (_fgdb ,_gggc ._efed );if _caag !=nil {return _fbcf ,_caag ;};_dabd :=0;_fgcgd :=_fc .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_dabd ));for _daae ._ef .HasExtGState (_fgcgd ){_dabd ++;_fgcgd =_fc .PdfObjectName (_f .Sprintf ("\u0047\u0053\u0025\u0064",_dabd ));};_ffdc :=_fc .MakeDict ();_ffdc .Set ("\u0042\u004d",_fc .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _gggc ._addg < 1.0{_ffdc .Set ("\u0043\u0041",_fc .MakeFloat (_gggc ._addg ));_ffdc .Set ("\u0063\u0061",_fc .MakeFloat (_gggc ._addg ));};_caag =_daae ._ef .AddExtGState (_fgcgd ,_fc .MakeIndirectObject (_ffdc ));if _caag !=nil {return _fbcf ,_caag ;};_bdga :=_gggc .Width ();_cace :=_gggc .Height ();_ ,_bcee :=_gggc .rotatedSize ();_fecf :=_fbcf .X ;_ffee :=_fbcf .PageHeight -_fbcf .Y -_cace ;if _gggc ._dbdg .IsRelative (){_ffee -=(_bcee -_cace )/2;switch _gggc ._cfea {case HorizontalAlignmentCenter :_fecf +=(_fbcf .Width -_bdga )/2;case HorizontalAlignmentRight :_fecf =_fbcf .PageWidth -_fbcf .Margins .Right -_gggc ._eabg .Right -_bdga ;};};_deef :=_gggc ._efgf ;_dgbg :=_gg .NewContentCreator ();_dgbg .Add_gs (_fgcgd );_dgbg .Translate (_fecf ,_ffee );if _deef !=0{_dgbg .Translate (_bdga /2,_cace /2);_dgbg .RotateDeg (_deef );_dgbg .Translate (-_bdga /2,-_cace /2);};_dgbg .Scale (_bdga ,_cace ).Add_Do (_fgdb );_bfeg :=_dgbg .Operations ();_bfeg .WrapIfNeeded ();_daae .addContents (_bfeg );if _gggc ._dbdg .IsRelative (){_fbcf .Y +=_bcee ;_fbcf .Height -=_bcee ;return _fbcf ,nil ;};return _fbce ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_dgg *Block )AddAnnotation (annotation *_a .PdfAnnotation ){for _ ,_bca :=range _dgg ._aa {if _bca ==annotation {return ;};};_dgg ._aa =append (_dgg ._aa ,annotation );};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_ebcf *TableCell )SetContent (vd VectorDrawable )error {switch _fgdabd :=vd .(type ){case *Paragraph :if _fgdabd ._fcgfg {_fgdabd ._aabgd =true ;};_ebcf ._abgfd =vd ;case *StyledParagraph :if _fgdabd ._cccd {_fgdabd ._bgeg =true ;};_ebcf ._abgfd =vd ;case *Image :_ebcf ._abgfd =vd ;case *Table :_ebcf ._abgfd =vd ;case *List :_ebcf ._abgfd =vd ;case *Division :_ebcf ._abgfd =vd ;default:_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );return _fc .ErrTypeError ;};return nil ;};

// SetWidthTop sets border width for top.
func (_fdga *border )SetWidthTop (bw float64 ){_fdga ._abe =bw };const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// WriteToFile writes the Creator output to file specified by path.
func (_ebaf *Creator )WriteToFile (outputPath string )error {_abaa ,_aecg :=_cc .Create (outputPath );if _aecg !=nil {return _aecg ;};defer _abaa .Close ();return _ebaf .Write (_abaa );};func (_egcca *Image )rotatedSize ()(float64 ,float64 ){_dgdc :=_egcca ._baed ;_fbda :=_egcca ._dce ;_aegb :=_egcca ._efgf ;if _aegb ==0{return _dgdc ,_fbda ;};_fdafe :=_gf .Path {Points :[]_gf .Point {_gf .NewPoint (0,0).Rotate (_aegb ),_gf .NewPoint (_dgdc ,0).Rotate (_aegb ),_gf .NewPoint (0,_fbda ).Rotate (_aegb ),_gf .NewPoint (_dgdc ,_fbda ).Rotate (_aegb )}}.GetBoundingBox ();return _fdafe .Width ,_fdafe .Height ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_dgfd *Creator )NewTextStyle ()TextStyle {return _begg (_dgfd ._bffb )};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_dcfd *Invoice )Sections ()[][2]string {return _dcfd ._dagab };func _eca (_dbab *Chapter ,_eeaf *TOC ,_cdce *_a .Outline ,_bde string ,_fcgg int ,_ffa TextStyle )*Chapter {var _dcd uint =1;if _dbab !=nil {_dcd =_dbab ._faac +1;};_ffe :=&Chapter {_aabc :_fcgg ,_gbf :_bde ,_aagf :true ,_ebg :true ,_ccg :_dbab ,_dea :_eeaf ,_bfe :_cdce ,_gag :[]Drawable {},_faac :_dcd };_afe :=_cbcd (_ffe .headingText (),_ffa );_afe .SetFont (_ffa .Font );_afe .SetFontSize (_ffa .FontSize );_ffe ._eafb =_afe ;return _ffe ;};func (_ccba *Invoice )drawAddress (_gabef *InvoiceAddress )[]*StyledParagraph {var _dfbc []*StyledParagraph ;if _gabef .Heading !=""{_ecgcf :=_fdege (_ccba ._baebc );_ecgcf .SetMargins (0,0,0,7);_ecgcf .Append (_gabef .Heading );_dfbc =append (_dfbc ,_ecgcf );};_gbgd :=_fdege (_ccba ._fgaeb );_gbgd .SetLineHeight (1.2);_aebe :=_gabef .Separator ;if _aebe ==""{_aebe =_ccba ._afbg ;};_ecag :=_gabef .City ;if _gabef .State !=""{if _ecag !=""{_ecag +=_aebe ;};_ecag +=_gabef .State ;};if _gabef .Zip !=""{if _ecag !=""{_ecag +=_aebe ;};_ecag +=_gabef .Zip ;};if _gabef .Name !=""{_gbgd .Append (_gabef .Name +"\u000a");};if _gabef .Street !=""{_gbgd .Append (_gabef .Street +"\u000a");};if _gabef .Street2 !=""{_gbgd .Append (_gabef .Street2 +"\u000a");};if _ecag !=""{_gbgd .Append (_ecag +"\u000a");};if _gabef .Country !=""{_gbgd .Append (_gabef .Country +"\u000a");};_cgec :=_fdege (_ccba ._fgaeb );_cgec .SetLineHeight (1.2);_cgec .SetMargins (0,0,7,0);if _gabef .Phone !=""{_cgec .Append (_gabef .fmtLine (_gabef .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_gabef .HidePhoneLabel ));};if _gabef .Email !=""{_cgec .Append (_gabef .fmtLine (_gabef .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_gabef .HideEmailLabel ));};_dfbc =append (_dfbc ,_gbgd ,_cgec );return _dfbc ;};func _bbaa (_fee ,_dfb ,_feb ,_gdee float64 )*border {_gaeg :=&border {};_gaeg ._dde =_fee ;_gaeg ._efdg =_dfb ;_gaeg ._fbbf =_feb ;_gaeg ._bba =_gdee ;_gaeg ._ac =_a .NewPdfColorDeviceRGB (0,0,0);_gaeg ._dbd =_a .NewPdfColorDeviceRGB (0,0,0);_gaeg ._aff =_a .NewPdfColorDeviceRGB (0,0,0);_gaeg ._ddbb =_a .NewPdfColorDeviceRGB (0,0,0);_gaeg ._abe =0;_gaeg ._fdba =0;_gaeg ._fdgd =0;_gaeg ._edea =0;_gaeg .LineStyle =_gf .LineStyleSolid ;return _gaeg ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ccgg *Invoice )InfoLines ()[][2]*InvoiceCell {_bdbg :=[][2]*InvoiceCell {_ccgg ._cdgc ,_ccgg ._dfdb ,_ccgg ._eebf };return append (_bdbg ,_ccgg ._aafaa ...);};

// AppendColumn appends a column to the line items table.
func (_eafa *Invoice )AppendColumn (description string )*InvoiceCell {_dcga :=_eafa .NewColumn (description );_eafa ._efag =append (_eafa ._efag ,_dcga );return _dcga ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_ecg *Block )ScaleToWidth (w float64 ){_cdf :=w /_ecg ._gc ;_ecg .Scale (_cdf ,_cdf )};

// Width returns the cell's width based on the input draw context.
func (_fegcb *TableCell )Width (ctx DrawContext )float64 {_ebgb :=float64 (0.0);for _dbee :=0;_dbee < _fegcb ._gfegb ;_dbee ++{_ebgb +=_fegcb ._gafce ._bdfba [_fegcb ._gdfe +_dbee -1];};_acbe :=ctx .Width *_ebgb ;return _acbe ;};

// Context returns the current drawing context.
func (_fgf *Creator )Context ()DrawContext {return _fgf ._aaa };

// SetFillOpacity sets the fill opacity.
func (_cfgc *Polygon )SetFillOpacity (opacity float64 ){_cfgc ._bfdb =opacity };func (_fgcfd *Invoice )generateTotalBlocks (_debf DrawContext )([]*Block ,DrawContext ,error ){_ceba :=_gagg (4);_ceba .SetMargins (0,0,10,10);_fbdc :=[][2]*InvoiceCell {_fgcfd ._beabb };_fbdc =append (_fbdc ,_fgcfd ._bbbe ...);_fbdc =append (_fbdc ,_fgcfd ._dcdf );for _ ,_ccbg :=range _fbdc {_bfgf ,_ecda :=_ccbg [0],_ccbg [1];if _ecda .Value ==""{continue ;};_ceba .SkipCells (2);_aagg :=_ceba .NewCell ();_aagg .SetBackgroundColor (_bfgf .BackgroundColor );_aagg .SetHorizontalAlignment (_ecda .Alignment );_fgcfd .setCellBorder (_aagg ,_bfgf );_acab :=_fdege (_bfgf .TextStyle );_acab .SetMargins (0,0,2,1);_acab .Append (_bfgf .Value );_aagg .SetContent (_acab );_aagg =_ceba .NewCell ();_aagg .SetBackgroundColor (_ecda .BackgroundColor );_aagg .SetHorizontalAlignment (_ecda .Alignment );_fgcfd .setCellBorder (_aagg ,_bfgf );_acab =_fdege (_ecda .TextStyle );_acab .SetMargins (0,0,2,1);_acab .Append (_ecda .Value );_aagg .SetContent (_acab );};return _ceba .GeneratePageBlocks (_debf );};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bfegf *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bfegf ._gggf .Left ,_bfegf ._gggf .Right ,_bfegf ._gggf .Top ,_bfegf ._gggf .Bottom ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_aeea string ;_ebegd *_a .PdfFont ;_gadb float64 ;_dcfaad float64 ;_aegd _a .PdfColorDeviceRGB ;_dggge TextAlignment ;_aabgd bool ;_bfag float64 ;_aggf int ;_fcgfg bool ;_eaccb float64 ;_bgfcg Margins ;_aega Positioning ;_gbaa float64 ;_eddbe float64 ;_fdcf ,_dfee float64 ;_abbb []string ;};

// Height returns the total height of all rows.
func (_cdcda *Table )Height ()float64 {_bbagg :=float64 (0.0);for _ ,_dced :=range _cdcda ._cbdb {_bbagg +=_dced ;};return _bbagg ;};func _acea ()*FilledCurve {_adc :=FilledCurve {};_adc ._egfe =[]_gf .CubicBezierCurve {};return &_adc };func _ccf (_dcde ,_fadf ,_fada ,_eac float64 )*Ellipse {_gcfc :=&Ellipse {};_gcfc ._caf =_dcde ;_gcfc ._dbff =_fadf ;_gcfc ._dbeb =_fada ;_gcfc ._dgfa =_eac ;_gcfc ._aggd =_a .NewPdfColorDeviceRGB (0,0,0);_gcfc ._fbdg =1.0;return _gcfc ;};

// SetBorderColor sets the border color for the path.
func (_bgb *FilledCurve )SetBorderColor (color Color ){_bgb ._dffb =_a .NewPdfColorDeviceRGB (color .ToRGB ());};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_eadf *Invoice )AddressStyle ()TextStyle {return _eadf ._fgaeb };func _fdege (_ffdg TextStyle )*StyledParagraph {return &StyledParagraph {_cebe :[]*TextChunk {},_fefe :_ffdg ,_baba :_cffb (_ffdg .Font ),_dbdfb :1.0,_acga :TextAlignmentLeft ,_bgeg :true ,_cccd :true ,_gada :0,_acfg :1,_dbgcg :1,_efdbe :PositionRelative };};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_dfefg *_gf .Polygon ;_bfdb float64 ;_gcfcg float64 ;};

// SetStyleLeft sets border style for left side.
func (_cbf *border )SetStyleLeft (style CellBorderStyle ){_cbf ._gff =style };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_aabc int ;_gbf string ;_eafb *Paragraph ;_gag []Drawable ;_gfg int ;_aagf bool ;_ebg bool ;_fbba Positioning ;_deg ,_cefc float64 ;_egb Margins ;_ccg *Chapter ;_dea *TOC ;_bfe *_a .Outline ;_cggd *_a .OutlineItem ;_faac uint ;};func (_abfd *Creator )initContext (){_abfd ._aaa .X =_abfd ._geg .Left ;_abfd ._aaa .Y =_abfd ._geg .Top ;_abfd ._aaa .Width =_abfd ._dbag -_abfd ._geg .Right -_abfd ._geg .Left ;_abfd ._aaa .Height =_abfd ._aba -_abfd ._geg .Bottom -_abfd ._geg .Top ;_abfd ._aaa .PageHeight =_abfd ._aba ;_abfd ._aaa .PageWidth =_abfd ._dbag ;_abfd ._aaa .Margins =_abfd ._geg ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_cgcg *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _ebda []*Block ;_faea :=ctx ;if _cgcg ._ffgf .IsRelative (){ctx .X +=_cgcg ._bfgc .Left ;ctx .Y +=_cgcg ._bfgc .Top ;ctx .Width -=_cgcg ._bfgc .Left +_cgcg ._bfgc .Right ;ctx .Height -=_cgcg ._bfgc .Top +_cgcg ._bfgc .Bottom ;};ctx .Inline =_cgcg ._gga ;_bfbc :=ctx ;_eeed :=ctx ;var _gefb float64 ;for _ ,_faaa :=range _cgcg ._fafc {if ctx .Inline {if (ctx .X -_bfbc .X )+_faaa .Width ()<=ctx .Width {ctx .Y =_eeed .Y ;ctx .Height =_eeed .Height ;}else {ctx .X =_bfbc .X ;ctx .Width =_bfbc .Width ;_eeed .Y +=_gefb ;_eeed .Height -=_gefb ;_gefb =0;};};_bdec ,_cdad ,_gbdb :=_faaa .GeneratePageBlocks (ctx );if _gbdb !=nil {_gd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_gbdb );return nil ,ctx ,_gbdb ;};if len (_bdec )< 1{continue ;};if len (_ebda )> 0{_ebda [len (_ebda )-1].mergeBlocks (_bdec [0]);_ebda =append (_ebda ,_bdec [1:]...);}else {_ebda =append (_ebda ,_bdec [0:]...);};if ctx .Inline {if ctx .Page !=_cdad .Page {_bfbc .Y =ctx .Margins .Top ;_bfbc .Height =ctx .PageHeight -ctx .Margins .Top ;_eeed .Y =_bfbc .Y ;_eeed .Height =_bfbc .Height ;_gefb =_cdad .Height -_bfbc .Height ;}else {if _dfef :=ctx .Height -_cdad .Height ;_dfef > _gefb {_gefb =_dfef ;};};}else {_cdad .X =ctx .X ;};ctx =_cdad ;};ctx .Inline =_faea .Inline ;if _cgcg ._ffgf .IsRelative (){ctx .X =_faea .X ;};if _cgcg ._ffgf .IsAbsolute (){return _ebda ,_faea ,nil ;};return _ebda ,ctx ,nil ;};

// SetBorder sets the cell's border style.
func (_cacda *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_cacda ._afeca =CellBorderStyleSingle ;_cacda ._ebbaa =width ;_cacda ._aedfc =CellBorderStyleSingle ;_cacda ._cfbb =width ;_cacda ._dfede =CellBorderStyleSingle ;_cacda ._acee =width ;_cacda ._babd =CellBorderStyleSingle ;_cacda ._gbdg =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_cacda ._afeca =CellBorderStyleDouble ;_cacda ._ebbaa =width ;_cacda ._aedfc =CellBorderStyleDouble ;_cacda ._cfbb =width ;_cacda ._dfede =CellBorderStyleDouble ;_cacda ._acee =width ;_cacda ._babd =CellBorderStyleDouble ;_cacda ._gbdg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_cacda ._afeca =style ;_cacda ._ebbaa =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_cacda ._aedfc =style ;_cacda ._cfbb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_cacda ._dfede =style ;_cacda ._acee =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_cacda ._babd =style ;_cacda ._gbdg =width ;};};

// SetNotes sets the notes section of the invoice.
func (_adffe *Invoice )SetNotes (title ,content string ){_adffe ._cfge =[2]string {title ,content }};

// SetTotal sets the total of the invoice.
func (_ddce *Invoice )SetTotal (value string ){_ddce ._dcdf [1].Value =value };

// SetBackgroundColor sets the cell's background color.
func (_afcc *TableCell )SetBackgroundColor (col Color ){_afcc ._ffbc =_a .NewPdfColorDeviceRGB (col .ToRGB ());};func (_bbgg *Paragraph )getMaxLineWidth ()float64 {if _bbgg ._abbb ==nil ||len (_bbgg ._abbb )==0{_bbgg .wrapText ();};var _eabe float64 ;for _ ,_agdd :=range _bbgg ._abbb {_cadd :=_bbgg .getTextLineWidth (_agdd );if _cadd > _eabe {_eabe =_cadd ;};};return _eabe ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_gdcb *FilledCurve )AppendCurve (curve _gf .CubicBezierCurve )*FilledCurve {_gdcb ._egfe =append (_gdcb ._egfe ,curve );return _gdcb ;};func (_dcef *Table )resetColumnWidths (){_dcef ._bdfba =[]float64 {};_ecbe :=float64 (1.0)/float64 (_dcef ._ddgf );for _badfc :=0;_badfc < _dcef ._ddgf ;_badfc ++{_dcef ._bdfba =append (_dcef ._bdfba ,_ecbe );};};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_cfb *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _cfb ._dfeb ,_cfb ._aabe ,_cfb ._ffcc ,_cfb ._aafdf ;};func (_eged *List )tableHeight (_bfbb float64 )float64 {var _ecccd float64 ;for _ ,_egfaa :=range _eged ._deaa {switch _ddeg :=_egfaa ._gbab .(type ){case *Paragraph :_cbce :=_ddeg ;if _cbce ._aabgd {_cbce .SetWidth (_bfbb );};_ecccd +=_cbce .Height ()+_cbce ._bgfcg .Bottom +_cbce ._bgfcg .Bottom ;_ecccd +=0.5*_cbce ._gadb *_cbce ._dcfaad ;case *StyledParagraph :_fbdcc :=_ddeg ;if _fbdcc ._bgeg {_fbdcc .SetWidth (_bfbb );};_ecccd +=_fbdcc .Height ()+_fbdcc ._gggf .Top +_fbdcc ._gggf .Bottom ;_ecccd +=0.5*_fbdcc .getTextHeight ();default:_ecccd +=_egfaa ._gbab .Height ();};};return _ecccd ;};

// Indent returns the left offset of the list when nested into another list.
func (_gfaaa *List )Indent ()float64 {return _gfaaa ._dfbcd };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// SetFillOpacity sets the fill opacity.
func (_gcce *Rectangle )SetFillOpacity (opacity float64 ){_gcce ._dbdb =opacity };

// Height returns the height of the list.
func (_cdeg *List )Height ()float64 {var _cfbd float64 ;for _ ,_cbc :=range _cdeg ._deaa {_cfbd +=_cbc ._gbab .Height ();};return _cfbd ;};func _egdga (_ggfe *_cc .File )([]*_a .PdfPage ,error ){_cbdd ,_gbfcb :=_a .NewPdfReader (_ggfe );if _gbfcb !=nil {return nil ,_gbfcb ;};_cege ,_gbfcb :=_cbdd .GetNumPages ();if _gbfcb !=nil {return nil ,_gbfcb ;};var _dcfb []*_a .PdfPage ;for _bbgff :=0;_bbgff < _cege ;_bbgff ++{_afeaf ,_gaaf :=_cbdd .GetPage (_bbgff +1);if _gaaf !=nil {return nil ,_gaaf ;};_dcfb =append (_dcfb ,_afeaf );};return _dcfb ,nil ;};

// SetColorTop sets border color for top.
func (_gddc *border )SetColorTop (col Color ){_gddc ._ac =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_dcfaa DrawContext )([]*Block ,DrawContext ,error );};

// Heading returns the heading component of the table of contents.
func (_eegg *TOC )Heading ()*StyledParagraph {return _eegg ._ccaa };func _ebed (_ddb string ,_ecgc _fc .PdfObject ,_aafeb *_a .PdfPageResources )_fc .PdfObjectName {_eec :=_bd .TrimRightFunc (_bd .TrimSpace (_ddb ),func (_fae rune )bool {return _ga .IsNumber (_fae )});if _eec ==""{_eec ="\u0046\u006f\u006e\u0074";};_bee :=0;_gde :=_fc .PdfObjectName (_ddb );for {_ged ,_bgce :=_aafeb .GetFontByName (_gde );if !_bgce ||_ged ==_ecgc {break ;};_bee ++;_gde =_fc .PdfObjectName (_f .Sprintf ("\u0025\u0073\u0025\u0064",_eec ,_bee ));};return _gde ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_aegea *Creator )DrawFooter (drawFooterFunc func (_bbbc *Block ,_eeg FooterFunctionArgs )){_aegea ._cefgb =drawFooterFunc ;};

// SetLineWidth sets the line width.
func (_eeef *Line )SetLineWidth (lw float64 ){_eeef ._ccgba =lw };

// SetFontSize sets the font size in document units (points).
func (_adcg *Paragraph )SetFontSize (fontSize float64 ){_adcg ._gadb =fontSize };func (_egc rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _egc ._ceb ,_egc ._aggg ,_egc ._dfa };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_gfda *_a .PdfAnnotation ;_ggfc bool ;};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_gcee *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dffa :=ctx ;var _gdag []*Block ;_gfde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gcee ._aega .IsRelative (){ctx .X +=_gcee ._bgfcg .Left ;ctx .Y +=_gcee ._bgfcg .Top ;ctx .Width -=_gcee ._bgfcg .Left +_gcee ._bgfcg .Right ;ctx .Height -=_gcee ._bgfcg .Top +_gcee ._bgfcg .Bottom ;_gcee .SetWidth (ctx .Width );if _gcee .Height ()> ctx .Height {_gdag =append (_gdag ,_gfde );_gfde =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bddc :=ctx ;_bddc .Y =ctx .Margins .Top ;_bddc .X =ctx .Margins .Left +_gcee ._bgfcg .Left ;_bddc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gcee ._bgfcg .Bottom ;_bddc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gcee ._bgfcg .Left -_gcee ._bgfcg .Right ;ctx =_bddc ;};}else {if int (_gcee ._bfag )<=0{_gcee .SetWidth (_gcee .getTextWidth ());};ctx .X =_gcee ._gbaa ;ctx .Y =_gcee ._eddbe ;};ctx ,_efgfc :=_fdee (_gfde ,_gcee ,ctx );if _efgfc !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_efgfc );return nil ,ctx ,_efgfc ;};_gdag =append (_gdag ,_gfde );if _gcee ._aega .IsRelative (){ctx .X -=_gcee ._bgfcg .Left ;ctx .Width =_dffa .Width ;return _gdag ,ctx ,nil ;};return _gdag ,_dffa ,nil ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_caab *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _caab ._dfdb [0],_caab ._dfdb [1]};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_beabd *Invoice )SetNoteHeadingStyle (style TextStyle ){_beabd ._ggf =style };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_acec *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_acec .Text },nil ;};var _gcbga []string ;var _cbca []rune ;var _ceaa float64 ;var _afgf []float64 ;_bcde :=_acec .Style ;for _ ,_gbcf :=range _acec .Text {if _gbcf =='\u000A'{_gcbga =append (_gcbga ,_bd .TrimRightFunc (string (_cbca ),_ga .IsSpace )+string (_gbcf ));_cbca =nil ;_ceaa =0;_afgf =nil ;continue ;};_adecb :=_gbcf ==' ';_aead ,_cfeaf :=_bcde .Font .GetRuneMetrics (_gbcf );if !_cfeaf {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_gbcf ,_gbcf ,_bcde .Font .BaseFont (),_bcde .Font .Subtype ());_gd .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bcde .Font );_gd .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bcde .Font .Encoder ());return nil ,_c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_egfaad :=_bcde .FontSize *_aead .Wx ;_eead :=_egfaad ;if !_adecb {_eead =_egfaad +_bcde .CharSpacing *1000.0;};if _ceaa +_egfaad > width *1000.0{_adgc :=-1;if !_adecb {for _cabg :=len (_cbca )-1;_cabg >=0;_cabg --{if _cbca [_cabg ]==' '{_adgc =_cabg ;break ;};};};_gddga :=string (_cbca );if _adgc > 0{_gddga =string (_cbca [0:_adgc +1]);_cbca =append (_cbca [_adgc +1:],_gbcf );_afgf =append (_afgf [_adgc +1:],_eead );_ceaa =0;for _ ,_aaad :=range _afgf {_ceaa +=_aaad ;};}else {if _adecb {_cbca =[]rune {};_afgf =[]float64 {};_ceaa =0;}else {_cbca =[]rune {_gbcf };_afgf =[]float64 {_eead };_ceaa =_eead ;};};_gcbga =append (_gcbga ,_bd .TrimRightFunc (_gddga ,_ga .IsSpace ));}else {_cbca =append (_cbca ,_gbcf );_ceaa +=_eead ;_afgf =append (_afgf ,_eead );};};if len (_cbca )> 0{_gcbga =append (_gcbga ,string (_cbca ));};return _gcbga ,nil ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cbe *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _cbe ._cdgc [0],_cbe ._cdgc [1]};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_dagg *Image )SetMargins (left ,right ,top ,bottom float64 ){_dagg ._eabg .Left =left ;_dagg ._eabg .Right =right ;_dagg ._eabg .Top =top ;_dagg ._eabg .Bottom =bottom ;};

// Width returns the Block's width.
func (_bea *Block )Width ()float64 {return _bea ._gc };

// SetInline sets the inline mode of the division.
func (_bec *Division )SetInline (inline bool ){_bec ._gga =inline };

// NewList creates a new list.
func (_cfef *Creator )NewList ()*List {return _ffcg (_cfef .NewTextStyle ())};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_bbgfe *TOCLine )SetLevelOffset (levelOffset float64 ){_bbgfe ._gfgc =levelOffset ;_bbgfe ._cabdd ._gggf .Left =_bbgfe ._abcc +float64 (_bbgfe ._fced -1)*_bbgfe ._gfgc ;};func (_gfacc *Paragraph )getTextWidth ()float64 {_bbca :=0.0;for _ ,_dbdf :=range _gfacc ._aeea {if _dbdf =='\u000A'{continue ;};_cacg ,_abcff :=_gfacc ._ebegd .GetRuneMetrics (_dbdf );if !_abcff {_gd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dbdf ,_dbdf );return -1;};_bbca +=_gfacc ._gadb *_cacg .Wx ;};return _bbca ;};

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_fdeff *Table )EnableRowWrap (enable bool ){_fdeff ._fcea =enable };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_bgcg *Creator )NewPolyBezierCurve (curves []_gf .CubicBezierCurve )*PolyBezierCurve {return _afbcb (curves );};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};func _fcebb (_dgdgf string )*_a .PdfAnnotation {_ecgf :=_a .NewPdfAnnotationLink ();_bed :=_a .NewBorderStyle ();_bed .SetBorderWidth (0);_ecgf .BS =_bed .ToPdfObject ();_afcg :=_a .NewPdfActionURI ();_afcg .URI =_fc .MakeString (_dgdgf );_ecgf .SetAction (_afcg .PdfAction );return _ecgf .PdfAnnotation ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ecbg *TOC )SetLineTitleStyle (style TextStyle ){_ecbg ._bdgb =style };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_dff *Creator )SetForms (form *_a .PdfAcroForm )error {_dff ._dcbf =form ;return nil };func (_aabg *Chapter )headingText ()string {_aac :=_aabg ._gbf ;if _dgd :=_aabg .headingNumber ();_dgd !=""{_aac =_f .Sprintf ("\u0025\u0073\u0020%\u0073",_dgd ,_aac );};return _aac ;};

// Inline returns whether the inline mode of the division is active.
func (_eecg *Division )Inline ()bool {return _eecg ._gga };

// SetFont sets the Paragraph's font.
func (_accc *Paragraph )SetFont (font *_a .PdfFont ){_accc ._ebegd =font };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_adcfc *Table )NewCell ()*TableCell {return _adcfc .newCell (1)};func _decag (_feag *_a .PdfAnnotationLink )*_a .PdfAnnotationLink {if _feag ==nil {return nil ;};_ccggf :=_a .NewPdfAnnotationLink ();_ccggf .BS =_feag .BS ;_ccggf .A =_feag .A ;if _acgd ,_ggag :=_feag .GetAction ();_ggag ==nil &&_acgd !=nil {_ccggf .SetAction (_acgd );};if _cabf ,_egfeb :=_feag .Dest .(*_fc .PdfObjectArray );_egfeb {_ccggf .Dest =_fc .MakeArray (_cabf .Elements ()...);};return _ccggf ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_aga *Image )SetWidth (w float64 ){_aga ._baed =w };

// SetDueDate sets the due date of the invoice.
func (_acef *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_acef ._eebf [1].Value =dueDate ;return _acef ._eebf [0],_acef ._eebf [1];};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_fddb *Image )GetHorizontalAlignment ()HorizontalAlignment {return _fddb ._cfea };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_eegd *Creator )MoveTo (x ,y float64 ){_eegd ._aaa .X =x ;_eegd ._aaa .Y =y };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_gcae *Paragraph )SetMaxLines (maxLines int ){_gcae ._aggf =maxLines ;_gcae .wrapText ()};

// Title returns the title of the invoice.
func (_aacc *Invoice )Title ()string {return _aacc ._abcd };func (_bac *Block )addContentsByString (_fcge string )error {_fdc :=_gg .NewContentStreamParser (_fcge );_fded ,_fdeb :=_fdc .Parse ();if _fdeb !=nil {return _fdeb ;};_bac ._cd .WrapIfNeeded ();_fded .WrapIfNeeded ();*_bac ._cd =append (*_bac ._cd ,*_fded ...);return nil ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_faag *Paragraph )SetTextAlignment (align TextAlignment ){_faag ._dggge =align };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gacc *StyledParagraph )SetTextAlignment (align TextAlignment ){_gacc ._acga =align };

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Height returns Image's document height.
func (_ggaf *Image )Height ()float64 {return _ggaf ._dce };

// SetDate sets the date of the invoice.
func (_bbcc *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_bbcc ._dfdb [1].Value =date ;return _bbcc ._dfdb [0],_bbcc ._dfdb [1];};type rgbColor struct{_ceb ,_aggg ,_dfa float64 };

// NewCell returns a new invoice table cell.
func (_adgf *Invoice )NewCell (value string )*InvoiceCell {return _adgf .newCell (value ,_adgf .NewCellProps ());};

// GeneratePageBlocks implements drawable interface.
func (_edgg *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gfbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cddf :=_edgg ._dde ;_geda :=ctx .PageHeight -_edgg ._efdg ;if _edgg ._bcd !=nil {_gce :=_gf .Rectangle {Opacity :1.0,X :_edgg ._dde ,Y :ctx .PageHeight -_edgg ._efdg -_edgg ._bba ,Height :_edgg ._bba ,Width :_edgg ._fbbf };_gce .FillEnabled =true ;_gce .FillColor =_edgg ._bcd ;_gce .BorderEnabled =false ;_aab ,_ ,_dec :=_gce .Draw ("");if _dec !=nil {return nil ,ctx ,_dec ;};_dec =_gfbb .addContentsByString (string (_aab ));if _dec !=nil {return nil ,ctx ,_dec ;};};_bgge :=_edgg ._abe ;_bbaf :=_edgg ._fdba ;_cdcb :=_edgg ._fdgd ;_bbd :=_edgg ._edea ;_cbfd :=_edgg ._abe ;if _edgg ._aece ==CellBorderStyleDouble {_cbfd +=2*_bgge ;};_dcb :=_edgg ._fdba ;if _edgg ._eefb ==CellBorderStyleDouble {_dcb +=2*_bbaf ;};_fdedb :=_edgg ._fdgd ;if _edgg ._gff ==CellBorderStyleDouble {_fdedb +=2*_cdcb ;};_eaf :=_edgg ._edea ;if _edgg ._edf ==CellBorderStyleDouble {_eaf +=2*_bbd ;};if _edgg ._abe !=0{_faaf :=_cddf ;_bbac :=_geda ;if _edgg ._aece ==CellBorderStyleDouble {_bbac -=_bgge ;_aage :=_gf .BasicLine {};_aage .X1 =_faaf -_cbfd /2;_aage .Y1 =_bbac +2*_bgge ;_aage .X2 =_faaf +_edgg ._fbbf +_cbfd /2;_aage .Y2 =_bbac +2*_bgge ;_aage .LineColor =_edgg ._ac ;_aage .LineWidth =_edgg ._abe ;_aage .LineStyle =_edgg .LineStyle ;_eccf ,_ ,_dad :=_aage .Draw ("");if _dad !=nil {return nil ,ctx ,_dad ;};_dad =_gfbb .addContentsByString (string (_eccf ));if _dad !=nil {return nil ,ctx ,_dad ;};};_edc :=_gf .BasicLine {LineWidth :_edgg ._abe ,Opacity :1.0,LineColor :_edgg ._ac ,X1 :_faaf -_cbfd /2+(_fdedb -_edgg ._fdgd ),Y1 :_bbac ,X2 :_faaf +_edgg ._fbbf +_cbfd /2-(_eaf -_edgg ._edea ),Y2 :_bbac ,LineStyle :_edgg .LineStyle };_edac ,_ ,_ecd :=_edc .Draw ("");if _ecd !=nil {return nil ,ctx ,_ecd ;};_ecd =_gfbb .addContentsByString (string (_edac ));if _ecd !=nil {return nil ,ctx ,_ecd ;};};if _edgg ._fdba !=0{_bcg :=_cddf ;_bbed :=_geda -_edgg ._bba ;if _edgg ._eefb ==CellBorderStyleDouble {_bbed +=_bbaf ;_gffe :=_gf .BasicLine {LineWidth :_edgg ._fdba ,Opacity :1.0,LineColor :_edgg ._dbd ,X1 :_bcg -_dcb /2,Y1 :_bbed -2*_bbaf ,X2 :_bcg +_edgg ._fbbf +_dcb /2,Y2 :_bbed -2*_bbaf ,LineStyle :_edgg .LineStyle };_agg ,_ ,_dcf :=_gffe .Draw ("");if _dcf !=nil {return nil ,ctx ,_dcf ;};_dcf =_gfbb .addContentsByString (string (_agg ));if _dcf !=nil {return nil ,ctx ,_dcf ;};};_eba :=_gf .BasicLine {LineWidth :_edgg ._fdba ,Opacity :1.0,LineColor :_edgg ._dbd ,X1 :_bcg -_dcb /2+(_fdedb -_edgg ._fdgd ),Y1 :_bbed ,X2 :_bcg +_edgg ._fbbf +_dcb /2-(_eaf -_edgg ._edea ),Y2 :_bbed ,LineStyle :_edgg .LineStyle };_gfaa ,_ ,_efb :=_eba .Draw ("");if _efb !=nil {return nil ,ctx ,_efb ;};_efb =_gfbb .addContentsByString (string (_gfaa ));if _efb !=nil {return nil ,ctx ,_efb ;};};if _edgg ._fdgd !=0{_gcfb :=_cddf ;_gfba :=_geda ;if _edgg ._gff ==CellBorderStyleDouble {_gcfb +=_cdcb ;_aca :=_gf .BasicLine {LineWidth :_edgg ._fdgd ,Opacity :1.0,LineColor :_edgg ._aff ,X1 :_gcfb -2*_cdcb ,Y1 :_gfba +_fdedb /2,X2 :_gcfb -2*_cdcb ,Y2 :_gfba -_edgg ._bba -_fdedb /2,LineStyle :_edgg .LineStyle };_ggg ,_ ,_febb :=_aca .Draw ("");if _febb !=nil {return nil ,ctx ,_febb ;};_febb =_gfbb .addContentsByString (string (_ggg ));if _febb !=nil {return nil ,ctx ,_febb ;};};_defg :=_gf .BasicLine {LineWidth :_edgg ._fdgd ,Opacity :1.0,LineColor :_edgg ._aff ,X1 :_gcfb ,Y1 :_gfba +_fdedb /2-(_cbfd -_edgg ._abe ),X2 :_gcfb ,Y2 :_gfba -_edgg ._bba -_fdedb /2+(_dcb -_edgg ._fdba ),LineStyle :_edgg .LineStyle };_dbe ,_ ,_dfe :=_defg .Draw ("");if _dfe !=nil {return nil ,ctx ,_dfe ;};_dfe =_gfbb .addContentsByString (string (_dbe ));if _dfe !=nil {return nil ,ctx ,_dfe ;};};if _edgg ._edea !=0{_agc :=_cddf +_edgg ._fbbf ;_fab :=_geda ;if _edgg ._edf ==CellBorderStyleDouble {_agc -=_bbd ;_deca :=_gf .BasicLine {LineWidth :_edgg ._edea ,Opacity :1.0,LineColor :_edgg ._ddbb ,X1 :_agc +2*_bbd ,Y1 :_fab +_eaf /2,X2 :_agc +2*_bbd ,Y2 :_fab -_edgg ._bba -_eaf /2,LineStyle :_edgg .LineStyle };_aad ,_ ,_bbeb :=_deca .Draw ("");if _bbeb !=nil {return nil ,ctx ,_bbeb ;};_bbeb =_gfbb .addContentsByString (string (_aad ));if _bbeb !=nil {return nil ,ctx ,_bbeb ;};};_fbf :=_gf .BasicLine {LineWidth :_edgg ._edea ,Opacity :1.0,LineColor :_edgg ._ddbb ,X1 :_agc ,Y1 :_fab +_eaf /2-(_cbfd -_edgg ._abe ),X2 :_agc ,Y2 :_fab -_edgg ._bba -_eaf /2+(_dcb -_edgg ._fdba ),LineStyle :_edgg .LineStyle };_eea ,_ ,_bgga :=_fbf .Draw ("");if _bgga !=nil {return nil ,ctx ,_bgga ;};_bgga =_gfbb .addContentsByString (string (_eea ));if _bgga !=nil {return nil ,ctx ,_bgga ;};};return []*Block {_gfbb },ctx ,nil ;};func _cgfac (_bdfe ,_aaccg ,_cfdb float64 )(_fbbeg ,_ccaf ,_gcfge ,_bcfa float64 ){if _cfdb ==0{return 0,0,_bdfe ,_aaccg ;};_cgdg :=_gf .Path {Points :[]_gf .Point {_gf .NewPoint (0,0).Rotate (_cfdb ),_gf .NewPoint (_bdfe ,0).Rotate (_cfdb ),_gf .NewPoint (0,_aaccg ).Rotate (_cfdb ),_gf .NewPoint (_bdfe ,_aaccg ).Rotate (_cfdb )}}.GetBoundingBox ();return _cgdg .X ,_cgdg .Y ,_cgdg .Width ,_cgdg .Height ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_facb *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _dfed (x1 ,y1 ,x2 ,y2 )};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_eda *Block )Draw (d Drawable )error {_bgad :=DrawContext {};_bgad .Width =_eda ._gc ;_bgad .Height =_eda ._bg ;_bgad .PageWidth =_eda ._gc ;_bgad .PageHeight =_eda ._bg ;_bgad .X =0;_bgad .Y =0;_edg ,_ ,_deb :=d .GeneratePageBlocks (_bgad );if _deb !=nil {return _deb ;};if len (_edg )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_efd :=range _edg {if _ade :=_eda .mergeBlocks (_efd );_ade !=nil {return _ade ;};};return nil ;};var PPI float64 =72;

// SetRowHeight sets the height for a specified row.
func (_bddaf *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_bddaf ._cbdb ){return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bddaf ._cbdb [row -1]=h ;return nil ;};

// Width returns Image's document width.
func (_bbc *Image )Width ()float64 {return _bbc ._baed };

// DrawWithContext draws the Block using the specified drawing context.
func (_gge *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_fac ,_ ,_fb :=d .GeneratePageBlocks (ctx );if _fb !=nil {return _fb ;};if len (_fac )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_eef :=range _fac {if _bafd :=_gge .mergeBlocks (_eef );_bafd !=nil {return _bafd ;};};return nil ;};func (_gggaf *TOCLine )prepareParagraph (_cbge *StyledParagraph ,_acbg DrawContext ){_aeec :=_gggaf .Title .Text ;if _gggaf .Number .Text !=""{_aeec ="\u0020"+_aeec ;};_aeec +="\u0020";_abcg :=_gggaf .Page .Text ;if _abcg !=""{_abcg ="\u0020"+_abcg ;};_cbge ._cebe =[]*TextChunk {{Text :_gggaf .Number .Text ,Style :_gggaf .Number .Style ,_gfda :_gggaf .getLineLink ()},{Text :_aeec ,Style :_gggaf .Title .Style ,_gfda :_gggaf .getLineLink ()},{Text :_abcg ,Style :_gggaf .Page .Style ,_gfda :_gggaf .getLineLink ()}};_cbge .wrapText ();_bfdbb :=len (_cbge ._aaccf );if _bfdbb ==0{return ;};_dada :=_acbg .Width *1000-_cbge .getTextLineWidth (_cbge ._aaccf [_bfdbb -1]);_geef :=_cbge .getTextLineWidth ([]*TextChunk {&_gggaf .Separator });_cggdd :=int (_dada /_geef );_eeeda :=_bd .Repeat (_gggaf .Separator .Text ,_cggdd );_caea :=_gggaf .Separator .Style ;_aeebd :=_cbge .Insert (2,_eeeda );_aeebd .Style =_caea ;_aeebd ._gfda =_gggaf .getLineLink ();_dada =_dada -float64 (_cggdd )*_geef ;if _dada > 500{_dbdbg ,_effca :=_caea .Font .GetRuneMetrics (' ');if _effca &&_dada > _dbdbg .Wx {_ffaab :=int (_dada /_dbdbg .Wx );if _ffaab > 0{_dgcd :=_caea ;_dgcd .FontSize =1;_aeebd =_cbge .Insert (2,_bd .Repeat ("\u0020",_ffaab ));_aeebd .Style =_dgcd ;_aeebd ._gfda =_gggaf .getLineLink ();};};};};

// AddTotalLine adds a new line in the invoice totals table.
func (_fgbf *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_gfae :=&InvoiceCell {_fgbf ._gaaa ,desc };_gddea :=&InvoiceCell {_fgbf ._gaaa ,value };_fgbf ._bbbe =append (_fgbf ._bbbe ,[2]*InvoiceCell {_gfae ,_gddea });return _gfae ,_gddea ;};func _bae (_dfc ,_eag *_a .PdfPageResources )error {_fdf ,_ :=_dfc .GetColorspaces ();if _fdf !=nil &&len (_fdf .Colorspaces )> 0{for _aeg ,_fgcb :=range _fdf .Colorspaces {_fgeg :=*_fc .MakeName (_aeg );if _eag .HasColorspaceByName (_fgeg ){continue ;};_fgcg :=_eag .SetColorspaceByName (_fgeg ,_fgcb );if _fgcg !=nil {return _fgcg ;};};};return nil ;};

// Add adds a new line with the default style to the table of contents.
func (_fgcdd *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_fcfg :=_fgcdd .AddLine (_dgffe (TextChunk {Text :number ,Style :_fgcdd ._dcaeb },TextChunk {Text :title ,Style :_fgcdd ._bdgb },TextChunk {Text :page ,Style :_fgcdd ._fdff },level ,_fgcdd ._acba ));if _fcfg ==nil {return nil ;};_bfce :=&_fgcdd ._gfede ;_fcfg .SetMargins (_bfce .Left ,_bfce .Right ,_bfce .Top ,_bfce .Bottom );_fcfg .SetLevelOffset (_fgcdd ._eebg );_fcfg .Separator .Text =_fgcdd ._debda ;_fcfg .Separator .Style =_fgcdd ._egada ;return _fcfg ;};func _ffebg (_efbd string ,_gcced ,_fdfabd TextStyle )*TOC {_adfba :=_fdfabd ;_adfba .FontSize =14;_face :=_fdege (_adfba );_face .SetEnableWrap (true );_face .SetTextAlignment (TextAlignmentLeft );_face .SetMargins (0,0,0,5);_geaa :=_face .Append (_efbd );_geaa .Style =_adfba ;return &TOC {_ccaa :_face ,_bfbf :[]*TOCLine {},_dcaeb :_gcced ,_bdgb :_gcced ,_egada :_gcced ,_fdff :_gcced ,_debda :"\u002e",_eebg :10,_gfede :Margins {0,0,2,2},_bfdfg :PositionRelative ,_acba :_gcced ,_faef :true };};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_bdef *StyledParagraph )Height ()float64 {_bdef .wrapText ();var _cgcd float64 ;for _ ,_efcf :=range _bdef ._aaccf {var _cbda float64 ;for _ ,_beec :=range _efcf {_cgcab :=_bdef ._dbdfb *_beec .Style .FontSize ;if _cgcab > _cbda {_cbda =_cgcab ;};};_cgcd +=_cbda ;};return _cgcd ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_bbec *StyledParagraph )SetEnableWrap (enableWrap bool ){_bbec ._bgeg =enableWrap ;_bbec ._cccd =false ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_baca float64 ;_aecea float64 ;_acbc float64 ;_dfdbc float64 ;_bdecg *_a .PdfColorDeviceRGB ;_dbdb float64 ;_cefa *_a .PdfColorDeviceRGB ;_gecfd float64 ;_dede float64 ;};

// SetFillColor sets the fill color.
func (_fgbc *Ellipse )SetFillColor (col Color ){_fgbc ._bacb =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_ggae *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_abcb :=NewTextChunk (text ,_ggae ._baba );_abcb ._gfda =_fcebb (url );return _ggae .appendChunk (_abcb );};func (_gcda *Invoice )drawInformation ()*Table {_baebb :=_gagg (2);_ffca :=append ([][2]*InvoiceCell {_gcda ._cdgc ,_gcda ._dfdb ,_gcda ._eebf },_gcda ._aafaa ...);for _ ,_aggga :=range _ffca {_cag ,_gabf :=_aggga [0],_aggga [1];if _gabf .Value ==""{continue ;};_ecdd :=_baebb .NewCell ();_ecdd .SetBackgroundColor (_cag .BackgroundColor );_gcda .setCellBorder (_ecdd ,_cag );_gba :=_fdege (_cag .TextStyle );_gba .Append (_cag .Value );_gba .SetMargins (0,0,2,1);_ecdd .SetContent (_gba );_ecdd =_baebb .NewCell ();_ecdd .SetBackgroundColor (_gabf .BackgroundColor );_gcda .setCellBorder (_ecdd ,_gabf );_gba =_fdege (_gabf .TextStyle );_gba .Append (_gabf .Value );_gba .SetMargins (0,0,2,1);_ecdd .SetContent (_gba );};return _baebb ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetBorderColor sets the border color.
func (_aee *Ellipse )SetBorderColor (col Color ){_aee ._aggd =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_ded *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_ded ._cfea =alignment };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_ccbc *Image )ScaleToHeight (h float64 ){_ccff :=_ccbc ._baed /_ccbc ._dce ;_ccbc ._dce =h ;_ccbc ._baed =h *_ccff ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_abed *Line )SetColor (col Color ){_abed ._feegg =_a .NewPdfColorDeviceRGB (col .ToRGB ())};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_gdd *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gdd ._de .Left ,_gdd ._de .Right ,_gdd ._de .Top ,_gdd ._de .Bottom ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_agddc *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dafc :=_agddc ;if _agddc ._fcea {_dafc =_agddc .clone ();};return _gggce (_dafc ,ctx );};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_bega *Table )MultiColCell (colspan int )*TableCell {return _bega .newCell (colspan )};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_cf *Block )SetPos (x ,y float64 ){_cf ._dg =PositionAbsolute ;_cf ._df =x ;_cf ._ce =y };

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_gfec *Rectangle )GetCoords ()(float64 ,float64 ){return _gfec ._baca ,_gfec ._aecea };

// LevelOffset returns the amount of space an indentation level occupies.
func (_ffgd *TOCLine )LevelOffset ()float64 {return _ffgd ._gfgc };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);func (_fgc *Block )translate (_ag ,_gfe float64 ){_dgf :=_gg .NewContentCreator ().Translate (_ag ,-_gfe ).Operations ();*_fgc ._cd =append (*_dgf ,*_fgc ._cd ...);_fgc ._cd .WrapIfNeeded ();};

// SetMargins sets the Paragraph's margins.
func (_cgdf *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_cgdf ._bgfcg .Left =left ;_cgdf ._bgfcg .Right =right ;_cgdf ._bgfcg .Top =top ;_cgdf ._bgfcg .Bottom =bottom ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_fef *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _fef ._efed ==nil {if _bgca :=_fef .makeXObject ();_bgca !=nil {return nil ,ctx ,_bgca ;};};var _bdb []*Block ;_gabe :=ctx ;_ebc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fef ._dbdg .IsRelative (){ctx .X +=_fef ._eabg .Left ;ctx .Y +=_fef ._eabg .Top ;ctx .Width -=_fef ._eabg .Left +_fef ._eabg .Right ;ctx .Height -=_fef ._eabg .Top +_fef ._eabg .Bottom ;if _fef ._dce > ctx .Height {_bdb =append (_bdb ,_ebc );_ebc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dcbfa :=ctx ;_dcbfa .Y =ctx .Margins .Top +_fef ._eabg .Top ;_dcbfa .X =ctx .Margins .Left +_fef ._eabg .Left ;_dcbfa .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fef ._eabg .Top -_fef ._eabg .Bottom ;_dcbfa .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fef ._eabg .Left -_fef ._eabg .Right ;ctx =_dcbfa ;_gabe .X =ctx .Margins .Left ;_gabe .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_fef ._afge ;ctx .Y =_fef ._ggbb ;};ctx ,_daggb :=_fega (_ebc ,_fef ,ctx );if _daggb !=nil {return nil ,ctx ,_daggb ;};_bdb =append (_bdb ,_ebc );if _fef ._dbdg .IsAbsolute (){ctx =_gabe ;}else {ctx .X =_gabe .X ;ctx .Y +=_fef ._eabg .Bottom ;ctx .Width =_gabe .Width ;};return _bdb ,ctx ,nil ;};func (_dabdg *Table )wrapRow (_dgdcb int ,_fdae DrawContext ,_efecb float64 )(bool ,error ){if !_dabdg ._fcea {return false ,nil ;};var (_eegbd =_dabdg ._adef [_dgdcb ];_dddg =-1;_gfbe []*TableCell ;_ccffc float64 ;_eccec bool ;_gbac =make ([]float64 ,0,len (_dabdg ._bdfba )););_ggaec :=func (_ddcf *TableCell ,_ggfg VectorDrawable ,_fcgda bool )*TableCell {_gfegf :=*_ddcf ;_gfegf ._abgfd =_ggfg ;if _fcgda {_gfegf ._dbgd ++;};return &_gfegf ;};_acfc :=func (_aecge int ,_dadff VectorDrawable ){var _gefeg float64 =-1;if _dadff ==nil {if _adfa :=_gbac [_aecge -_dgdcb ];_adfa > _fdae .Height {_dadff =_dabdg ._adef [_aecge ]._abgfd ;_dabdg ._adef [_aecge ]._abgfd =nil ;_gbac [_aecge -_dgdcb ]=0;_gefeg =_adfa ;};};_dffc :=_ggaec (_dabdg ._adef [_aecge ],_dadff ,true );_gfbe =append (_gfbe ,_dffc );if _gefeg < 0{_gefeg =_dffc .height (_fdae .Width );};if _gefeg > _ccffc {_ccffc =_gefeg ;};};for _cgda :=_dgdcb ;_cgda < len (_dabdg ._adef );_cgda ++{_dgcg :=_dabdg ._adef [_cgda ];if _eegbd ._dbgd !=_dgcg ._dbgd {_dddg =_cgda ;break ;};_fdae .Width =_dgcg .width (_dabdg ._bdfba ,_efecb );var _aeff VectorDrawable ;switch _dagc :=_dgcg ._abgfd .(type ){case *StyledParagraph :if _gbbe :=_dgcg .height (_fdae .Width );_gbbe > _fdae .Height {_fgfb :=_fdae ;_fgfb .Height =_bb .Floor (_fdae .Height -_dagc ._gggf .Top -_dagc ._gggf .Bottom -0.5*_dagc .getTextHeight ());_cdbce ,_fgbfd ,_dgeb :=_dagc .split (_fgfb );if _dgeb !=nil {return false ,_dgeb ;};if _cdbce !=nil &&_fgbfd !=nil {_dagc =_cdbce ;_dgcg =_ggaec (_dgcg ,_cdbce ,false );_dabdg ._adef [_cgda ]=_dgcg ;_aeff =_fgbfd ;_eccec =true ;};};};_gbac =append (_gbac ,_dgcg .height (_fdae .Width ));if _eccec {if _gfbe ==nil {_gfbe =make ([]*TableCell ,0,len (_dabdg ._bdfba ));for _cfeg :=_dgdcb ;_cfeg < _cgda ;_cfeg ++{_acfc (_cfeg ,nil );};};_acfc (_cgda ,_aeff );};};var _gaef float64 ;for _ ,_efecd :=range _gbac {if _efecd > _gaef {_gaef =_efecd ;};};if _eccec &&_gaef < _fdae .Height {if _dddg < 0{_dddg =len (_dabdg ._adef );};_cdcge :=_dabdg ._adef [_dddg -1]._dbgd +_dabdg ._adef [_dddg -1]._baccg -1;for _fbaaf :=_dddg ;_fbaaf < len (_dabdg ._adef );_fbaaf ++{_dabdg ._adef [_fbaaf ]._dbgd ++;};_dabdg ._adef =append (_dabdg ._adef [:_dddg ],append (_gfbe ,_dabdg ._adef [_dddg :]...)...);_dabdg ._cbdb =append (_dabdg ._cbdb [:_cdcge ],append ([]float64 {_ccffc },_dabdg ._cbdb [_cdcge :]...)...);_dabdg ._cbdb [_eegbd ._dbgd +_eegbd ._baccg -2]=_gaef ;};return _eccec ,nil ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_deaa []*listItem ;_eacf Margins ;_aeae TextChunk ;_dfbcd float64 ;_faga bool ;_abdc Positioning ;_gadf TextStyle ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_ece *Block )SetMargins (left ,right ,top ,bottom float64 ){_ece ._de .Left =left ;_ece ._de .Right =right ;_ece ._de .Top =top ;_ece ._de .Bottom =bottom ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eae *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _eae ._dcdf [0],_eae ._dcdf [1]};func _bafg (_eegb ,_bfac ,_faf ,_gcc ,_eeca ,_cddb float64 )*Curve {_fbg :=&Curve {};_fbg ._dcfa =_eegb ;_fbg ._agga =_bfac ;_fbg ._baeb =_faf ;_fbg ._bcfd =_gcc ;_fbg ._eddb =_eeca ;_fbg ._bdcc =_cddb ;_fbg ._aabd =_a .NewPdfColorDeviceRGB (0,0,0);_fbg ._gdde =1.0;return _fbg ;};

// SetPos sets absolute positioning with specified coordinates.
func (_abca *Paragraph )SetPos (x ,y float64 ){_abca ._aega =PositionAbsolute ;_abca ._gbaa =x ;_abca ._eddbe =y ;};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_gbbf *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_afff :=_gf .Line {LineWidth :_gbbf ._ccgba ,Opacity :1.0,LineColor :_gbbf ._feegg ,LineEndingStyle1 :_gf .LineEndingStyleNone ,LineEndingStyle2 :_gf .LineEndingStyleNone ,X1 :_gbbf ._dfeb ,Y1 :ctx .PageHeight -_gbbf ._aabe ,X2 :_gbbf ._ffcc ,Y2 :ctx .PageHeight -_gbbf ._aafdf };_cgfb ,_ ,_fgcfc :=_afff .Draw ("");if _fgcfc !=nil {return nil ,ctx ,_fgcfc ;};_fgcfc =_efeg .addContentsByString (string (_cgfb ));if _fgcfc !=nil {return nil ,ctx ,_fgcfc ;};return []*Block {_efeg },ctx ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fefae *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_geac :=ctx ;_agef ,ctx ,_bdecd :=_fefae ._ccaa .GeneratePageBlocks (ctx );if _bdecd !=nil {return _agef ,ctx ,_bdecd ;};for _ ,_bbfgb :=range _fefae ._bfbf {_adcb :=_bbfgb ._becg ;if !_fefae ._faef {_bbfgb ._becg =0;};_fcbf ,_gggg ,_ebbgb :=_bbfgb .GeneratePageBlocks (ctx );_bbfgb ._becg =_adcb ;if _ebbgb !=nil {return _agef ,ctx ,_ebbgb ;};if len (_fcbf )< 1{continue ;};_agef [len (_agef )-1].mergeBlocks (_fcbf [0]);_agef =append (_agef ,_fcbf [1:]...);ctx =_gggg ;};if _fefae ._bfdfg .IsRelative (){ctx .X =_geac .X ;};if _fefae ._bfdfg .IsAbsolute (){return _agef ,_geac ,nil ;};return _agef ,ctx ,nil ;};func (_ageg *Invoice )generateInformationBlocks (_ggef DrawContext )([]*Block ,DrawContext ,error ){_fgdaf :=_fdege (_ageg ._eeec );_fgdaf .SetMargins (0,0,0,20);_ffdd :=_ageg .drawAddress (_ageg ._fcbg );_ffdd =append (_ffdd ,_fgdaf );_ffdd =append (_ffdd ,_ageg .drawAddress (_ageg ._ebgf )...);_fagbb :=_egge ();for _ ,_accg :=range _ffdd {_fagbb .Add (_accg );};_fdfa :=_ageg .drawInformation ();_dbge :=_gagg (2);_dbge .SetMargins (0,0,25,0);_bfgfg :=_dbge .NewCell ();_bfgfg .SetIndent (0);_bfgfg .SetContent (_fagbb );_bfgfg =_dbge .NewCell ();_bfgfg .SetContent (_fdfa );return _dbge .GeneratePageBlocks (_ggef );};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_bgdf *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _dgffe (number ,title ,page ,level ,style );};

// NewFilledCurve returns a instance of filled curve.
func (_bdfcb *Creator )NewFilledCurve ()*FilledCurve {return _acea ()};

// SetFillColor sets the fill color.
func (_bdba *PolyBezierCurve )SetFillColor (color Color ){_bdba ._agde .FillColor =_a .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetText sets the text content of the Paragraph.
func (_bbbea *Paragraph )SetText (text string ){_bbbea ._aeea =text };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_aebc *Paragraph )SetWidth (width float64 ){_aebc ._bfag =width ;_aebc .wrapText ()};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_fafc []VectorDrawable ;_ffgf Positioning ;_bfgc Margins ;_gga bool ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_caee *Invoice )SetAddressStyle (style TextStyle ){_caee ._fgaeb =style };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_aaga *Creator )Finalize ()error {if _aaga ._ecb {return nil ;};_abd :=len (_aaga ._gcbc );_fcgd :=0;if _aaga ._bbgf !=nil {_fcgd ++;};if _aaga .AddTOC {_aaga .initContext ();_aaga ._aaa .Page =_fcgd +1;if _aaga ._ebbcd !=nil {if _ccea :=_aaga ._ebbcd (_aaga ._ebbg );_ccea !=nil {return _ccea ;};};_abcf ,_ ,_afd :=_aaga ._ebbg .GeneratePageBlocks (_aaga ._aaa );if _afd !=nil {_gd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_afd );return _afd ;};_fcgd +=len (_abcf );_eafd :=_aaga ._ebbg .Lines ();for _ ,_dfcf :=range _eafd {_bfbe ,_dca :=_g .Atoi (_dfcf .Page .Text );if _dca !=nil {continue ;};_dfcf .Page .Text =_g .Itoa (_bfbe +_fcgd );};};_eed :=false ;if _aaga ._bbgf !=nil {_abd ++;_egf :=_aaga .newPage ();_aaga ._gcbc =append ([]*_a .PdfPage {_egf },_aaga ._gcbc ...);_aaga .setActivePage (_egf );_cga :=FrontpageFunctionArgs {PageNum :1,TotalPages :_abd };_aaga ._bbgf (_cga );_eed =true ;};if _aaga .AddTOC {_aaga .initContext ();if _aaga ._ebbcd !=nil {if _adec :=_aaga ._ebbcd (_aaga ._ebbg );_adec !=nil {_gd .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_adec );return _adec ;};};_geb :=_aaga ._ebbg .Lines ();for _ ,_gbfc :=range _geb {_gbfc ._becg +=int64 (_fcgd );};var _gfeg []*_a .PdfPage ;_caef ,_ ,_ :=_aaga ._ebbg .GeneratePageBlocks (_aaga ._aaa );for _ ,_cff :=range _caef {_cff .SetPos (0,0);_abd ++;_aeba :=_aaga .newPage ();_gfeg =append (_gfeg ,_aeba );_aaga .setActivePage (_aeba );_aaga .Draw (_cff );};if _eed {_feea :=_aaga ._gcbc [0];_daa :=_aaga ._gcbc [1:];_aaga ._gcbc =append ([]*_a .PdfPage {_feea },_gfeg ...);_aaga ._gcbc =append (_aaga ._gcbc ,_daa ...);}else {_aaga ._gcbc =append (_gfeg ,_aaga ._gcbc ...);};};if _aaga ._gbbd !=nil &&_aaga .AddOutlines {var _bfc func (_fgda *_a .OutlineItem );_bfc =func (_effe *_a .OutlineItem ){_effe .Dest .Page +=int64 (_fcgd );if _dbc :=int (_effe .Dest .Page );_dbc >=0&&_dbc < len (_aaga ._gcbc ){_effe .Dest .PageObj =_aaga ._gcbc [_dbc ].GetPageAsIndirectObject ();}else {_gd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_dbc );};_effe .Dest .Y =_aaga ._aba -_effe .Dest .Y ;_fgaa :=_effe .Items ();for _ ,_afbc :=range _fgaa {_bfc (_afbc );};};_fedf :=_aaga ._gbbd .Items ();for _ ,_ebeddf :=range _fedf {_bfc (_ebeddf );};if _aaga .AddTOC {var _effc int ;if _eed {_effc =1;};_gcbg :=_a .NewOutlineDest (int64 (_effc ),0,_aaga ._aba );if _effc >=0&&_effc < len (_aaga ._gcbc ){_gcbg .PageObj =_aaga ._gcbc [_effc ].GetPageAsIndirectObject ();}else {_gd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_effc );};_aaga ._gbbd .Insert (0,_a .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_gcbg ));};};for _ffgb ,_agdc :=range _aaga ._gcbc {_aaga .setActivePage (_agdc );if _aaga ._ceg !=nil {_bceg :=NewBlock (_aaga ._dbag ,_aaga ._geg .Top );_eaa :=HeaderFunctionArgs {PageNum :_ffgb +1,TotalPages :_abd };_aaga ._ceg (_bceg ,_eaa );_bceg .SetPos (0,0);if _gfbf :=_aaga .Draw (_bceg );_gfbf !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_gfbf );return _gfbf ;};};if _aaga ._cefgb !=nil {_cced :=NewBlock (_aaga ._dbag ,_aaga ._geg .Bottom );_eeb :=FooterFunctionArgs {PageNum :_ffgb +1,TotalPages :_abd };_aaga ._cefgb (_cced ,_eeb );_cced .SetPos (0,_aaga ._aba -_cced ._bg );if _dfd :=_aaga .Draw (_cced );_dfd !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_dfd );return _dfd ;};};_bfa ,_feg :=_aaga ._dbea [_agdc ];if !_feg {continue ;};if _febd ,_egbac :=_aaga ._gcfg [_agdc ];_egbac {_bfa .transform (_febd );};if _bfde :=_bfa .drawToPage (_agdc );_bfde !=nil {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_ffgb +1,_bfde );return _bfde ;};};_aaga ._ecb =true ;return nil ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_fbdd *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggdg :=ctx ;var _fgead []*Block ;_ffcgd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fbdd ._efdbe .IsRelative (){ctx .X +=_fbdd ._gggf .Left ;ctx .Y +=_fbdd ._gggf .Top ;ctx .Width -=_fbdd ._gggf .Left +_fbdd ._gggf .Right ;ctx .Height -=_fbdd ._gggf .Top +_fbdd ._gggf .Bottom ;_fbdd .SetWidth (ctx .Width );}else {if int (_fbdd ._eeeac )<=0{_fbdd .SetWidth (_fbdd .getTextWidth ());};ctx .X =_fbdd ._gcbf ;ctx .Y =_fbdd ._dgfc ;};if _fbdd ._ggdd !=nil {_fbdd ._ggdd (_fbdd ,ctx );};if _baac :=_fbdd .wrapText ();_baac !=nil {return nil ,ctx ,_baac ;};_bfae :=_fbdd ._aaccf ;for {_gafc ,_dgfe ,_ebdcf :=_gged (_ffcgd ,_fbdd ,_bfae ,ctx );if _ebdcf !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebdcf );return nil ,ctx ,_ebdcf ;};ctx =_gafc ;_fgead =append (_fgead ,_ffcgd );if _bfae =_dgfe ;len (_dgfe )==0{break ;};_ffcgd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gafc =ctx ;_gafc .Y =ctx .Margins .Top ;_gafc .X =ctx .Margins .Left +_fbdd ._gggf .Left ;_gafc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fbdd ._gggf .Bottom ;_gafc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fbdd ._gggf .Left -_fbdd ._gggf .Right ;ctx =_gafc ;};if _fbdd ._efdbe .IsRelative (){ctx .X -=_fbdd ._gggf .Left ;ctx .Width =_ggdg .Width ;return _fgead ,ctx ,nil ;};return _fgead ,_ggdg ,nil ;};func _fdee (_gaba *Block ,_adcge *Paragraph ,_dega DrawContext )(DrawContext ,error ){_fdad :=1;_fabc :=_fc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_g .Itoa (_fdad ));for _gaba ._ef .HasFontByName (_fabc ){_fdad ++;_fabc =_fc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_g .Itoa (_fdad ));};_fcbgd :=_gaba ._ef .SetFontByName (_fabc ,_adcge ._ebegd .ToPdfObject ());if _fcbgd !=nil {return _dega ,_fcbgd ;};_adcge .wrapText ();_eeba :=_gg .NewContentCreator ();_eeba .Add_q ();_eefg :=_dega .PageHeight -_dega .Y -_adcge ._gadb *_adcge ._dcfaad ;_eeba .Translate (_dega .X ,_eefg );if _adcge ._eaccb !=0{_eeba .RotateDeg (_adcge ._eaccb );};_eeba .Add_BT ().Add_rg (_adcge ._aegd .R (),_adcge ._aegd .G (),_adcge ._aegd .B ()).Add_Tf (_fabc ,_adcge ._gadb ).Add_TL (_adcge ._gadb *_adcge ._dcfaad );for _bgbg ,_fgg :=range _adcge ._abbb {if _bgbg !=0{_eeba .Add_Tstar ();};_efaf :=[]rune (_fgg );_fgec :=0.0;_eecd :=0;for _acbdd ,_febcg :=range _efaf {if _febcg ==' '{_eecd ++;continue ;};if _febcg =='\u000A'{continue ;};_gdgcg ,_acefg :=_adcge ._ebegd .GetRuneMetrics (_febcg );if !_acefg {_gd .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_acbdd ,_febcg ,_febcg ,_adcge ._ebegd .BaseFont (),_adcge ._ebegd .Subtype ());return _dega ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_fgec +=_adcge ._gadb *_gdgcg .Wx ;};var _bbff []_fc .PdfObject ;_bdde ,_beafeb :=_adcge ._ebegd .GetRuneMetrics (' ');if !_beafeb {return _dega ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_cgeg :=_bdde .Wx ;switch _adcge ._dggge {case TextAlignmentJustify :if _eecd > 0&&_bgbg < len (_adcge ._abbb )-1{_cgeg =(_adcge ._bfag *1000.0-_fgec )/float64 (_eecd )/_adcge ._gadb ;};case TextAlignmentCenter :_ggeg :=_fgec +float64 (_eecd )*_cgeg *_adcge ._gadb ;_edgf :=(_adcge ._bfag *1000.0-_ggeg )/2/_adcge ._gadb ;_bbff =append (_bbff ,_fc .MakeFloat (-_edgf ));case TextAlignmentRight :_bafgb :=_fgec +float64 (_eecd )*_cgeg *_adcge ._gadb ;_fffc :=(_adcge ._bfag *1000.0-_bafgb )/_adcge ._gadb ;_bbff =append (_bbff ,_fc .MakeFloat (-_fffc ));};_bfdf :=_adcge ._ebegd .Encoder ();var _dcae []byte ;for _ ,_egbc :=range _efaf {if _egbc =='\u000A'{continue ;};if _egbc ==' '{if len (_dcae )> 0{_bbff =append (_bbff ,_fc .MakeStringFromBytes (_dcae ));_dcae =nil ;};_bbff =append (_bbff ,_fc .MakeFloat (-_cgeg ));}else {if _ ,_egdg :=_bfdf .RuneToCharcode (_egbc );!_egdg {_gd .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_egbc ,_egbc );continue ;};_dcae =append (_dcae ,_bfdf .Encode (string (_egbc ))...);};};if len (_dcae )> 0{_bbff =append (_bbff ,_fc .MakeStringFromBytes (_dcae ));};_eeba .Add_TJ (_bbff ...);};_eeba .Add_ET ();_eeba .Add_Q ();_gdbcb :=_eeba .Operations ();_gdbcb .WrapIfNeeded ();_gaba .addContents (_gdbcb );if _adcge ._aega .IsRelative (){_fabg :=_adcge .Height ()+_adcge ._bgfcg .Bottom ;_dega .Y +=_fabg ;_dega .Height -=_fabg ;if _dega .Inline {_dega .X +=_adcge .Width ()+_adcge ._bgfcg .Right ;};};return _dega ,nil ;};

// CurRow returns the currently active cell's row number.
func (_ddbbd *Table )CurRow ()int {_eabec :=(_ddbbd ._adab -1)/_ddbbd ._ddgf +1;return _eabec };

// SetFillColor sets the fill color for the path.
func (_bdae *FilledCurve )SetFillColor (color Color ){_bdae ._ffgbb =_a .NewPdfColorDeviceRGB (color .ToRGB ());};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_befd *StyledParagraph )SetWidth (width float64 ){_befd ._eeeac =width ;_befd .wrapText ()};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_edeb *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_dgb *_a .PdfWriter )error ){_edeb ._bbad =pdfWriterAccessFunc ;};