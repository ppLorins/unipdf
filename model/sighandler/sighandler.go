//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_ga "bytes";_e "crypto";_ba "crypto/rand";_ge "crypto/rsa";_ce "crypto/x509";_c "crypto/x509/pkix";_dd "encoding/asn1";_bc "errors";_b "fmt";_cg "github.com/pplorins/pkcs7";_fd "github.com/pplorins/timestamp";_gf "github.com/pplorins/unipdf/v3/core";_da "github.com/pplorins/unipdf/v3/model";_cee "github.com/pplorins/unipdf/v3/model/sigutil";_f "hash";_d "time";);func _gfge (_dcc _ce .SignatureAlgorithm )(_e .Hash ,bool ){var _aff _e .Hash ;switch _dcc {case _ce .SHA1WithRSA :_aff =_e .SHA1 ;case _ce .SHA256WithRSA :_aff =_e .SHA256 ;case _ce .SHA384WithRSA :_aff =_e .SHA384 ;case _ce .SHA512WithRSA :_aff =_e .SHA512 ;default:return _e .SHA1 ,false ;};return _aff ,true ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_beb *adobeX509RSASHA1 )IsApplicable (sig *_da .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// InitSignature initialises the PdfSignature.
func (_bca *adobeX509RSASHA1 )InitSignature (sig *_da .PdfSignature )error {if _bca ._bcg ==nil {return _bc .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _bca ._baa ==nil &&_bca ._aeb ==nil {return _bc .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_geg :=*_bca ;sig .Handler =&_geg ;sig .Filter =_gf .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_gf .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_gf .MakeString (string (_geg ._bcg .Raw ));sig .Reference =nil ;_af ,_cce :=_geg .NewDigest (sig );if _cce !=nil {return _cce ;};_af .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _geg .sign (sig ,_af ,_bca ._eb );};func (_gge *adobeX509RSASHA1 )getCertificate (_gd *_da .PdfSignature )(*_ce .Certificate ,error ){if _gge ._bcg !=nil {return _gge ._bcg ,nil ;};_aeg ,_cd :=_gd .GetCerts ();if _cd !=nil {return nil ,_cd ;};return _aeg [0],nil ;};func (_dad *docTimeStamp )getCertificate (_cgc *_da .PdfSignature )(*_ce .Certificate ,error ){_fbg ,_fdd :=_cgc .GetCerts ();if _fdd !=nil {return nil ,_fdd ;};return _fbg [0],nil ;};type adobeX509RSASHA1 struct{_baa *_ge .PrivateKey ;_bcg *_ce .Certificate ;_aeb SignFunc ;_eb bool ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_da .SignatureHandler ,error ){return &adobePKCS7Detached {_bac :true ,_ddg :signatureLen },nil ;};

// Validate validates PdfSignature.
func (_ac *adobeX509RSASHA1 )Validate (sig *_da .PdfSignature ,digest _da .Hasher )(_da .SignatureValidationResult ,error ){_cbf ,_fb :=_ac .getCertificate (sig );if _fb !=nil {return _da .SignatureValidationResult {},_fb ;};_ebb :=sig .Contents .Bytes ();var _ccd []byte ;if _ ,_bg :=_dd .Unmarshal (_ebb ,&_ccd );_bg !=nil {return _da .SignatureValidationResult {},_bg ;};_ec ,_aege :=digest .(_f .Hash );if !_aege {return _da .SignatureValidationResult {},_bc .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ecg ,_ :=_gfge (_cbf .SignatureAlgorithm );if _fgc :=_ge .VerifyPKCS1v15 (_cbf .PublicKey .(*_ge .PublicKey ),_ecg ,_ec .Sum (nil ),_ccd );_fgc !=nil {return _da .SignatureValidationResult {},_fgc ;};return _da .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};type adobePKCS7Detached struct{_ea *_ge .PrivateKey ;_fc *_ce .Certificate ;_bac bool ;_ddg int ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bdb *docTimeStamp )Sign (sig *_da .PdfSignature ,digest _da .Hasher )error {_beff ,_ffff :=_cee .NewTimestampRequest (digest .(*_ga .Buffer ),&_fd .RequestOptions {Hash :_bdb ._gb ,Certificates :true });if _ffff !=nil {return _ffff ;};_bafb :=_cee .NewTimestampClient ();_fddc ,_ffff :=_bafb .GetEncodedToken (_bdb ._fbc ,_beff );if _ffff !=nil {return _ffff ;};_de :=len (_fddc );if _bdb ._aad > 0&&_de > _bdb ._aad {return _da .ErrSignNotEnoughSpace ;};if _de > 0{_bdb ._aad =_de +128;};sig .Contents =_gf .MakeHexString (string (_fddc ));return nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _e .Hash ,opts *DocTimeStampOpts )(_da .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_fbc :timestampServerURL ,_gb :hashAlgorithm ,_aad :opts .SignatureSize },nil ;};

// NewDigest creates a new digest.
func (_ab *adobePKCS7Detached )NewDigest (sig *_da .PdfSignature )(_da .Hasher ,error ){return _ga .NewBuffer (nil ),nil ;};

// Validate validates PdfSignature.
func (_gg *adobePKCS7Detached )Validate (sig *_da .PdfSignature ,digest _da .Hasher )(_da .SignatureValidationResult ,error ){_dc :=sig .Contents .Bytes ();_bb ,_bf :=_cg .Parse (_dc );if _bf !=nil {return _da .SignatureValidationResult {},_bf ;};_ag :=digest .(*_ga .Buffer );_bb .Content =_ag .Bytes ();if _bf =_bb .Verify ();_bf !=nil {return _da .SignatureValidationResult {},_bf ;};return _da .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Sign sets the Contents fields.
func (_fab *adobePKCS7Detached )Sign (sig *_da .PdfSignature ,digest _da .Hasher )error {if _fab ._bac {_aa :=_fab ._ddg ;if _aa <=0{_aa =8192;};sig .Contents =_gf .MakeHexString (string (make ([]byte ,_aa )));return nil ;};_aag :=digest .(*_ga .Buffer );_be ,_gfg :=_cg .NewSignedData (_aag .Bytes ());if _gfg !=nil {return _gfg ;};if _ddd :=_be .AddSigner (_fab ._fc ,_fab ._ea ,_cg .SignerInfoConfig {});_ddd !=nil {return _ddd ;};_be .Detach ();_dcd ,_gfg :=_be .Finish ();if _gfg !=nil {return _gfg ;};_ae :=make ([]byte ,8192);copy (_ae ,_dcd );sig .Contents =_gf .MakeHexString (string (_ae ));return nil ;};

// NewDigest creates a new digest.
func (_bde *docTimeStamp )NewDigest (sig *_da .PdfSignature )(_da .Hasher ,error ){return _ga .NewBuffer (nil ),nil ;};type timestampInfo struct{Version int ;Policy _dd .RawValue ;MessageImprint struct{HashAlgorithm _c .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _dd .RawValue ;GeneralizedTime _d .Time ;};

// NewDigest creates a new digest.
func (_bbb *adobeX509RSASHA1 )NewDigest (sig *_da .PdfSignature )(_da .Hasher ,error ){_ff ,_ef :=_bbb .getCertificate (sig );if _ef !=nil {return nil ,_ef ;};_bd ,_ :=_gfge (_ff .SignatureAlgorithm );return _bd .New (),nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ge .PrivateKey ,certificate *_ce .Certificate )(_da .SignatureHandler ,error ){return &adobePKCS7Detached {_fc :certificate ,_ea :privateKey },nil ;};

// InitSignature initialises the PdfSignature.
func (_fa *adobePKCS7Detached )InitSignature (sig *_da .PdfSignature )error {if !_fa ._bac {if _fa ._fc ==nil {return _bc .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _fa ._ea ==nil {return _bc .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_ca :=*_fa ;sig .Handler =&_ca ;sig .Filter =_gf .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_gf .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_gfd ,_cc :=_ca .NewDigest (sig );if _cc !=nil {return _cc ;};_gfd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _ca .Sign (sig ,_gfd );};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_cb *_da .PdfSignature ,_ddc _da .Hasher )([]byte ,error );

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_ce .Certificate ,signFunc SignFunc )(_da .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bcg :certificate ,_aeb :signFunc },nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _e .Hash )(_da .SignatureHandler ,error ){return &docTimeStamp {_fbc :timestampServerURL ,_gb :hashAlgorithm },nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ge .PrivateKey ,certificate *_ce .Certificate )(_da .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bcg :certificate ,_baa :privateKey },nil ;};func _df (_fee _dd .ObjectIdentifier )(_e .Hash ,error ){switch {case _fee .Equal (_cg .OIDDigestAlgorithmSHA1 ),_fee .Equal (_cg .OIDDigestAlgorithmECDSASHA1 ),_fee .Equal (_cg .OIDDigestAlgorithmDSA ),_fee .Equal (_cg .OIDDigestAlgorithmDSASHA1 ),_fee .Equal (_cg .OIDEncryptionAlgorithmRSA ):return _e .SHA1 ,nil ;case _fee .Equal (_cg .OIDDigestAlgorithmSHA256 ),_fee .Equal (_cg .OIDDigestAlgorithmECDSASHA256 ):return _e .SHA256 ,nil ;case _fee .Equal (_cg .OIDDigestAlgorithmSHA384 ),_fee .Equal (_cg .OIDDigestAlgorithmECDSASHA384 ):return _e .SHA384 ,nil ;case _fee .Equal (_cg .OIDDigestAlgorithmSHA512 ),_fee .Equal (_cg .OIDDigestAlgorithmECDSASHA512 ):return _e .SHA512 ,nil ;};return _e .Hash (0),_cg .ErrUnsupportedAlgorithm ;};

// Sign sets the Contents fields for the PdfSignature.
func (_ggc *adobeX509RSASHA1 )Sign (sig *_da .PdfSignature ,digest _da .Hasher )error {var _baf []byte ;var _fea error ;if _ggc ._aeb !=nil {_baf ,_fea =_ggc ._aeb (sig ,digest );if _fea !=nil {return _fea ;};}else {_cge ,_dg :=digest .(_f .Hash );if !_dg {return _bc .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ecb ,_ :=_gfge (_ggc ._bcg .SignatureAlgorithm );_baf ,_fea =_ge .SignPKCS1v15 (_ba .Reader ,_ggc ._baa ,_ecb ,_cge .Sum (nil ));if _fea !=nil {return _fea ;};};_baf ,_fea =_dd .Marshal (_baf );if _fea !=nil {return _fea ;};sig .Contents =_gf .MakeHexString (string (_baf ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ed *docTimeStamp )IsApplicable (sig *_da .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_ce .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_da .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_bcg :certificate ,_aeb :signFunc ,_eb :opts .EstimateSize },nil ;};type docTimeStamp struct{_fbc string ;_gb _e .Hash ;_aad int ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};func (_fe *adobePKCS7Detached )getCertificate (_a *_da .PdfSignature )(*_ce .Certificate ,error ){if _fe ._fc !=nil {return _fe ._fc ,nil ;};_bab ,_fg :=_a .GetCerts ();if _fg !=nil {return nil ,_fg ;};return _bab [0],nil ;};

// Validate validates PdfSignature.
func (_cdd *docTimeStamp )Validate (sig *_da .PdfSignature ,digest _da .Hasher )(_da .SignatureValidationResult ,error ){_bcd :=sig .Contents .Bytes ();_fce ,_fag :=_cg .Parse (_bcd );if _fag !=nil {return _da .SignatureValidationResult {},_fag ;};if _fag =_fce .Verify ();_fag !=nil {return _da .SignatureValidationResult {},_fag ;};var _fff timestampInfo ;_ ,_fag =_dd .Unmarshal (_fce .Content ,&_fff );if _fag !=nil {return _da .SignatureValidationResult {},_fag ;};_aee ,_fag :=_df (_fff .MessageImprint .HashAlgorithm .Algorithm );if _fag !=nil {return _da .SignatureValidationResult {},_fag ;};_fffd :=_aee .New ();_ggf :=digest .(*_ga .Buffer );_fffd .Write (_ggf .Bytes ());_gegd :=_fffd .Sum (nil );_bdd :=_da .SignatureValidationResult {IsSigned :true ,IsVerified :_ga .Equal (_gegd ,_fff .MessageImprint .HashedMessage ),GeneralizedTime :_fff .GeneralizedTime };return _bdd ,nil ;};

// InitSignature initialises the PdfSignature.
func (_fcb *docTimeStamp )InitSignature (sig *_da .PdfSignature )error {_gdc :=*_fcb ;sig .Handler =&_gdc ;sig .Filter =_gf .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_gf .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _fcb ._aad > 0{sig .Contents =_gf .MakeHexString (string (make ([]byte ,_fcb ._aad )));}else {_afad ,_gc :=_fcb .NewDigest (sig );if _gc !=nil {return _gc ;};_afad .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gc =_gdc .Sign (sig ,_afad );_gc !=nil {return _gc ;};_fcb ._aad =_gdc ._aad ;};return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_bef *adobePKCS7Detached )IsApplicable (sig *_da .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};func (_ccb *adobeX509RSASHA1 )sign (_ccg *_da .PdfSignature ,_bfg _da .Hasher ,_afe bool )error {if !_afe {return _ccb .Sign (_ccg ,_bfg );};_ead ,_eg :=_ccb ._bcg .PublicKey .(*_ge .PublicKey );if !_eg {return _b .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_ead );};_db ,_bgc :=_dd .Marshal (make ([]byte ,_ead .Size ()));if _bgc !=nil {return _bgc ;};_ccg .Contents =_gf .MakeHexString (string (_db ));return nil ;};