//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_b "bufio";_ggf "bytes";_e "compress/lzw";_db "compress/zlib";_gg "crypto/md5";_adc "crypto/rand";_dc "encoding/hex";_c "errors";_gf "fmt";_ge "github.com/pplorins/unipdf/v3/common";_aa "github.com/pplorins/unipdf/v3/core/security";_ee "github.com/pplorins/unipdf/v3/core/security/crypt";_fa "github.com/pplorins/unipdf/v3/internal/ccittfax";_dg "github.com/pplorins/unipdf/v3/internal/imageutil";_fe "github.com/pplorins/unipdf/v3/internal/jbig2";_df "github.com/pplorins/unipdf/v3/internal/jbig2/bitmap";_ggd "github.com/pplorins/unipdf/v3/internal/jbig2/decoder";_fab "github.com/pplorins/unipdf/v3/internal/jbig2/document";_ag "github.com/pplorins/unipdf/v3/internal/jbig2/errors";_fgf "github.com/pplorins/unipdf/v3/internal/strutils";_fg "golang.org/x/image/tiff/lzw";_bg "golang.org/x/xerrors";_gb "image";_g "image/color";_caf "image/jpeg";_de "io";_cd "reflect";_d "regexp";_ad "sort";_ca "strconv";_ggg "strings";_ae "sync";_f "time";);

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cbac *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_cbac ._effbe )==0{return nil ;};if len (_cbac ._effbe )==1{return _cbac ._effbe [0].MakeDecodeParams ();};_aaag :=MakeArray ();for _ ,_babb :=range _cbac ._effbe {_bec :=_babb .MakeDecodeParams ();if _bec ==nil {_aaag .Append (MakeNull ());}else {_aaag .Append (_bec );};};return _aaag ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_accag *JBIG2Encoder )Encode ()(_ebg []byte ,_cfca error ){const _adfd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _accag ._cacb ==nil {return nil ,_ag .Errorf (_adfd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_accag ._cacb .FullHeaders =_accag .DefaultPageSettings .FileMode ;_ebg ,_cfca =_accag ._cacb .Encode ();if _cfca !=nil {return nil ,_ag .Wrap (_cfca ,_adfd ,"");};return _ebg ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cfc *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_ceda *PdfParser )parseObject ()(PdfObject ,error ){_ge .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_ceda .skipSpaces ();for {_bcce ,_eafa :=_ceda ._aeff .Peek (2);if _eafa !=nil {if _eafa !=_de .EOF ||len (_bcce )==0{return nil ,_eafa ;};if len (_bcce )==1{_bcce =append (_bcce ,' ');};};_ge .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_bcce ));if _bcce [0]=='/'{_dabd ,_cbee :=_ceda .parseName ();_ge .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_dabd );return &_dabd ,_cbee ;}else if _bcce [0]=='('{_ge .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_edfc ,_befa :=_ceda .parseString ();return _edfc ,_befa ;}else if _bcce [0]=='['{_ge .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_caadd ,_cdgc :=_ceda .parseArray ();return _caadd ,_cdgc ;}else if (_bcce [0]=='<')&&(_bcce [1]=='<'){_ge .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_ggde ,_gba :=_ceda .ParseDict ();return _ggde ,_gba ;}else if _bcce [0]=='<'{_ge .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_cfdae ,_geea :=_ceda .parseHexString ();return _cfdae ,_geea ;}else if _bcce [0]=='%'{_ceda .readComment ();_ceda .skipSpaces ();}else {_ge .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_bcce ,_ =_ceda ._aeff .Peek (15);_aefd :=string (_bcce );_ge .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_aefd );if (len (_aefd )> 3)&&(_aefd [:4]=="\u006e\u0075\u006c\u006c"){_aadb ,_geafa :=_ceda .parseNull ();return &_aadb ,_geafa ;}else if (len (_aefd )> 4)&&(_aefd [:5]=="\u0066\u0061\u006cs\u0065"){_cfbc ,_caff :=_ceda .parseBool ();return &_cfbc ,_caff ;}else if (len (_aefd )> 3)&&(_aefd [:4]=="\u0074\u0072\u0075\u0065"){_dbac ,_gcae :=_ceda .parseBool ();return &_dbac ,_gcae ;};_gedg :=_ggdc .FindStringSubmatch (_aefd );if len (_gedg )> 1{_bcce ,_ =_ceda ._aeff .ReadBytes ('R');_ge .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_bcce [:]));_gdaf ,_cagf :=_acbeb (string (_bcce ));_gdaf ._efgg =_ceda ;return &_gdaf ,_cagf ;};_gafce :=_bdbe .FindStringSubmatch (_aefd );if len (_gafce )> 1{_ge .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_aeecd ,_adcf :=_ceda .parseNumber ();return _aeecd ,_adcf ;};_gafce =_deac .FindStringSubmatch (_aefd );if len (_gafce )> 1{_ge .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_ge .Log .Trace ("\u0025\u0020\u0073",_gafce );_gabe ,_ecea :=_ceda .parseNumber ();return _gabe ,_ecea ;};_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_aefd );return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// UpdateParams updates the parameter values of the encoder.
func (_dfbf *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Len returns the number of elements in the streams.
func (_dbfg *PdfObjectStreams )Len ()int {if _dbfg ==nil {return 0;};return len (_dbfg ._agcf );};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_edb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_fgg *PdfParser )lookupObjectViaOS (_ea int ,_dcg int )(PdfObject ,error ){var _gd *_ggf .Reader ;var _cdf objectStream ;var _eb bool ;_cdf ,_eb =_fgg ._aba [_ea ];if !_eb {_gef ,_fc :=_fgg .LookupByNumber (_ea );if _fc !=nil {_ge .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ea );return nil ,_fc ;};_fb ,_ed :=_gef .(*PdfObjectStream );if !_ed {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _fgg ._fbcbf !=nil &&!_fgg ._fbcbf .isDecrypted (_fb ){return nil ,_c .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_cb :=_fb .PdfObjectDictionary ;_ge .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_cb .String ());_cafa ,_ed :=_cb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ed {_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ggg .ToLower (string (*_cafa ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_c .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ed :=_cb .Get ("\u004e").(*PdfObjectInteger );if !_ed {return nil ,_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_agg ,_ed :=_cb .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ed {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ge .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cafa ,*N );_ef ,_fc :=DecodeStream (_fb );if _fc !=nil {return nil ,_fc ;};_ge .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ef );_cf :=_fgg .GetFileOffset ();defer func (){_fgg .SetFileOffset (_cf )}();_gd =_ggf .NewReader (_ef );_fgg ._aeff =_b .NewReader (_gd );_ge .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_da :=map[int ]int64 {};for _dad :=0;_dad < int (*N );_dad ++{_fgg .skipSpaces ();_gefa ,_fbc :=_fgg .parseNumber ();if _fbc !=nil {return nil ,_fbc ;};_gda ,_cfg :=_gefa .(*PdfObjectInteger );if !_cfg {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_fgg .skipSpaces ();_gefa ,_fbc =_fgg .parseNumber ();if _fbc !=nil {return nil ,_fbc ;};_gbf ,_cfg :=_gefa .(*PdfObjectInteger );if !_cfg {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_ge .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_gda ,*_gbf );_da [int (*_gda )]=int64 (*_agg +*_gbf );};_cdf =objectStream {N :int (*N ),_cg :_ef ,_ce :_da };_fgg ._aba [_ea ]=_cdf ;}else {_eac :=_fgg .GetFileOffset ();defer func (){_fgg .SetFileOffset (_eac )}();_gd =_ggf .NewReader (_cdf ._cg );_fgg ._aeff =_b .NewReader (_gd );};_dbb :=_cdf ._ce [_dcg ];_ge .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_dcg ,_dbb );_gd .Seek (_dbb ,_de .SeekStart );_fgg ._aeff =_b .NewReader (_gd );_gfc ,_ :=_fgg ._aeff .Peek (100);_ge .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gfc ));_cbf ,_gfd :=_fgg .parseObject ();if _gfd !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_gfd );return nil ,_gfd ;};if _cbf ==nil {return nil ,_c .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_gc :=PdfIndirectObject {};_gc .ObjectNumber =int64 (_dcg );_gc .PdfObject =_cbf ;return &_gc ,nil ;};const _dedg =10;func _ceagg (_bee *_ee .FilterDict ,_fdc *PdfObjectDictionary )error {if _ccd ,_cba :=_fdc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cba {if _fbb :=string (*_ccd );_fbb !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_ge .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_fbb );};};_abc ,_aeag :=_fdc .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_aeag {return _gf .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_bee .CFM =string (*_abc );if _aff ,_eef :=_fdc .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_eef {_bee .AuthEvent =_aa .AuthEvent (*_aff );}else {_bee .AuthEvent =_aa .EventDocOpen ;};if _agd ,_beb :=_fdc .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_beb {_bee .Length =int (*_agd );};return nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};var _bdbe =_d .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_fde *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _adafb []byte ;_ge .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_fafb :=0;_aaab :=false ;for _fafb < len (encoded )&&!_aaab {_cfb :=[5]byte {0,0,0,0,0};_dfg :=0;_bfdd :=0;_deef :=4;for _bfdd < 5+_dfg {if _fafb +_bfdd ==len (encoded ){break ;};_abca :=encoded [_fafb +_bfdd ];if IsWhiteSpace (_abca ){_dfg ++;_bfdd ++;continue ;}else if _abca =='~'&&_fafb +_bfdd +1< len (encoded )&&encoded [_fafb +_bfdd +1]=='>'{_deef =(_bfdd -_dfg )-1;if _deef < 0{_deef =0;};_aaab =true ;break ;}else if _abca >='!'&&_abca <='u'{_abca -='!';}else if _abca =='z'&&_bfdd -_dfg ==0{_deef =4;_bfdd ++;break ;}else {_ge .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_cfb [_bfdd -_dfg ]=_abca ;_bfdd ++;};_fafb +=_bfdd ;for _fed :=_deef +1;_fed < 5;_fed ++{_cfb [_fed ]=84;};_gffb :=uint32 (_cfb [0])*85*85*85*85+uint32 (_cfb [1])*85*85*85+uint32 (_cfb [2])*85*85+uint32 (_cfb [3])*85+uint32 (_cfb [4]);_bebac :=[]byte {byte ((_gffb >>24)&0xff),byte ((_gffb >>16)&0xff),byte ((_gffb >>8)&0xff),byte (_gffb &0xff)};_adafb =append (_adafb ,_bebac [:_deef ]...);};_ge .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_ge .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_adafb );return _adafb ,nil ;};func (_gbfbf *PdfParser )repairSeekXrefMarker ()error {_aeaf ,_ggfd :=_gbfbf ._bbfa .Seek (0,_de .SeekEnd );if _ggfd !=nil {return _ggfd ;};_ebgc :=_d .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _cbec int64 ;var _cffa int64 =1000;for _cbec < _aeaf {if _aeaf <=(_cffa +_cbec ){_cffa =_aeaf -_cbec ;};_ ,_dcaf :=_gbfbf ._bbfa .Seek (-_cbec -_cffa ,_de .SeekEnd );if _dcaf !=nil {return _dcaf ;};_cegb :=make ([]byte ,_cffa );_gbfbf ._bbfa .Read (_cegb );_ge .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_cegb ));_ffbc :=_ebgc .FindAllStringIndex (string (_cegb ),-1);if _ffbc !=nil {_ddae :=_ffbc [len (_ffbc )-1];_ge .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ffbc );_gbfbf ._bbfa .Seek (-_cbec -_cffa +int64 (_ddae [0]),_de .SeekEnd );_gbfbf ._aeff =_b .NewReader (_gbfbf ._bbfa );for {_gfbbg ,_afcc :=_gbfbf ._aeff .Peek (1);if _afcc !=nil {return _afcc ;};_ge .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_gfbbg [0],_gfbbg [0]);if !IsWhiteSpace (_gfbbg [0]){break ;};_gbfbf ._aeff .Discard (1);};return nil ;};_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_cbec +=_cffa ;};_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _c .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_bddb *PdfParser )IsEncrypted ()(bool ,error ){if _bddb ._fbcbf !=nil {return true ,nil ;}else if _bddb ._caedd ==nil {return false ,nil ;};_ge .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_bedgg :=_bddb ._caedd .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _bedgg ==nil {return false ,nil ;};_ge .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_gdeb *PdfObjectDictionary ;);switch _eefe :=_bedgg .(type ){case *PdfObjectDictionary :_gdeb =_eefe ;case *PdfObjectReference :_ge .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_eefe );_fdbb ,_dcbc :=_bddb .LookupByReference (*_eefe );_ge .Log .Trace ("\u0031\u003a\u0020%\u0071",_fdbb );if _dcbc !=nil {return false ,_dcbc ;};_fdcbc ,_gggbd :=_fdbb .(*PdfIndirectObject );if !_gggbd {_ge .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_abae ,_gggbd :=_fdcbc .PdfObject .(*PdfObjectDictionary );_ge .Log .Trace ("\u0032\u003a\u0020%\u0071",_abae );if !_gggbd {return false ,_c .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_gdeb =_abae ;case *PdfObjectNull :_ge .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_gf .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_eefe );};_gbga ,_aadca :=PdfCryptNewDecrypt (_bddb ,_gdeb ,_bddb ._caedd );if _aadca !=nil {return false ,_aadca ;};for _ ,_gffg :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_gaab :=_bddb ._caedd .Get (PdfObjectName (_gffg ));if _gaab ==nil {continue ;};switch _edge :=_gaab .(type ){case *PdfObjectReference :_gbga ._aea [int (_edge .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_gbga ._agc [_edge ]=true ;_gbga ._aea [int (_edge .ObjectNumber )]=struct{}{};};};_bddb ._fbcbf =_gbga ;_ge .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_gbga );return true ,nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_caa *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_dea ,_fbdb :=obj .(*PdfObjectReference );if !_fbdb {return obj ,nil ;};_ade :=_caa .GetFileOffset ();defer func (){_caa .SetFileOffset (_ade )}();_fcg ,_ecg :=_caa .LookupByReference (*_dea );if _ecg !=nil {return nil ,_ecg ;};_bfg ,_dcc :=_fcg .(*PdfIndirectObject );if !_dcc {return _fcg ,nil ;};_fcg =_bfg .PdfObject ;_ ,_fbdb =_fcg .(*PdfObjectReference );if _fbdb {return _bfg ,_c .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _fcg ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_gga *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_cdc ,_ ,_eg :=_gga .lookupByNumberWrapper (objNumber ,true );return _cdc ,_eg ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_feba *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_feba .GetFilterName ());return data ,ErrNoJPXDecode ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_b .Reader )(PdfObject ,error ){_bcebg :=false ;_cedgf :=true ;var _fbgg _ggf .Buffer ;for {if _ge .Log .IsLogLevel (_ge .LogLevelTrace ){_ge .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_fbgg .String ());};_aeecdg ,_agbf :=buf .Peek (1);if _agbf ==_de .EOF {break ;};if _agbf !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_agbf );return nil ,_agbf ;};if _cedgf &&(_aeecdg [0]=='-'||_aeecdg [0]=='+'){_cbaff ,_ :=buf .ReadByte ();_fbgg .WriteByte (_cbaff );_cedgf =false ;}else if IsDecimalDigit (_aeecdg [0]){_aefbd ,_ :=buf .ReadByte ();_fbgg .WriteByte (_aefbd );}else if _aeecdg [0]=='.'{_bdbb ,_ :=buf .ReadByte ();_fbgg .WriteByte (_bdbb );_bcebg =true ;}else if _aeecdg [0]=='e'||_aeecdg [0]=='E'{_bbae ,_ :=buf .ReadByte ();_fbgg .WriteByte (_bbae );_bcebg =true ;_cedgf =true ;}else {break ;};};var _ageg PdfObject ;if _bcebg {_addf ,_dcaa :=_ca .ParseFloat (_fbgg .String (),64);if _dcaa !=nil {_ge .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_fbgg .String (),_dcaa );_addf =0.0;};_ebge :=PdfObjectFloat (_addf );_ageg =&_ebge ;}else {_bbcc ,_gacf :=_ca .ParseInt (_fbgg .String (),10,64);if _gacf !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_fbgg .String (),_gacf );_bbcc =0;};_cacd :=PdfObjectInteger (_bbcc );_ageg =&_cacd ;};return _ageg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfdaa *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_aedf :=&PdfObjectDictionary {};_aedf ._bfea =map[PdfObjectName ]PdfObject {};_aedf ._cbg =[]PdfObjectName {};return _aedf ;};func _edae (_gffc PdfObject )(*float64 ,error ){switch _cdcf :=_gffc .(type ){case *PdfObjectFloat :_efee :=float64 (*_cdcf );return &_efee ,nil ;case *PdfObjectInteger :_gadbc :=float64 (*_cdcf );return &_gadbc ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_gcag *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fffd [][]byte ;for _abgc :=0;_abgc < len (data );_abgc +=_gcag .Columns {_daf :=make ([]byte ,_gcag .Columns );_fdgf :=0;for _efac :=0;_efac < _gcag .Columns ;_efac ++{if data [_abgc +_efac ]==255{_daf [_fdgf ]=1;}else {_daf [_fdgf ]=0;};_fdgf ++;};_fffd =append (_fffd ,_daf );};_gac :=&_fa .Encoder {K :_gcag .K ,Columns :_gcag .Columns ,EndOfLine :_gcag .EndOfLine ,EndOfBlock :_gcag .EndOfBlock ,BlackIs1 :_gcag .BlackIs1 ,DamagedRowsBeforeError :_gcag .DamagedRowsBeforeError ,Rows :_gcag .Rows ,EncodedByteAlign :_gcag .EncodedByteAlign };return _gac .Encode (_fffd ),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_feccf *PdfObjectStream )WriteString ()string {var _feade _ggg .Builder ;_feade .WriteString (_ca .FormatInt (_feccf .ObjectNumber ,10));_feade .WriteString ("\u0020\u0030\u0020\u0052");return _feade .String ();};func (_ffbf *FlateEncoder )postDecodePredict (_eace []byte )([]byte ,error ){if _ffbf .Predictor > 1{if _ffbf .Predictor ==2{_ge .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ge .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_ffbf .Colors );_ggbf :=_ffbf .Columns *_ffbf .Colors ;if _ggbf < 1{return []byte {},nil ;};_edf :=len (_eace )/_ggbf ;if len (_eace )%_ggbf !=0{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eace ),_ggbf );};if _ggbf %_ffbf .Colors !=0{return nil ,_gf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ggbf ,_ffbf .Colors );};if _ggbf > len (_eace ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ggbf ,len (_eace ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ge .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_eace ),_eace );_bfgfd :=_ggf .NewBuffer (nil );for _ccbd :=0;_ccbd < _edf ;_ccbd ++{_ggc :=_eace [_ggbf *_ccbd :_ggbf *(_ccbd +1)];for _fcf :=_ffbf .Colors ;_fcf < _ggbf ;_fcf ++{_ggc [_fcf ]+=_ggc [_fcf -_ffbf .Colors ];};_bfgfd .Write (_ggc );};_acbe :=_bfgfd .Bytes ();_ge .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_acbe ),_acbe );return _acbe ,nil ;}else if _ffbf .Predictor >=10&&_ffbf .Predictor <=15{_ge .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ddf :=_ffbf .Columns *_ffbf .Colors +1;_dbca :=len (_eace )/_ddf ;if len (_eace )%_ddf !=0{return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eace ),_ddf );};if _ddf > len (_eace ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ddf ,len (_eace ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ggcc :=_ggf .NewBuffer (nil );_ge .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ffbf .Columns );_ge .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_eace ),_ddf ,_dbca );_ggdg :=make ([]byte ,_ddf );for _dgdb :=0;_dgdb < _ddf ;_dgdb ++{_ggdg [_dgdb ]=0;};_gdaa :=_ffbf .Colors ;for _bdg :=0;_bdg < _dbca ;_bdg ++{_cgge :=_eace [_ddf *_bdg :_ddf *(_bdg +1)];_cggd :=_cgge [0];switch _cggd {case _ede :case _faef :for _ffg :=1+_gdaa ;_ffg < _ddf ;_ffg ++{_cgge [_ffg ]+=_cgge [_ffg -_gdaa ];};case _bgff :for _fbca :=1;_fbca < _ddf ;_fbca ++{_cgge [_fbca ]+=_ggdg [_fbca ];};case _febg :for _gcg :=1;_gcg < _gdaa +1;_gcg ++{_cgge [_gcg ]+=_ggdg [_gcg ]/2;};for _bdfa :=_gdaa +1;_bdfa < _ddf ;_bdfa ++{_cgge [_bdfa ]+=byte ((int (_cgge [_bdfa -_gdaa ])+int (_ggdg [_bdfa ]))/2);};case _agfc :for _fbda :=1;_fbda < _ddf ;_fbda ++{var _fceb ,_fag ,_afga byte ;_fag =_ggdg [_fbda ];if _fbda >=_gdaa +1{_fceb =_cgge [_fbda -_gdaa ];_afga =_ggdg [_fbda -_gdaa ];};_cgge [_fbda ]+=_fcebf (_fceb ,_fag ,_afga );};default:_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_cggd ,_bdg );return nil ,_gf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cggd );};copy (_ggdg ,_cgge );_ggcc .Write (_cgge [1:]);};_ega :=_ggcc .Bytes ();return _ega ,nil ;}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ffbf .Predictor );return nil ,_gf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ffbf .Predictor );};};return _eace ,nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_ccgd :=&LZWEncoder {};_ccgd .Predictor =1;_ccgd .BitsPerComponent =8;_ccgd .Colors =1;_ccgd .Columns =1;_ccgd .EarlyChange =1;return _ccgd ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_aabg JBIG2EncoderSettings )Validate ()error {const _dbe ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _aabg .Threshold < 0||_aabg .Threshold > 1.0{return _ag .Errorf (_dbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_aabg .Threshold );};if _aabg .ResolutionX < 0{return _ag .Errorf (_dbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_aabg .ResolutionX );};if _aabg .ResolutionY < 0{return _ag .Errorf (_dbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_aabg .ResolutionY );};if _aabg .DefaultPixelValue !=0&&_aabg .DefaultPixelValue !=1{return _ag .Errorf (_dbe ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_aabg .DefaultPixelValue );};if _aabg .Compression !=JB2Generic {return _ag .Errorf (_dbe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fbcff *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_aabb :=range _fbcff ._effbe {_aabb .UpdateParams (params );};};

// Len returns the number of elements in the array.
func (_efab *PdfObjectArray )Len ()int {if _efab ==nil {return 0;};return len (_efab ._bcadc );};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_ecf *PdfObjectDictionary );EncodeBytes (_cagc []byte )([]byte ,error );DecodeBytes (_fdfe []byte )([]byte ,error );DecodeStream (_gggb *PdfObjectStream )([]byte ,error );};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_aedg :=&ASCIIHexEncoder {};return _aedg };

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_eegaa *PdfParser )GetTrailer ()*PdfObjectDictionary {return _eegaa ._caedd };

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// WriteString outputs the object as it is to be written to file.
func (_dbbgab *PdfObjectArray )WriteString ()string {var _adad _ggg .Builder ;_adad .WriteString ("\u005b");for _bgdf ,_dfead :=range _dbbgab .Elements (){_adad .WriteString (_dfead .WriteString ());if _bgdf < (_dbbgab .Len ()-1){_adad .WriteString ("\u0020");};};_adad .WriteString ("\u005d");return _adad .String ();};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_eegc *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_beea :=n ;_ebdabe :=0;_adecc :=0;for _beea > 0{_gaaa ,_bfcf :=_eegc ._aeff .Read (p [_ebdabe :]);if _bfcf !=nil {_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_gaaa ,_adecc ,_bfcf .Error ());return _ebdabe ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_adecc ++;_ebdabe +=_gaaa ;_beea -=_gaaa ;};return _ebdabe ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ccgc *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_gbce :=_ggf .NewReader (data );var _gcee []byte ;var _bcbg []byte ;_cdaf ,_eaac :=_gbce .ReadByte ();if _eaac ==_de .EOF {return []byte {},nil ;}else if _eaac !=nil {return nil ,_eaac ;};_adbb :=1;for {_dace ,_cadb :=_gbce .ReadByte ();if _cadb ==_de .EOF {break ;}else if _cadb !=nil {return nil ,_cadb ;};if _dace ==_cdaf {if len (_bcbg )> 0{_bcbg =_bcbg [:len (_bcbg )-1];if len (_bcbg )> 0{_gcee =append (_gcee ,byte (len (_bcbg )-1));_gcee =append (_gcee ,_bcbg ...);};_adbb =1;_bcbg =[]byte {};};_adbb ++;if _adbb >=127{_gcee =append (_gcee ,byte (257-_adbb ),_cdaf );_adbb =0;};}else {if _adbb > 0{if _adbb ==1{_bcbg =[]byte {_cdaf };}else {_gcee =append (_gcee ,byte (257-_adbb ),_cdaf );};_adbb =0;};_bcbg =append (_bcbg ,_dace );if len (_bcbg )>=127{_gcee =append (_gcee ,byte (len (_bcbg )-1));_gcee =append (_gcee ,_bcbg ...);_bcbg =[]byte {};};};_cdaf =_dace ;};if len (_bcbg )> 0{_gcee =append (_gcee ,byte (len (_bcbg )-1));_gcee =append (_gcee ,_bcbg ...);}else if _adbb > 0{_gcee =append (_gcee ,byte (257-_adbb ),_cdaf );};_gcee =append (_gcee ,128);return _gcee ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_aaga *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_edd :=MakeDict ();_edd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aaga .GetFilterName ()));_gbgd :=_aaga .MakeDecodeParams ();if _gbgd !=nil {_edd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gbgd );};_edd .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_aaga .EarlyChange )));return _edd ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_ccgb *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ccgb .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_bded *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };var _deac =_d .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_fdff *MultiEncoder )GetFilterArray ()*PdfObjectArray {_beee :=make ([]PdfObject ,len (_fdff ._effbe ));for _bgfc ,_ggbfc :=range _fdff ._effbe {_beee [_bgfc ]=MakeName (_ggbfc .GetFilterName ());};return MakeArray (_beee ...);};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_geab *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_ddd ,_caedb :=_dg .NewImage (_geab .Width ,_geab .Height ,_geab .BitsPerComponent ,_geab .ColorComponents ,data ,nil ,nil );if _caedb !=nil {return nil ,_caedb ;};_gabd :=_caf .Options {};_gabd .Quality =_geab .Quality ;var _dage _ggf .Buffer ;if _caedb =_caf .Encode (&_dage ,_ddd ,&_gabd );_caedb !=nil {return nil ,_caedb ;};return _dage .Bytes (),nil ;};func (_dbf *PdfCrypt )generateParams (_dec ,_dadd []byte )error {_fbcf :=_dbf .securityHandler ();_gecg ,_bed :=_fbcf .GenerateParams (&_dbf ._dcga ,_dadd ,_dec );if _bed !=nil {return _bed ;};_dbf ._bfc =_gecg ;return nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_bdcf :=MultiEncoder {};_bdcf ._effbe =[]StreamEncoder {};return &_bdcf ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_fcgg *JBIG2Encoder )EncodeImage (img _gb .Image )([]byte ,error ){return _fcgg .encodeImage (img )};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_agagg *PdfIndirectObject ,_cedg bool ){obj =ResolveReference (obj );_agagg ,_cedg =obj .(*PdfIndirectObject );return _agagg ,_cedg ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_debd *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _debd .DecodeBytes (streamObj .Stream );};func (_bbdc *ASCII85Encoder )base256Tobase85 (_dcba uint32 )[5]byte {_ebb :=[5]byte {0,0,0,0,0};_adgg :=_dcba ;for _bfcg :=0;_bfcg < 5;_bfcg ++{_edfac :=uint32 (1);for _accg :=0;_accg < 4-_bfcg ;_accg ++{_edfac *=85;};_gcca :=_adgg /_edfac ;_adgg =_adgg %_edfac ;_ebb [_bfcg ]=byte (_gcca );};return _ebb ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_afgbf *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bcda _ggf .Buffer ;_aece :=_ggf .NewReader (encoded );var _ddfa _de .ReadCloser ;if _afgbf .EarlyChange ==1{_ddfa =_fg .NewReader (_aece ,_fg .MSB ,8);}else {_ddfa =_e .NewReader (_aece ,_e .MSB ,8);};defer _ddfa .Close ();if _ ,_eege :=_bcda .ReadFrom (_ddfa );_eege !=nil {if _eege !=_de .ErrUnexpectedEOF ||_bcda .Len ()==0{return nil ,_eege ;};_ge .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_eege );};return _bcda .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bgfcg *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ebe :=MakeDict ();_ebe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgfcg .GetFilterName ()));return _ebe ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_bcadc []PdfObject };func (_dcce *PdfCrypt )isEncrypted (_geg PdfObject )bool {_ ,_cgg :=_dcce ._ege [_geg ];if _cgg {_ge .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_ge .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_g .Model ;Bounds ()_gb .Rectangle ;At (_fefa ,_cgfc int )_g .Color ;Set (_cgd ,_abeg int ,_egad _g .Color );};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_ge .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gdfc ,_fcdd :=NewEncoderFromStream (streamObj );if _fcdd !=nil {_ge .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fcdd );return _fcdd ;};if _acbd ,_eacc :=_gdfc .(*LZWEncoder );_eacc {_acbd .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_ge .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_gdfc );_gcdb ,_fcdd :=_gdfc .EncodeBytes (streamObj .Stream );if _fcdd !=nil {_ge .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fcdd );return _fcdd ;};streamObj .Stream =_gcdb ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gcdb ))));return nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_dbd *FlateEncoder )SetPredictor (columns int ){_dbd .Predictor =11;_dbd .Columns =columns };

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_bbfe *JBIG2Encoder )DecodeImages (encoded []byte )([]_gb .Image ,error ){const _cebe ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_gcfg ,_bgbda :=_ggd .Decode (encoded ,_ggd .Parameters {},_bbfe .Globals .ToDocumentGlobals ());if _bgbda !=nil {return nil ,_ag .Wrap (_bgbda ,_cebe ,"");};_aged ,_bgbda :=_gcfg .PageNumber ();if _bgbda !=nil {return nil ,_ag .Wrap (_bgbda ,_cebe ,"");};_cfaf :=[]_gb .Image {};var _eca _gb .Image ;for _dfde :=1;_dfde <=_aged ;_dfde ++{_eca ,_bgbda =_gcfg .DecodePageImage (_dfde );if _bgbda !=nil {return nil ,_ag .Wrapf (_bgbda ,_cebe ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dfde );};_cfaf =append (_cfaf ,_eca );};return _cfaf ,nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_aace *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };func (_aegd *PdfCrypt )securityHandler ()_aa .StdHandler {if _aegd ._dcga .R >=5{return _aa .NewHandlerR6 ();};return _aa .NewHandlerR4 (_aegd ._fbg ,_aegd ._gfg .Length );};func (_cbfb *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cfd :=MakeDict ();_cfd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_cfd .Set ("\u0056",MakeInteger (int64 (_cbfb ._gfg .V )));_cfd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cbfb ._gfg .Length )));return _cfd ;};

// String returns a string describing `d`.
func (_egcf *PdfObjectDictionary )String ()string {var _bceb _ggg .Builder ;_bceb .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_gfbfa :=range _egcf ._cbg {_daed :=_egcf ._bfea [_gfbfa ];_bceb .WriteString ("\u0022"+_gfbfa .String ()+"\u0022\u003a\u0020");_bceb .WriteString (_daed .String ());_bceb .WriteString ("\u002c\u0020");};_bceb .WriteString ("\u0029");return _bceb .String ();};func (_cfeg *PdfParser )xrefNextObjectOffset (_gcbd int64 )int64 {_debb :=int64 (0);if len (_cfeg ._bgc .ObjectMap )==0{return 0;};if len (_cfeg ._bgc ._ab )==0{_eaacb :=0;for _ ,_gfbd :=range _cfeg ._bgc .ObjectMap {if _gfbd .Offset > 0{_eaacb ++;};};if _eaacb ==0{return 0;};_cfeg ._bgc ._ab =make ([]XrefObject ,_eaacb );_aeeb :=0;for _ ,_bedcd :=range _cfeg ._bgc .ObjectMap {if _bedcd .Offset > 0{_cfeg ._bgc ._ab [_aeeb ]=_bedcd ;_aeeb ++;};};_ad .Slice (_cfeg ._bgc ._ab ,func (_gbbbc ,_feaea int )bool {return _cfeg ._bgc ._ab [_gbbbc ].Offset < _cfeg ._bgc ._ab [_feaea ].Offset });};_eecb :=_ad .Search (len (_cfeg ._bgc ._ab ),func (_egfb int )bool {return _cfeg ._bgc ._ab [_egfb ].Offset >=_gcbd });if _eecb < len (_cfeg ._bgc ._ab ){_debb =_cfeg ._bgc ._ab [_eecb ].Offset ;};return _debb ;};func (_baf *PdfCrypt )authenticate (_fce []byte )(bool ,error ){_baf ._agcd =false ;_egf :=_baf .securityHandler ();_cde ,_fcee ,_gggg :=_egf .Authenticate (&_baf ._dcga ,_fce );if _gggg !=nil {return false ,_gggg ;}else if _fcee ==0||len (_cde )==0{return false ,nil ;};_baf ._agcd =true ;_baf ._bfc =_cde ;return true ,nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_cef *PdfParser )GetCrypter ()*PdfCrypt {return _cef ._fbcbf };var _efaec _ae .Map ;

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_edab []float64 ,_gefg error ){for _ ,_fcbc :=range objects {_gbcgf ,_bdfe :=GetNumberAsFloat (_fcbc );if _bdfe !=nil {return nil ,_bdfe ;};_edab =append (_edab ,_gbcgf );};return _edab ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};var _beaa =_d .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_afddg :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _afddg ==nil {return NewRawEncoder (),nil ;};if _ ,_eegb :=_afddg .(*PdfObjectNull );_eegb {return NewRawEncoder (),nil ;};_adbbg ,_dafg :=_afddg .(*PdfObjectName );if !_dafg {_afcca ,_ggab :=_afddg .(*PdfObjectArray );if !_ggab {return nil ,_gf .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _afcca .Len ()==0{return NewRawEncoder (),nil ;};if _afcca .Len ()!=1{_bace ,_fdfgb :=_edeg (streamObj );if _fdfgb !=nil {_ge .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_fdfgb );return nil ,_fdfgb ;};_ge .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_bace );return _bace ,nil ;};_afddg =_afcca .Get (0);_adbbg ,_ggab =_afddg .(*PdfObjectName );if !_ggab {return nil ,_gf .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};if _dbfb ,_adee :=_efaec .Load (_adbbg .String ());_adee {return _dbfb .(StreamEncoder ),nil ;};switch *_adbbg {case StreamEncodingFilterNameFlate :return _ceb (streamObj ,nil );case StreamEncodingFilterNameLZW :return _cdgf (streamObj ,nil );case StreamEncodingFilterNameDCT :return _gfa (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _gcce (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _dcde (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _geda (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_gf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_adbbg );};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dgbcg *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_baga *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// UpdateParams updates the parameter values of the encoder.
func (_defbd *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_cggdf ,_aaa :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _aaa ==nil {_defbd .Predictor =int (_cggdf );};_dgc ,_aaa :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _aaa ==nil {_defbd .BitsPerComponent =int (_dgc );};_agfe ,_aaa :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _aaa ==nil {_defbd .Columns =int (_agfe );};_egb ,_aaa :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _aaa ==nil {_defbd .Colors =int (_egb );};_egfg ,_aaa :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _aaa ==nil {_defbd .EarlyChange =int (_egfg );};};func (_fgaaa *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_fgaaa ._bbfa .Seek (0,_de .SeekStart );_fgaaa ._aeff =_b .NewReader (_fgaaa ._bbfa );_afgg :=20;_beeg :=make ([]byte ,_afgg );for {_ffge ,_fegae :=_fgaaa ._aeff .ReadByte ();if _fegae !=nil {if _fegae ==_de .EOF {break ;}else {return 0,0,_fegae ;};};if IsDecimalDigit (_ffge )&&_beeg [_afgg -1]=='.'&&IsDecimalDigit (_beeg [_afgg -2])&&_beeg [_afgg -3]=='-'&&_beeg [_afgg -4]=='F'&&_beeg [_afgg -5]=='D'&&_beeg [_afgg -6]=='P'{_gfad :=int (_beeg [_afgg -2]-'0');_bbac :=int (_ffge -'0');return _gfad ,_bbac ,nil ;};_beeg =append (_beeg [1:_afgg ],_ffge );};return 0,0,_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _bagg :=obj .(type ){case *PdfObjectFloat :_ge .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_bagg ),nil ;case *PdfObjectInteger :return int64 (*_bagg ),nil ;};return 0,ErrNotANumber ;};

// Clear resets the dictionary to an empty state.
func (_cgce *PdfObjectDictionary )Clear (){_cgce ._cbg =[]PdfObjectName {};_cgce ._bfea =map[PdfObjectName ]PdfObject {};};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_bbbe *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// String returns a string describing `streams`.
func (_fafeb *PdfObjectStreams )String ()string {return _gf .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_fafeb .ObjectNumber );};func (_aadcg *JBIG2Encoder )encodeImage (_cfde _gb .Image )([]byte ,error ){const _afeg ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_cfdf ,_ffaf :=GoImageToJBIG2 (_cfde ,JB2ImageAutoThreshold );if _ffaf !=nil {return nil ,_ag .Wrap (_ffaf ,_afeg ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _ffaf =_aadcg .AddPageImage (_cfdf ,&_aadcg .DefaultPageSettings );_ffaf !=nil {return nil ,_ag .Wrap (_ffaf ,_afeg ,"");};return _aadcg .Encode ();};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_fdef :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_fdef .PdfObjectDictionary =encoder .MakeStreamDict ();_fdec ,_fbccc :=encoder .EncodeBytes (contents );if _fbccc !=nil {return nil ,_fbccc ;};_fdef .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fdec ))));_fdef .Stream =_fdec ;return _fdef ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bgdca *PdfObjectName )WriteString ()string {var _cefg _ggf .Buffer ;if len (*_bgdca )> 127{_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_bgdca );};_cefg .WriteString ("\u002f");for _gdce :=0;_gdce < len (*_bgdca );_gdce ++{_cgcf :=(*_bgdca )[_gdce ];if !IsPrintable (_cgcf )||_cgcf =='#'||IsDelimiter (_cgcf ){_cefg .WriteString (_gf .Sprintf ("\u0023\u0025\u002e2\u0078",_cgcf ));}else {_cefg .WriteByte (_cgcf );};};return _cefg .String ();};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_ddgf *JBIG2Image )ToGoImage ()(_gb .Image ,error ){const _adbc ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _ddgf .Data ==nil {return nil ,_ag .Error (_adbc ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _ddgf .Width ==0||_ddgf .Height ==0{return nil ,_ag .Error (_adbc ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_faec ,_ccdg :=_dg .NewImage (_ddgf .Width ,_ddgf .Height ,1,1,_ddgf .Data ,nil ,nil );if _ccdg !=nil {return nil ,_ccdg ;};return _faec ,nil ;};func (_bdca *PdfParser )parseBool ()(PdfObjectBool ,error ){_eadc ,_bada :=_bdca ._aeff .Peek (4);if _bada !=nil {return PdfObjectBool (false ),_bada ;};if (len (_eadc )>=4)&&(string (_eadc [:4])=="\u0074\u0072\u0075\u0065"){_bdca ._aeff .Discard (4);return PdfObjectBool (true ),nil ;};_eadc ,_bada =_bdca ._aeff .Peek (5);if _bada !=nil {return PdfObjectBool (false ),_bada ;};if (len (_eadc )>=5)&&(string (_eadc [:5])=="\u0066\u0061\u006cs\u0065"){_bdca ._aeff .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_c .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_acgc *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_acgc .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// WriteString outputs the object as it is to be written to file.
func (_gbde *PdfObjectReference )WriteString ()string {var _deeff _ggg .Builder ;_deeff .WriteString (_ca .FormatInt (_gbde .ObjectNumber ,10));_deeff .WriteString ("\u0020");_deeff .WriteString (_ca .FormatInt (_gbde .GenerationNumber ,10));_deeff .WriteString ("\u0020\u0052");return _deeff .String ();};func (_efcc *JBIG2Image )toBitmap ()(_agea *_df .Bitmap ,_cadf error ){const _febe ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _efcc .Data ==nil {return nil ,_ag .Error (_febe ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _efcc .Width ==0||_efcc .Height ==0{return nil ,_ag .Error (_febe ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _efcc .HasPadding {_agea ,_cadf =_df .NewWithData (_efcc .Width ,_efcc .Height ,_efcc .Data );}else {_agea ,_cadf =_df .NewWithUnpaddedData (_efcc .Width ,_efcc .Height ,_efcc .Data );};if _cadf !=nil {return nil ,_ag .Wrap (_cadf ,_febe ,"");};return _agea ,nil ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_dfff *PdfParser )IsAuthenticated ()bool {return _dfff ._fbcbf ._agcd };func (_ceff *PdfParser )repairLocateXref ()(int64 ,error ){_ddecb :=int64 (1000);_ceff ._bbfa .Seek (-_ddecb ,_de .SeekCurrent );_fdaf ,_fgdee :=_ceff ._bbfa .Seek (0,_de .SeekCurrent );if _fgdee !=nil {return 0,_fgdee ;};_agcca :=make ([]byte ,_ddecb );_ceff ._bbfa .Read (_agcca );_edef :=_cggg .FindAllStringIndex (string (_agcca ),-1);if len (_edef )< 1{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_c .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_fcdb :=int64 (_edef [len (_edef )-1][0]);_gdf :=_fdaf +_fcdb ;return _gdf ,nil ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func (_cfbd *PdfParser )readTextLine ()(string ,error ){var _afcgf _ggf .Buffer ;for {_cbfa ,_abfa :=_cfbd ._aeff .Peek (1);if _abfa !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abfa .Error ());return _afcgf .String (),_abfa ;};if (_cbfa [0]!='\r')&&(_cbfa [0]!='\n'){_begd ,_ :=_cfbd ._aeff .ReadByte ();_afcgf .WriteByte (_begd );}else {break ;};};return _afcgf .String (),nil ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_ceae *PdfObjectDictionary ,_bbec bool ){_ceae ,_bbec =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _ceae ,_bbec ;};var _ggdc =_d .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_gbbf *PdfObjectArray )Get (i int )PdfObject {if _gbbf ==nil ||i >=len (_gbbf ._bcadc )||i < 0{return nil ;};return _gbbf ._bcadc [i ];};func _cec (_bdf int )cryptFilters {return cryptFilters {_ggaa :_ee .NewFilterV2 (_bdf )}};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_fabe *PdfObjectBool ,_cbcf bool ){_fabe ,_cbcf =TraceToDirectObject (obj ).(*PdfObjectBool );return _fabe ,_cbcf ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_gacg *MultiEncoder )GetFilterName ()string {_ddff :="";for _eecd ,_gdca :=range _gacg ._effbe {_ddff +=_gdca .GetFilterName ();if _eecd < len (_gacg ._effbe )-1{_ddff +="\u0020";};};return _ddff ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_egega Version ;_bbfa _de .ReadSeeker ;_aeff *_b .Reader ;_feea int64 ;_bgc XrefTable ;_febd int64 ;_aaaf *xrefType ;_aba objectStreams ;_caedd *PdfObjectDictionary ;_fbcbf *PdfCrypt ;_aagf bool ;ObjCache objectCache ;_eebe map[int ]bool ;_gead map[int64 ]bool ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_cdag *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _fe .DecodeBytes (encoded ,_ggd .Parameters {},_cdag .Globals );};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};type cryptFilters map[string ]_ee .Filter ;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_efea *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_ffc :=MakeDict ();_ffc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efea .GetFilterName ()));_bgec :=_efea .MakeDecodeParams ();if _bgec !=nil {_ffc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bgec );};return _ffc ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func _cdgf (_agda *PdfObjectStream ,_aadd *PdfObjectDictionary )(*LZWEncoder ,error ){_agb :=NewLZWEncoder ();_degc :=_agda .PdfObjectDictionary ;if _degc ==nil {return _agb ,nil ;};if _aadd ==nil {_afe :=TraceToDirectObject (_degc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _afe !=nil {if _dbfa ,_gbgdg :=_afe .(*PdfObjectDictionary );_gbgdg {_aadd =_dbfa ;}else if _eebb ,_dgb :=_afe .(*PdfObjectArray );_dgb {if _eebb .Len ()==1{if _ebc ,_ccga :=GetDict (_eebb .Get (0));_ccga {_aadd =_ebc ;};};};if _aadd ==nil {_ge .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_afe );return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_fcc :=_degc .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _fcc !=nil {_dadc ,_bafe :=_fcc .(*PdfObjectInteger );if !_bafe {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_fcc );return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_dadc !=0&&*_dadc !=1{return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_agb .EarlyChange =int (*_dadc );}else {_agb .EarlyChange =1;};if _aadd ==nil {return _agb ,nil ;};if _cfda ,_caad :=GetIntVal (_aadd .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_caad {if _cfda ==0||_cfda ==1{_agb .EarlyChange =_cfda ;}else {_ge .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_cfda );};};_fcc =_aadd .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _fcc !=nil {_fbfg ,_gdda :=_fcc .(*PdfObjectInteger );if !_gdda {_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fcc );return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_agb .Predictor =int (*_fbfg );};_fcc =_aadd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _fcc !=nil {_fdad ,_dgbc :=_fcc .(*PdfObjectInteger );if !_dgbc {_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_gf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_agb .BitsPerComponent =int (*_fdad );};if _agb .Predictor > 1{_agb .Columns =1;_fcc =_aadd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _fcc !=nil {_beba ,_fff :=_fcc .(*PdfObjectInteger );if !_fff {return nil ,_gf .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_agb .Columns =int (*_beba );};_agb .Colors =1;_fcc =_aadd .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fcc !=nil {_baa ,_abfd :=_fcc .(*PdfObjectInteger );if !_abfd {return nil ,_gf .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_agb .Colors =int (*_baa );};};_ge .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_aadd .String ());return _agb ,nil ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_bfbbg bool ,_bdee bool ){_fgda ,_bdee :=TraceToDirectObject (obj ).(*PdfObjectBool );if _bdee {return bool (*_fgda ),true ;};return false ,false ;};func (_gecf *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _gecf ._aagf {return nil ,_gf .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_gecf ._aagf =true ;_gecf ._bbfa .Seek (0,_de .SeekStart );_gecf ._aeff =_b .NewReader (_gecf ._bbfa );_bbea :=20;_cbge :=make ([]byte ,_bbea );_aecee :=XrefTable {};_aecee .ObjectMap =make (map[int ]XrefObject );for {_edccb ,_ddddd :=_gecf ._aeff .ReadByte ();if _ddddd !=nil {if _ddddd ==_de .EOF {break ;}else {return nil ,_ddddd ;};};if _edccb =='j'&&_cbge [_bbea -1]=='b'&&_cbge [_bbea -2]=='o'&&IsWhiteSpace (_cbge [_bbea -3]){_cfcc :=_bbea -4;for IsWhiteSpace (_cbge [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0||!IsDecimalDigit (_cbge [_cfcc ]){continue ;};for IsDecimalDigit (_cbge [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0||!IsWhiteSpace (_cbge [_cfcc ]){continue ;};for IsWhiteSpace (_cbge [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0||!IsDecimalDigit (_cbge [_cfcc ]){continue ;};for IsDecimalDigit (_cbge [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0{continue ;};_gaagd :=_gecf .GetFileOffset ()-int64 (_bbea -_cfcc );_bgea :=append (_cbge [_cfcc +1:],_edccb );_abaee ,_egcfa ,_ceeg :=_gbgfg (string (_bgea ));if _ceeg !=nil {_ge .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_ceeg );return nil ,_ceeg ;};if _cdebc ,_feage :=_aecee .ObjectMap [_abaee ];!_feage ||_cdebc .Generation < _egcfa {_cbcb :=XrefObject {};_cbcb .XType =XrefTypeTableEntry ;_cbcb .ObjectNumber =_abaee ;_cbcb .Generation =_egcfa ;_cbcb .Offset =_gaagd ;_aecee .ObjectMap [_abaee ]=_cbcb ;};};_cbge =append (_cbge [1:_bbea ],_edccb );};_gecf ._eebe =nil ;return &_aecee ,nil ;};func (_bebg *PdfCrypt )makeKey (_ged string ,_efae ,_aage uint32 ,_gcaa []byte )([]byte ,error ){_eegg ,_cdd :=_bebg ._gfe [_ged ];if !_cdd {return nil ,_gf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ged );};return _eegg .MakeKey (_efae ,_aage ,_gcaa );};type xrefType int ;func _bgfcgb (_cfcad _dg .Image )*JBIG2Image {_bagf :=_cfcad .Base ();return &JBIG2Image {Data :_bagf .Data ,Width :_bagf .Width ,Height :_bagf .Height ,HasPadding :true };};

// WriteString outputs the object as it is to be written to file.
func (_gdbc *PdfObjectStreams )WriteString ()string {var _gfcb _ggg .Builder ;_gfcb .WriteString (_ca .FormatInt (_gdbc .ObjectNumber ,10));_gfcb .WriteString ("\u0020\u0030\u0020\u0052");return _gfcb .String ();};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetFilterName returns the name of the encoding filter.
func (_dbg *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_feaf *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_fcea :=MakeDict ();_fcea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_feaf .GetFilterArray ());for _ ,_bfeb :=range _feaf ._effbe {_gace :=_bfeb .MakeStreamDict ();for _ ,_dgdc :=range _gace .Keys (){_fbcab :=_gace .Get (_dgdc );if _dgdc !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_dgdc !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_fcea .Set (_dgdc ,_fbcab );};};};_ffac :=_feaf .MakeDecodeParams ();if _ffac !=nil {_fcea .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ffac );};return _fcea ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cccd *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cccd .Predictor !=1&&_cccd .Predictor !=11{_ge .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _cccd .Predictor ==11{_fdfeg :=_cccd .Columns ;_cafd :=len (data )/_fdfeg ;if len (data )%_fdfeg !=0{_ge .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_bad :=_ggf .NewBuffer (nil );_cafg :=make ([]byte ,_fdfeg );for _dcda :=0;_dcda < _cafd ;_dcda ++{_dbbga :=data [_fdfeg *_dcda :_fdfeg *(_dcda +1)];_cafg [0]=_dbbga [0];for _gff :=1;_gff < _fdfeg ;_gff ++{_cafg [_gff ]=byte (int (_dbbga [_gff ]-_dbbga [_gff -1])%256);};_bad .WriteByte (1);_bad .Write (_cafg );};data =_bad .Bytes ();};var _ggfe _ggf .Buffer ;_fad :=_db .NewWriter (&_ggfe );_fad .Write (data );_fad .Close ();return _ggfe .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cbef *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// UpdateParams updates the parameter values of the encoder.
func (_dfb *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Append appends PdfObject(s) to the streams.
func (_effc *PdfObjectStreams )Append (objects ...PdfObject ){if _effc ==nil {_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_effc ._agcf =append (_effc ._agcf ,objects ...);};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_agcf :objects };};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cdge *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_gdcg :=MakeDict ();_gdcg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cdge .GetFilterName ()));return _gdcg ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ggea *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ggea .DecodeBytes (streamObj .Stream );};

// GetXrefTable returns the PDFs xref table.
func (_ecd *PdfParser )GetXrefTable ()XrefTable {return _ecd ._bgc };

// WriteString outputs the object as it is to be written to file.
func (_eggaf *PdfIndirectObject )WriteString ()string {var _gdccc _ggg .Builder ;_gdccc .WriteString (_ca .FormatInt (_eggaf .ObjectNumber ,10));_gdccc .WriteString ("\u0020\u0030\u0020\u0052");return _gdccc .String ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_beg *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_bdcbb :=MakeDict ();_bdcbb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_beg .GetFilterName ()));return _bdcbb ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_cfad *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_cfad ._bbfa .Seek (offset ,_de .SeekStart );_cfad ._aeff =_b .NewReader (_cfad ._bbfa );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gce *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_eabf :=MakeDict ();_eabf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gce .GetFilterName ()));_bfe :=_gce .MakeDecodeParams ();if _bfe !=nil {_eabf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bfe );};return _eabf ;};

// WriteString outputs the object as it is to be written to file.
func (_gaded *PdfObjectBool )WriteString ()string {if *_gaded {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetFilterName returns the name of the encoding filter.
func (_ece *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_fdegg string ,_ffacc bool ){_cfcdf ,_ffacc :=TraceToDirectObject (obj ).(*PdfObjectName );if _ffacc {return string (*_cfcdf ),true ;};return ;};func (_ffa *PdfCrypt )encryptBytes (_aegf []byte ,_daec string ,_cda []byte )([]byte ,error ){_ge .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_eee ,_bcd :=_ffa ._gfe [_daec ];if !_bcd {return nil ,_gf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_daec );};return _eee .EncryptBytes (_aegf ,_cda );};func (_egcb *PdfParser )inspect ()(map[string ]int ,error ){_ge .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_ge .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_dagg :=map[string ]int {};_dbda :=0;_bbfea :=0;var _dgaf []int ;for _ccgcb :=range _egcb ._bgc .ObjectMap {_dgaf =append (_dgaf ,_ccgcb );};_ad .Ints (_dgaf );_gbgaf :=0;for _ ,_fggd :=range _dgaf {_fgad :=_egcb ._bgc .ObjectMap [_fggd ];if _fgad .ObjectNumber ==0{continue ;};_dbda ++;_ge .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_ge .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_fgad .ObjectNumber );_gfed ,_bcbb :=_egcb .LookupByNumber (_fgad .ObjectNumber );if _bcbb !=nil {_ge .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_fgad .ObjectNumber ,_bcbb );_bbfea ++;continue ;};_ge .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_gfed );_bdadd ,_ffeb :=_gfed .(*PdfIndirectObject );if _ffeb {_ge .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_fgad .ObjectNumber ,_bdadd );_ggcf ,_gafaf :=_bdadd .PdfObject .(*PdfObjectDictionary );if _gafaf {if _gcdd ,_bcgb :=_ggcf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bcgb {_fedf :=string (*_gcdd );_ge .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_fedf );_ ,_afeff :=_dagg [_fedf ];if _afeff {_dagg [_fedf ]++;}else {_dagg [_fedf ]=1;};}else if _fgcd ,_ffgf :=_ggcf .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ffgf {_ebfd :=string (*_fgcd );_ge .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_ebfd );_ ,_ffdb :=_dagg [_ebfd ];if _ffdb {_dagg [_ebfd ]++;}else {_dagg [_ebfd ]=1;};};if _bggc ,_egcc :=_ggcf .Get ("\u0053").(*PdfObjectName );_egcc &&*_bggc =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_egef :=_dagg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _egef {_dagg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_dagg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _fgec ,_dgcd :=_gfed .(*PdfObjectStream );_dgcd {if _efff ,_ccfdc :=_fgec .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ccfdc {_ge .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_efff );_dddc :=string (*_efff );_dagg [_dddc ]++;};}else {_gaaf ,_cfcf :=_gfed .(*PdfObjectDictionary );if _cfcf {_dabdb ,_gegc :=_gaaf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _gegc {_dagc :=string (*_dabdb );_ge .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_dagc );_dagg [_dagc ]++;};};_ge .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_fgad .ObjectNumber ,_gfed );};_gbgaf ++;};_ge .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_ge .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_ge .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_dbda );_ge .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_bbfea );for _dgdef ,_bfdac :=range _dagg {_ge .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_dgdef ,_bfdac );};_ge .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_egcb ._bgc .ObjectMap )< 1{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_gf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_ffgef ,_afaae :=_dagg ["\u0046\u006f\u006e\u0074"];if !_afaae ||_ffgef < 2{_ge .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_ge .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _dagg ,nil ;};var _bdad =_d .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func (_edaf *PdfCrypt )saveCryptFilters (_gec *PdfObjectDictionary )error {if _edaf ._gfg .V < 4{return _c .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_gdd :=MakeDict ();_gec .Set ("\u0043\u0046",_gdd );for _bgf ,_affa :=range _edaf ._gfe {if _bgf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_efba :=_fgeb (_affa ,"");_gdd .Set (PdfObjectName (_bgf ),_efba );};_gec .Set ("\u0053\u0074\u0072\u0046",MakeName (_edaf ._aac ));_gec .Set ("\u0053\u0074\u006d\u0046",MakeName (_edaf ._fbf ));return nil ;};func (_aebbe *PdfParser )parseName ()(PdfObjectName ,error ){var _daeb _ggf .Buffer ;_egc :=false ;for {_ddea ,_badbg :=_aebbe ._aeff .Peek (1);if _badbg ==_de .EOF {break ;};if _badbg !=nil {return PdfObjectName (_daeb .String ()),_badbg ;};if !_egc {if _ddea [0]=='/'{_egc =true ;_aebbe ._aeff .ReadByte ();}else if _ddea [0]=='%'{_aebbe .readComment ();_aebbe .skipSpaces ();}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_ddea ,_ddea );return PdfObjectName (_daeb .String ()),_gf .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_ddea [0]);};}else {if IsWhiteSpace (_ddea [0]){break ;}else if (_ddea [0]=='/')||(_ddea [0]=='[')||(_ddea [0]=='(')||(_ddea [0]==']')||(_ddea [0]=='<')||(_ddea [0]=='>'){break ;}else if _ddea [0]=='#'{_ded ,_ebga :=_aebbe ._aeff .Peek (3);if _ebga !=nil {return PdfObjectName (_daeb .String ()),_ebga ;};_acdfb ,_ebga :=_dc .DecodeString (string (_ded [1:3]));if _ebga !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_daeb .WriteByte ('#');_aebbe ._aeff .Discard (1);continue ;};_aebbe ._aeff .Discard (3);_daeb .Write (_acdfb );}else {_aacf ,_ :=_aebbe ._aeff .ReadByte ();_daeb .WriteByte (_aacf );};};};return PdfObjectName (_daeb .String ()),nil ;};const (DefaultJPEGQuality =75;);

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_bceg *PdfParser )Decrypt (password []byte )(bool ,error ){if _bceg ._fbcbf ==nil {return false ,_c .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_geag ,_dffa :=_bceg ._fbcbf .authenticate (password );if _dffa !=nil {return false ,_dffa ;};if !_geag {_geag ,_dffa =_bceg ._fbcbf .authenticate ([]byte (""));};return _geag ,_dffa ;};

// UpdateParams updates the parameter values of the encoder.
func (_fbbb *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_fbfa ,_badb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _badb ==nil {_fbbb .ColorComponents =int (_fbfa );};_cad ,_badb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _badb ==nil {_fbbb .BitsPerComponent =int (_cad );};_ecbd ,_badb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _badb ==nil {_fbbb .Width =int (_ecbd );};_eacd ,_badb :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _badb ==nil {_fbbb .Height =int (_eacd );};_fbcac ,_badb :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _badb ==nil {_fbbb .Quality =int (_fbcac );};};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_eegd *PdfObjectStreams )Elements ()[]PdfObject {if _eegd ==nil {return nil ;};return _eegd ._agcf ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_cccg *JBIG2Encoder )DecodeGlobals (encoded []byte )(_fe .Globals ,error ){return _fe .DecodeGlobals (encoded );};

// WriteString outputs the object as it is to be written to file.
func (_eedee *PdfObjectFloat )WriteString ()string {return _ca .FormatFloat (float64 (*_eedee ),'f',-1,64);};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_afdb *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_bfdgb :=PdfIndirectObject {};_bfdgb ._efgg =_afdb ;_ge .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_abfc ,_ggac :=_afdb ._aeff .Peek (20);if _ggac !=nil {if _ggac !=_de .EOF {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_bfdgb ,_ggac ;};};_ge .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_abfc ));_bgef :=_fage .FindStringSubmatchIndex (string (_abfc ));if len (_bgef )< 6{if _ggac ==_de .EOF {return nil ,_ggac ;};_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_abfc ));return &_bfdgb ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_afdb ._aeff .Discard (_bgef [0]);_ge .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_bgef );_aeaa :=_bgef [1]-_bgef [0];_cgdad :=make ([]byte ,_aeaa );_ ,_ggac =_afdb .ReadAtLeast (_cgdad ,_aeaa );if _ggac !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_ggac );return nil ,_ggac ;};_ge .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cgdad );_bbeg :=_fage .FindStringSubmatch (string (_cgdad ));if len (_bbeg )< 3{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_cgdad ));return &_bfdgb ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_baac ,_ :=_ca .Atoi (_bbeg [1]);_fcgga ,_ :=_ca .Atoi (_bbeg [2]);_bfdgb .ObjectNumber =int64 (_baac );_bfdgb .GenerationNumber =int64 (_fcgga );for {_gagf ,_bgfg :=_afdb ._aeff .Peek (2);if _bgfg !=nil {return &_bfdgb ,_bgfg ;};_ge .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gagf ),string (_gagf ));if IsWhiteSpace (_gagf [0]){_afdb .skipSpaces ();}else if _gagf [0]=='%'{_afdb .skipComments ();}else if (_gagf [0]=='<')&&(_gagf [1]=='<'){_ge .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_bfdgb .PdfObject ,_bgfg =_afdb .ParseDict ();_ge .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_bgfg );if _bgfg !=nil {return &_bfdgb ,_bgfg ;};_ge .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_gagf [0]=='/')||(_gagf [0]=='(')||(_gagf [0]=='[')||(_gagf [0]=='<'){_bfdgb .PdfObject ,_bgfg =_afdb .parseObject ();if _bgfg !=nil {return &_bfdgb ,_bgfg ;};_ge .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _gagf [0]==']'{_ge .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_afdb ._aeff .Discard (1);}else {if _gagf [0]=='e'{_caac ,_eeca :=_afdb .readTextLine ();if _eeca !=nil {return nil ,_eeca ;};if len (_caac )>=6&&_caac [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _gagf [0]=='s'{_gagf ,_ =_afdb ._aeff .Peek (10);if string (_gagf [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_dbec :=6;if len (_gagf )> 6{if IsWhiteSpace (_gagf [_dbec ])&&_gagf [_dbec ]!='\r'&&_gagf [_dbec ]!='\n'{_ge .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_dbec ++;};if _gagf [_dbec ]=='\r'{_dbec ++;if _gagf [_dbec ]=='\n'{_dbec ++;};}else if _gagf [_dbec ]=='\n'{_dbec ++;};};_afdb ._aeff .Discard (_dbec );_ccdf ,_cdcg :=_bfdgb .PdfObject .(*PdfObjectDictionary );if !_cdcg {return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ge .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_ccdf );_fgag ,_ffdg :=_afdb .traceStreamLength (_ccdf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _ffdg !=nil {_ge .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_ffdg );return nil ,_ffdg ;};_ge .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fgag );_aedgg ,_faaaf :=_fgag .(*PdfObjectInteger );if !_faaaf {return nil ,_c .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_cgbe :=*_aedgg ;if _cgbe < 0{return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_bbab :=_afdb .GetFileOffset ();_bedb :=_afdb .xrefNextObjectOffset (_bbab );if _bbab +int64 (_cgbe )> _bedb &&_bedb > _bbab {_ge .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_bbab +int64 (_cgbe ));_ge .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_bedb );_ddeae :=_bedb -_bbab -17;if _ddeae < 0{return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_ge .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_ddeae );_cgbe =PdfObjectInteger (_ddeae );_ccdf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_ddeae ));};if int64 (_cgbe )> _afdb ._feea {_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_gcgg :=make ([]byte ,_cgbe );_ ,_ffdg =_afdb .ReadAtLeast (_gcgg ,int (_cgbe ));if _ffdg !=nil {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_gcgg ),_gcgg );_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffdg );return nil ,_ffdg ;};_dbffb :=PdfObjectStream {};_dbffb .Stream =_gcgg ;_dbffb .PdfObjectDictionary =_bfdgb .PdfObject .(*PdfObjectDictionary );_dbffb .ObjectNumber =_bfdgb .ObjectNumber ;_dbffb .GenerationNumber =_bfdgb .GenerationNumber ;_dbffb .PdfObjectReference ._efgg =_afdb ;_afdb .skipSpaces ();_afdb ._aeff .Discard (9);_afdb .skipSpaces ();return &_dbffb ,nil ;};};_bfdgb .PdfObject ,_bgfg =_afdb .parseObject ();if _bfdgb .PdfObject ==nil {_ge .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_bfdgb .PdfObject =MakeNull ();};return &_bfdgb ,_bgfg ;};};if _bfdgb .PdfObject ==nil {_ge .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_bfdgb .PdfObject =MakeNull ();};_ge .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_bfdgb ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_abf *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_geeb ,_cbce :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cbce ==nil {_abf .Predictor =int (_geeb );};_cdee ,_cbce :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cbce ==nil {_abf .BitsPerComponent =int (_cdee );};_ccag ,_cbce :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cbce ==nil {_abf .Columns =int (_ccag );};_ccc ,_cbce :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cbce ==nil {_abf .Colors =int (_ccc );};};func (_fdcdd *PdfParser )resolveReference (_fefg *PdfObjectReference )(PdfObject ,bool ,error ){_dbfd ,_gbacc :=_fdcdd .ObjCache [int (_fefg .ObjectNumber )];if _gbacc {return _dbfd ,true ,nil ;};_cead ,_eeaf :=_fdcdd .LookupByReference (*_fefg );if _eeaf !=nil {return nil ,false ,_eeaf ;};_fdcdd .ObjCache [int (_fefg .ObjectNumber )]=_cead ;return _cead ,false ,nil ;};func (_debdb *PdfObjectFloat )String ()string {return _gf .Sprintf ("\u0025\u0066",*_debdb )};func _fgeb (_gge _ee .Filter ,_ebd _aa .AuthEvent )*PdfObjectDictionary {if _ebd ==""{_ebd =_aa .EventDocOpen ;};_ac :=MakeDict ();_ac .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_ac .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ebd )));_ac .Set ("\u0043\u0046\u004d",MakeName (_gge .Name ()));_ac .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gge .KeyLength ())));return _ac ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_dcdg *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_gebb :=MakeDict ();_gebb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dcdg .GetFilterName ()));return _gebb ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_fbfe *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fbfe .DecodeBytes (streamObj .Stream );};func (_cfgg *offsetReader )Read (p []byte )(_bgfb int ,_fdfd error ){return _cfgg ._dddd .Read (p )};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_bdfc *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_deefg ,_affbg :=_bdfc ._bfea [key ];if !_affbg {return nil ;};return _deefg ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_bcca *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_dgaca :=range another .Keys (){_gbcbd :=another .Get (_dgaca );_bcca .Set (_dgaca ,_gbcbd );};};return _bcca ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func _bcec (_gbdb PdfObject ,_ebbbc int ,_dfce map[PdfObject ]struct{})error {_ge .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_ebbbc );if _ ,_daebb :=_dfce [_gbdb ];_daebb {_ge .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_dfce [_gbdb ]=struct{}{};switch _abgdb :=_gbdb .(type ){case *PdfIndirectObject :_fbfd :=_abgdb ;_ge .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_fbfd );_ge .Log .Trace ("\u002d\u0020\u0025\u0073",_fbfd .PdfObject );return _bcec (_fbfd .PdfObject ,_ebbbc +1,_dfce );case *PdfObjectStream :_fecd :=_abgdb ;return _bcec (_fecd .PdfObjectDictionary ,_ebbbc +1,_dfce );case *PdfObjectDictionary :_bdeg :=_abgdb ;_ge .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_bdeg );for _ ,_dead :=range _bdeg .Keys (){_cbcde :=_bdeg .Get (_dead );if _debc ,_aegdb :=_cbcde .(*PdfObjectReference );_aegdb {_cfbde :=_debc .Resolve ();_bdeg .Set (_dead ,_cfbde );_fadeg :=_bcec (_cfbde ,_ebbbc +1,_dfce );if _fadeg !=nil {return _fadeg ;};}else {_ebba :=_bcec (_cbcde ,_ebbbc +1,_dfce );if _ebba !=nil {return _ebba ;};};};return nil ;case *PdfObjectArray :_aggg :=_abgdb ;_ge .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_aggg );for _ebafc ,_faee :=range _aggg .Elements (){if _gcaf ,_ffcf :=_faee .(*PdfObjectReference );_ffcf {_fbfgd :=_gcaf .Resolve ();_aggg .Set (_ebafc ,_fbfgd );_aacca :=_bcec (_fbfgd ,_ebbbc +1,_dfce );if _aacca !=nil {return _aacca ;};}else {_bdge :=_bcec (_faee ,_ebbbc +1,_dfce );if _bdge !=nil {return _bdge ;};};};return nil ;case *PdfObjectReference :_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _c .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_fafd :=PdfObjectName (s );return &_fafd };

// String returns a string describing `null`.
func (_gefgb *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func (_aecf *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_de .SeekStart {offset +=_aecf ._cbbf ;};_ggcb ,_acfg :=_aecf ._dddd .Seek (offset ,whence );if _acfg !=nil {return _ggcb ,_acfg ;};if whence ==_de .SeekCurrent {_ggcb -=_aecf ._cbbf ;};if _ggcb < 0{return 0,_c .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _ggcb ,nil ;};var _cfggb =_d .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};func (_aaceg *PdfParser )skipSpaces ()(int ,error ){_acbc :=0;for {_cbed ,_edcc :=_aaceg ._aeff .ReadByte ();if _edcc !=nil {return 0,_edcc ;};if IsWhiteSpace (_cbed ){_acbc ++;}else {_aaceg ._aeff .UnreadByte ();break ;};};return _acbc ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_bfag *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_cfgb error ){const _fgc ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _bfag ==nil {return _ag .Error (_fgc ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_bfag .DefaultPageSettings ;};if _bfag ._cacb ==nil {_bfag ._cacb =_fab .InitEncodeDocument (settings .FileMode );};if _cfgb =settings .Validate ();_cfgb !=nil {return _ag .Wrap (_cfgb ,_fgc ,"");};_bdda ,_cfgb :=img .toBitmap ();if _cfgb !=nil {return _ag .Wrap (_cfgb ,_fgc ,"");};switch settings .Compression {case JB2Generic :if _cfgb =_bfag ._cacb .AddGenericPage (_bdda ,settings .DuplicatedLinesRemoval );_cfgb !=nil {return _ag .Wrap (_cfgb ,_fgc ,"");};case JB2SymbolCorrelation :return _ag .Error (_fgc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _ag .Error (_fgc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _ag .Error (_fgc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// String returns a string representation of the *PdfObjectString.
func (_gfgd *PdfObjectString )String ()string {return _gfgd ._bdcaa };func (_eba *PdfParser )lookupByNumber (_fec int ,_dcf bool )(PdfObject ,bool ,error ){_cfa ,_ec :=_eba .ObjCache [_fec ];if _ec {_ge .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_fec );return _cfa ,false ,nil ;};if _eba ._eebe ==nil {_eba ._eebe =map[int ]bool {};};if _eba ._eebe [_fec ]{_ge .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_fec );return nil ,false ,_c .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_eba ._eebe [_fec ]=true ;defer delete (_eba ._eebe ,_fec );_gefc ,_ec :=_eba ._bgc .ObjectMap [_fec ];if !_ec {_ge .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _caed PdfObjectNull ;return &_caed ,false ,nil ;};_ge .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_fec );if _gefc .XType ==XrefTypeTableEntry {_ge .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_gefc .ObjectNumber );_ge .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_gefc .Generation );_ge .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_gefc .Offset );_eba ._bbfa .Seek (_gefc .Offset ,_de .SeekStart );_eba ._aeff =_b .NewReader (_eba ._bbfa );_adf ,_bc :=_eba .ParseIndirectObject ();if _bc !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_bc );if _dcf {_ge .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_bb ,_eeg :=_eba .repairRebuildXrefsTopDown ();if _eeg !=nil {_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_eeg );return nil ,false ,_eeg ;};_eba ._bgc =*_bb ;return _eba .lookupByNumber (_fec ,false );};return nil ,false ,_bc ;};if _dcf {_cab ,_ ,_ :=_dgd (_adf );if int (_cab )!=_fec {_ge .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_feae :=_eba .rebuildXrefTable ();if _feae !=nil {return nil ,false ,_feae ;};_eba .ObjCache =objectCache {};return _eba .lookupByNumberWrapper (_fec ,false );};};_ge .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_eba .ObjCache [_fec ]=_adf ;return _adf ,false ,nil ;}else if _gefc .XType ==XrefTypeObjectStream {_ge .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_ge .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_ge .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_gefc .OsObjNumber ,_gefc .OsObjIndex );if _gefc .OsObjNumber ==_fec {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_c .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_bgd :=_eba ._bgc .ObjectMap [_gefc .OsObjNumber ];_bgd {_ceag ,_bfd :=_eba .lookupObjectViaOS (_gefc .OsObjNumber ,_fec );if _bfd !=nil {_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_bfd );return nil ,true ,_bfd ;};_ge .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_eba .ObjCache [_fec ]=_ceag ;if _eba ._fbcbf !=nil {_eba ._fbcbf ._agc [_ceag ]=true ;};return _ceag ,true ,nil ;};_ge .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_c .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_c .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// WriteString outputs the object as it is to be written to file.
func (_bdfg *PdfObjectInteger )WriteString ()string {return _ca .FormatInt (int64 (*_bdfg ),10)};

// DecodeStream implements ASCII hex decoding.
func (_cbb *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cbb .DecodeBytes (streamObj .Stream );};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func (_dfe *PdfParser )lookupByNumberWrapper (_cc int ,_cae bool )(PdfObject ,bool ,error ){_af ,_afg ,_fd :=_dfe .lookupByNumber (_cc ,_cae );if _fd !=nil {return nil ,_afg ,_fd ;};if !_afg &&_dfe ._fbcbf !=nil &&!_dfe ._fbcbf .isDecrypted (_af ){_efb :=_dfe ._fbcbf .Decrypt (_af ,0,0);if _efb !=nil {return nil ,_afg ,_efb ;};};return _af ,_afg ,nil ;};func _ceb (_ecb *PdfObjectStream ,_bag *PdfObjectDictionary )(*FlateEncoder ,error ){_fggg :=NewFlateEncoder ();_bff :=_ecb .PdfObjectDictionary ;if _bff ==nil {return _fggg ,nil ;};_fggg ._ada =_abcb (_bff );if _bag ==nil {_efbf :=TraceToDirectObject (_bff .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _bebb :=_efbf .(type ){case *PdfObjectArray :if _bebb .Len ()!=1{_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_bebb .Len ());return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _eegf ,_fdbf :=GetDict (_bebb .Get (0));_fdbf {_bag =_eegf ;};case *PdfObjectDictionary :_bag =_bebb ;case *PdfObjectNull ,nil :default:_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_efbf );return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bag ==nil {return _fggg ,nil ;};_ge .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bag .String ());_abed :=_bag .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _abed ==nil {_ge .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_bbd ,_gcd :=_abed .(*PdfObjectInteger );if !_gcd {_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_abed );return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fggg .Predictor =int (*_bbd );};_abed =_bag .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _abed !=nil {_ggda ,_bfa :=_abed .(*PdfObjectInteger );if !_bfa {_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_gf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fggg .BitsPerComponent =int (*_ggda );};if _fggg .Predictor > 1{_fggg .Columns =1;_abed =_bag .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _abed !=nil {_cbfc ,_cbcd :=_abed .(*PdfObjectInteger );if !_cbcd {return nil ,_gf .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fggg .Columns =int (*_cbfc );};_fggg .Colors =1;_abed =_bag .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _abed !=nil {_bfde ,_efg :=_abed .(*PdfObjectInteger );if !_efg {return nil ,_gf .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_fggg .Colors =int (*_bfde );};};return _fggg ,nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_geec *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_ge .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_gdaac :=MakeDict ();_gdaac ._dcab =_geec ;_feafb ,_ :=_geec ._aeff .ReadByte ();if _feafb !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_feafb ,_ =_geec ._aeff .ReadByte ();if _feafb !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_geec .skipSpaces ();_geec .skipComments ();_fgcf ,_bebc :=_geec ._aeff .Peek (2);if _bebc !=nil {return nil ,_bebc ;};_ge .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fgcf ),string (_fgcf ));if (_fgcf [0]=='>')&&(_fgcf [1]=='>'){_ge .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_geec ._aeff .ReadByte ();_geec ._aeff .ReadByte ();break ;};_ge .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_bgbe ,_bebc :=_geec .parseName ();_ge .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_bgbe );if _bebc !=nil {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_bebc );return nil ,_bebc ;};if len (_bgbe )> 4&&_bgbe [len (_bgbe )-4:]=="\u006e\u0075\u006c\u006c"{_bebe :=_bgbe [0:len (_bgbe )-4];_ge .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_bgbe );_ge .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_bebe );_geec .skipSpaces ();_gcagc ,_ :=_geec ._aeff .Peek (1);if _gcagc [0]=='/'{_gdaac .Set (_bebe ,MakeNull ());continue ;};};_geec .skipSpaces ();_gcbg ,_bebc :=_geec .parseObject ();if _bebc !=nil {return nil ,_bebc ;};_gdaac .Set (_bgbe ,_gcbg );if _ge .Log .IsLogLevel (_ge .LogLevelTrace ){_ge .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_bgbe ,_gcbg .String ());};};_ge .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _gdaac ,nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ab []XrefObject ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// Append appends PdfObject(s) to the array.
func (_abac *PdfObjectArray )Append (objects ...PdfObject ){if _abac ==nil {_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_abac ._bcadc =append (_abac ._bcadc ,objects ...);};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_efaec .Store (filterName ,customStreamEncoder );};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};const (_ede =0;_faef =1;_bgff =2;_febg =3;_agfc =4;);

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _caga _ggf .Buffer ;_caga .Write ([]byte {0xFE,0xFF});_caga .WriteString (_fgf .StringToUTF16 (s ));return &PdfObjectString {_bdcaa :_caga .String (),_egcg :true };};return &PdfObjectString {_bdcaa :string (_fgf .StringToPDFDocEncoding (s )),_egcg :false };};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _de .ReadSeeker )(*PdfParser ,error ){_dfbd :=&PdfParser {_bbfa :rs ,ObjCache :make (objectCache ),_gead :map[int64 ]bool {}};_ecbe ,_ffde ,_dgbb :=_dfbd .parsePdfVersion ();if _dgbb !=nil {_ge .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_dgbb );return nil ,_dgbb ;};_dfbd ._egega .Major =_ecbe ;_dfbd ._egega .Minor =_ffde ;if _dfbd ._caedd ,_dgbb =_dfbd .loadXrefs ();_dgbb !=nil {_ge .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dgbb );return nil ,_dgbb ;};_ge .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_dfbd ._caedd );if len (_dfbd ._bgc .ObjectMap )==0{return nil ,_gf .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _dfbd ,nil ;};func _eae (_dd *_aa .StdEncryptDict ,_cbc *PdfObjectDictionary ){_cbc .Set ("\u0052",MakeInteger (int64 (_dd .R )));_cbc .Set ("\u0050",MakeInteger (int64 (_dd .P )));_cbc .Set ("\u004f",MakeStringFromBytes (_dd .O ));_cbc .Set ("\u0055",MakeStringFromBytes (_dd .U ));if _dd .R >=5{_cbc .Set ("\u004f\u0045",MakeStringFromBytes (_dd .OE ));_cbc .Set ("\u0055\u0045",MakeStringFromBytes (_dd .UE ));_cbc .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_dd .EncryptMetadata ));if _dd .R > 5{_cbc .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_dd .Perms ));};};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgd *LZWEncoder )MakeDecodeParams ()PdfObject {if _fgd .Predictor > 1{_eebc :=MakeDict ();_eebc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fgd .Predictor )));if _fgd .BitsPerComponent !=8{_eebc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fgd .BitsPerComponent )));};if _fgd .Columns !=1{_eebc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgd .Columns )));};if _fgd .Colors !=1{_eebc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fgd .Colors )));};return _eebc ;};return nil ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_bege *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_abff ,_fefe :=_bege ._bfea [key ].(*PdfObjectString );if !_fefe {return "",false ;};return _abff .Str (),true ;};var _fdcf =_d .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func (_acdb *PdfParser )traceStreamLength (_ebea PdfObject )(PdfObject ,error ){_dgef ,_bgcg :=_ebea .(*PdfObjectReference );if _bgcg {_gbag ,_ddaa :=_acdb ._gead [_dgef .ObjectNumber ];if _ddaa &&_gbag {_ge .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_c .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_acdb ._gead [_dgef .ObjectNumber ]=true ;};_ebcd ,_affag :=_acdb .Resolve (_ebea );if _affag !=nil {return nil ,_affag ;};_ge .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ebcd );if _bgcg {_acdb ._gead [_dgef .ObjectNumber ]=false ;};return _ebcd ,nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_agcf []PdfObject ;};func (_gabc *PdfParser )parseArray ()(*PdfObjectArray ,error ){_bage :=MakeArray ();_gabc ._aeff .ReadByte ();for {_gabc .skipSpaces ();_fcdc ,_cbafb :=_gabc ._aeff .Peek (1);if _cbafb !=nil {return _bage ,_cbafb ;};if _fcdc [0]==']'{_gabc ._aeff .ReadByte ();break ;};_adga ,_cbafb :=_gabc .parseObject ();if _cbafb !=nil {return _bage ,_cbafb ;};_bage .Append (_adga );};return _bage ,nil ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_adgb *PdfObjectArray ,_aegc bool ){_adgb ,_aegc =TraceToDirectObject (obj ).(*PdfObjectArray );return _adgb ,_aegc ;};func _caae (_ced _de .ReadSeeker ,_bbad int64 )(*offsetReader ,error ){_eabff :=&offsetReader {_dddd :_ced ,_cbbf :_bbad };_ ,_eefa :=_eabff .Seek (0,_de .SeekStart );return _eabff ,_eefa ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_eabb *PdfObjectString )Str ()string {return _eabb ._bdcaa };

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_fdde :=_ggf .NewReader ([]byte (txt ));_bbffg :=&PdfParser {ObjCache :objectCache {},_bbfa :_fdde ,_aeff :_b .NewReader (_fdde ),_feea :int64 (len (txt )),_gead :map[int64 ]bool {}};_bbffg ._bgc .ObjectMap =make (map[int ]XrefObject );return _bbffg ;};

// SetImage sets the image base for given flate encoder.
func (_agf *FlateEncoder )SetImage (img *_dg .ImageBase ){_agf ._ada =img };

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_bdcaa string ;_egcg bool ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_fedb *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _geca _ggf .Buffer ;for _gedb :=0;_gedb < len (data );_gedb +=4{_cgb :=data [_gedb ];_gafcf :=1;_dffe :=byte (0);if _gedb +1< len (data ){_dffe =data [_gedb +1];_gafcf ++;};_fead :=byte (0);if _gedb +2< len (data ){_fead =data [_gedb +2];_gafcf ++;};_beddb :=byte (0);if _gedb +3< len (data ){_beddb =data [_gedb +3];_gafcf ++;};_dcdc :=(uint32 (_cgb )<<24)|(uint32 (_dffe )<<16)|(uint32 (_fead )<<8)|uint32 (_beddb );if _dcdc ==0{_geca .WriteByte ('z');}else {_eegfd :=_fedb .base256Tobase85 (_dcdc );for _ ,_facc :=range _eegfd [:_gafcf +1]{_geca .WriteByte (_facc +'!');};};};_geca .WriteString ("\u007e\u003e");return _geca .Bytes (),nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_cefa *PdfObjectStreams ,_aede bool ){_cefa ,_aede =obj .(*PdfObjectStreams );return _cefa ,_aede ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cbca *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetFilterName returns the name of the encoding filter.
func (_ccagf *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_cacb *_fab .Document ;

// Globals are the JBIG2 global segments.
Globals _fe .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_dfcd *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bedd :=_ggf .NewReader (encoded );var _effb []byte ;for {_fdcd ,_dagd :=_bedd .ReadByte ();if _dagd !=nil {return nil ,_dagd ;};if _fdcd > 128{_cffe ,_dgdbb :=_bedd .ReadByte ();if _dgdbb !=nil {return nil ,_dgdbb ;};for _gfdd :=0;_gfdd < 257-int (_fdcd );_gfdd ++{_effb =append (_effb ,_cffe );};}else if _fdcd < 128{for _fcb :=0;_fcb < int (_fdcd )+1;_fcb ++{_bbed ,_adb :=_bedd .ReadByte ();if _adb !=nil {return nil ,_adb ;};_effb =append (_effb ,_bbed );};}else {break ;};};return _effb ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_ggff *PdfObjectStream ,_fbbbg bool ){obj =ResolveReference (obj );_ggff ,_fbbbg =obj .(*PdfObjectStream );return _ggff ,_fbbbg ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_bcfe :=&DCTEncoder {};_bcfe .ColorComponents =3;_bcfe .BitsPerComponent =8;_bcfe .Quality =DefaultJPEGQuality ;return _bcfe ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};var _fage =_d .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_bfea map[PdfObjectName ]PdfObject ;_cbg []PdfObjectName ;_dcab *PdfParser ;};var _edaab =_d .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_bbfbb *PdfObjectString ,_ebggb bool ){_bbfbb ,_ebggb =TraceToDirectObject (obj ).(*PdfObjectString );return _bbfbb ,_ebggb ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_caaa :=&PdfCrypt {_agcd :false ,_agc :make (map[PdfObject ]bool ),_ege :make (map[PdfObject ]bool ),_aea :make (map[int ]struct{}),_abd :parser };_faf ,_bfda :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_bfda {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _caaa ,_c .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_faf !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_faf );return _caaa ,_c .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_caaa ._gfg .Filter =string (*_faf );if _bab ,_acc :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_acc {_caaa ._gfg .SubFilter =_bab .Str ();_ge .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_bab );};if L ,_agad :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_agad {if (*L %8)!=0{_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _caaa ,_c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_caaa ._gfg .Length =int (*L );}else {_caaa ._gfg .Length =40;};_caaa ._gfg .V =0;if _fbcg ,_ebad :=ed .Get ("\u0056").(*PdfObjectInteger );_ebad {V :=int (*_fbcg );_caaa ._gfg .V =V ;if V >=1&&V <=2{_caaa ._gfe =_cec (_caaa ._gfg .Length );}else if V >=4&&V <=5{if _ff :=_caaa .loadCryptFilters (ed );_ff !=nil {return _caaa ,_ff ;};}else {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _caaa ,_c .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _fac :=_cdb (&_caaa ._dcga ,ed );_fac !=nil {return _caaa ,_fac ;};_ace :="";if _eaa ,_cga :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_cga &&_eaa .Len ()>=1{_agebg ,_cgaa :=GetString (_eaa .Get (0));if !_cgaa {return _caaa ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_ace =_agebg .Str ();}else {_ge .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_caaa ._fbg =_ace ;return _caaa ,nil ;};const _gaceb =32<<(^uint (0)>>63);func _ffggf (_abacc PdfObject ,_aabc int )PdfObject {if _aabc > _dedg {_ge .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_dedg );return MakeNull ();};switch _bgdb :=_abacc .(type ){case *PdfIndirectObject :_abacc =_ffggf ((*_bgdb ).PdfObject ,_aabc +1);case *PdfObjectArray :for _dgec ,_fcdca :=range (*_bgdb )._bcadc {(*_bgdb )._bcadc [_dgec ]=_ffggf (_fcdca ,_aabc +1);};case *PdfObjectDictionary :for _dgceb ,_caaed :=range (*_bgdb )._bfea {(*_bgdb )._bfea [_dgceb ]=_ffggf (_caaed ,_aabc +1);};_ad .Slice ((*_bgdb )._cbg ,func (_gcgd ,_cfgf int )bool {return (*_bgdb )._cbg [_gcgd ]< (*_bgdb )._cbg [_cfgf ]});};return _abacc ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fdce :=PdfObjectBool (val );return &_fdce };

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_cbgf :=TraceToDirectObject (obj ).(*PdfObjectNull );return _cbgf ;};

// GetFilterName returns the name of the encoding filter.
func (_cffee *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// Clear resets the array to an empty state.
func (_dfbc *PdfObjectArray )Clear (){_dfbc ._bcadc =[]PdfObject {}};func _acbeb (_bgbf string )(PdfObjectReference ,error ){_dgad :=PdfObjectReference {};_fceeg :=_ggdc .FindStringSubmatch (_bgbf );if len (_fceeg )< 3{_ge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _dgad ,_c .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_fgfa ,_ :=_ca .Atoi (_fceeg [1]);_gcfe ,_ :=_ca .Atoi (_fceeg [2]);_dgad .ObjectNumber =int64 (_fgfa );_dgad .GenerationNumber =int64 (_gcfe );return _dgad ,nil ;};var _gdbgf =_d .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_aade *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _aade .Predictor !=1{return nil ,_gf .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _aade .EarlyChange ==1{return nil ,_gf .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _ead _ggf .Buffer ;_efgd :=_e .NewWriter (&_ead ,_e .MSB ,8);_efgd .Write (data );_efgd .Close ();return _ead .Bytes (),nil ;};func _ddfc (_gbbc int )int {if _gbbc < 0{return -_gbbc ;};return _gbbc ;};func (_fgba *PdfObjectInteger )String ()string {return _gf .Sprintf ("\u0025\u0064",*_fgba )};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_afgc Version )String ()string {return _gf .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_afgc .Major ,_afgc .Minor );};

// UpdateParams updates the parameter values of the encoder.
func (_dabe *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _aae ,_bdec :=GetNumberAsInt64 (params .Get ("\u004b"));_bdec ==nil {_dabe .K =int (_aae );};if _bdef ,_bfgc :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_bfgc ==nil {_dabe .Columns =int (_bdef );}else if _bdef ,_bfgc =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_bfgc ==nil {_dabe .Columns =int (_bdef );};if _gefb ,_bdff :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bdff ==nil {_dabe .BlackIs1 =_gefb > 0;}else {if _bfdb ,_cgdf :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cgdf {_dabe .BlackIs1 =_bfdb ;}else {if _decf ,_bcbgb :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_bcbgb {_caee ,_bgaa :=_decf .ToIntegerArray ();if _bgaa ==nil {_dabe .BlackIs1 =_caee [0]==1&&_caee [1]==0;};};};};if _ceaa ,_eefd :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_eefd ==nil {_dabe .EncodedByteAlign =_ceaa > 0;}else {if _aaaa ,_facf :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_facf {_dabe .EncodedByteAlign =_aaaa ;};};if _ebbg ,_cdfa :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cdfa ==nil {_dabe .EndOfLine =_ebbg > 0;}else {if _ebade ,_adab :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_adab {_dabe .EndOfLine =_ebade ;};};if _bgg ,_ebac :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_ebac ==nil {_dabe .Rows =int (_bgg );}else if _bgg ,_ebac =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_ebac ==nil {_dabe .Rows =int (_bgg );};if _gdbg ,_fffb :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fffb ==nil {_dabe .EndOfBlock =_gdbg > 0;}else {if _cced ,_gafa :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gafa {_dabe .EndOfBlock =_cced ;};};if _bffc ,_ggge :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_ggge !=nil {_dabe .DamagedRowsBeforeError =int (_bffc );};};

// GetXrefOffset returns the offset of the xref table.
func (_dgea *PdfParser )GetXrefOffset ()int64 {return _dgea ._febd };var (ErrUnsupportedEncodingParameters =_c .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_c .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_c .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_c .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_bg .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_c .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_dacf string ,_ccaca bool ){_bfgfdf ,_ccaca :=TraceToDirectObject (obj ).(*PdfObjectString );if _ccaca {return _bfgfdf .Str (),true ;};return ;};

// WriteString outputs the object as it is to be written to file.
func (_eedg *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func (_gfbf *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _fffda =20;_bfbb ,_ :=_gfbf ._aeff .Peek (_fffda );for _ffcdc :=0;_ffcdc < 2;_ffcdc ++{if _gfbf ._febd ==0{_gfbf ._febd =_gfbf .GetFileOffset ();};if _fage .Match (_bfbb ){_ge .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_ge .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_bfbb ));return _gfbf .parseXrefStream (nil );};if _beaa .Match (_bfbb ){_ge .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _gfbf .parseXrefTable ();};_gafg :=_gfbf .GetFileOffset ();if _gfbf ._febd ==0{_gfbf ._febd =_gafg ;};_gfbf .SetFileOffset (_gafg -_fffda );defer _gfbf .SetFileOffset (_gafg );_aaaad ,_ :=_gfbf ._aeff .Peek (_fffda );_bfbb =append (_aaaad ,_bfbb ...);};_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _fggb :=_gfbf .repairSeekXrefMarker ();_fggb !=nil {_ge .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_fggb );return nil ,_fggb ;};return _gfbf .parseXrefTable ();};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_fccg *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fccg .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _bcec (o ,0,traversed );};func (_geb *PdfCrypt )loadCryptFilters (_aec *PdfObjectDictionary )error {_geb ._gfe =cryptFilters {};_daa :=_aec .Get ("\u0043\u0046");_daa =TraceToDirectObject (_daa );if _fba ,_fbe :=_daa .(*PdfObjectReference );_fbe {_dcd ,_cca :=_geb ._abd .LookupByReference (*_fba );if _cca !=nil {_ge .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _cca ;};_daa =TraceToDirectObject (_dcd );};_gbd ,_cag :=_daa .(*PdfObjectDictionary );if !_cag {_ge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_daa );return _c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_cbe :=range _gbd .Keys (){_faa :=_gbd .Get (_cbe );if _bef ,_abe :=_faa .(*PdfObjectReference );_abe {_gfdb ,_ddc :=_geb ._abd .LookupByReference (*_bef );if _ddc !=nil {_ge .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _ddc ;};_faa =TraceToDirectObject (_gfdb );};_abea ,_def :=_faa .(*PdfObjectDictionary );if !_def {return _gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cbe ,_faa );};if _cbe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _gaa _ee .FilterDict ;if _ecc :=_ceagg (&_gaa ,_abea );_ecc !=nil {return _ecc ;};_afc ,_deed :=_ee .NewFilter (_gaa );if _deed !=nil {return _deed ;};_geb ._gfe [string (_cbe )]=_afc ;};_geb ._gfe ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ee .NewIdentity ();_geb ._aac ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dgfd ,_eeb :=_aec .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_eeb {if _ ,_aed :=_geb ._gfe [string (*_dgfd )];!_aed {return _gf .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dgfd );};_geb ._aac =string (*_dgfd );};_geb ._fbf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ba ,_cge :=_aec .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_cge {if _ ,_bea :=_geb ._gfe [string (*_ba )];!_bea {return _gf .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_ba );};_geb ._fbf =string (*_ba );};return nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_agag *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _fcd ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _agag .ColorComponents !=1||_agag .BitsPerComponent !=1{return nil ,_ag .Errorf (_fcd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_edc *_df .Bitmap ;_eged error ;);_ggbfg :=(_agag .Width *_agag .Height )==len (data );if _ggbfg {_edc ,_eged =_df .NewWithUnpaddedData (_agag .Width ,_agag .Height ,data );}else {_edc ,_eged =_df .NewWithData (_agag .Width ,_agag .Height ,data );};if _eged !=nil {return nil ,_eged ;};_fcga :=_agag .DefaultPageSettings ;if _eged =_fcga .Validate ();_eged !=nil {return nil ,_ag .Wrap (_eged ,_fcd ,"");};switch _fcga .Compression {case JB2Generic :if _eged =_agag ._cacb .AddGenericPage (_edc ,_fcga .DuplicatedLinesRemoval );_eged !=nil {return nil ,_ag .Wrap (_eged ,_fcd ,"");};case JB2SymbolCorrelation :return nil ,_ag .Error (_fcd ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_ag .Error (_fcd ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_ag .Error (_fcd ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _agag .Encode ();};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_cdac :=MakeArray ();for _ ,_cgga :=range vals {_cdac .Append (MakeInteger (int64 (_cgga )));};return _cdac ;};

// String returns a descriptive information string about the encryption method used.
func (_abg *PdfCrypt )String ()string {if _abg ==nil {return "";};_eff :=_abg ._gfg .Filter +"\u0020\u002d\u0020";if _abg ._gfg .V ==0{_eff +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _abg ._gfg .V ==1{_eff +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _abg ._gfg .V ==2{_eff +=_gf .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_abg ._gfg .Length );}else if _abg ._gfg .V ==3{_eff +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _abg ._gfg .V >=4{_eff +=_gf .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_abg ._fbf ,_abg ._aac );_eff +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _cgc ,_dacb :=range _abg ._gfe {_eff +=_gf .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_cgc ,_dacb .Name (),_dacb .KeyLength ());};};_dae :=_abg .GetAccessPermissions ();_eff +=_gf .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_dae );return _eff ;};func _dgd (_aga PdfObject )(int64 ,int64 ,error ){if _bd ,_dee :=_aga .(*PdfIndirectObject );_dee {return _bd .ObjectNumber ,_bd .GenerationNumber ,nil ;};if _bf ,_deg :=_aga .(*PdfObjectStream );_deg {return _bf .ObjectNumber ,_bf .GenerationNumber ,nil ;};return 0,0,_c .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gffdg ,_fagd :=NewEncoderFromStream (streamObj );if _fagd !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_fagd );return nil ,_fagd ;};_ge .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_gffdg );_bcge ,_fagd :=_gffdg .DecodeStream (streamObj );if _fagd !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_fagd );return nil ,_fagd ;};return _bcge ,nil ;};func _gcce (_ccea *PdfObjectStream ,_adaf *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cfe *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_ddec *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_ge .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ddec .Predictor );if _ddec .BitsPerComponent !=8{return nil ,_gf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_ddec .BitsPerComponent );};_eaeb ,_cabc :=_ddec .DecodeBytes (streamObj .Stream );if _cabc !=nil {return nil ,_cabc ;};_eaeb ,_cabc =_ddec .postDecodePredict (_eaeb );if _cabc !=nil {return nil ,_cabc ;};return _ddec .cleanImageData (_eaeb );};func (_abgcg *PdfParser )parsePdfVersion ()(int ,int ,error ){var _gfeb int64 =20;_ccfd :=make ([]byte ,_gfeb );_abgcg ._bbfa .Seek (0,_de .SeekStart );_abgcg ._bbfa .Read (_ccfd );var _dfag error ;var _eggb ,_dfcg int ;if _dgadd :=_bdad .FindStringSubmatch (string (_ccfd ));len (_dgadd )< 3{if _eggb ,_dfcg ,_dfag =_abgcg .seekPdfVersionTopDown ();_dfag !=nil {_ge .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_dfag ;};_abgcg ._bbfa ,_dfag =_caae (_abgcg ._bbfa ,_abgcg .GetFileOffset ()-8);if _dfag !=nil {return 0,0,_dfag ;};}else {if _eggb ,_dfag =_ca .Atoi (_dgadd [1]);_dfag !=nil {return 0,0,_dfag ;};if _dfcg ,_dfag =_ca .Atoi (_dgadd [2]);_dfag !=nil {return 0,0,_dfag ;};_abgcg .SetFileOffset (0);};_abgcg ._aeff =_b .NewReader (_abgcg ._bbfa );_ge .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_eggb ,_dfcg );return _eggb ,_dfcg ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fadf *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _ecec :=obj .(type ){case *PdfObjectFloat :return float64 (*_ecec ),nil ;case *PdfObjectInteger :return float64 (*_ecec ),nil ;};return 0,ErrNotANumber ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_cacb :_fab .InitEncodeDocument (false )}};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ee .FilterDict ;};

// GetFilterName returns the name of the encoding filter.
func (_eggg *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_defa *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_defa ._agcf ){return _c .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_defa ._agcf [i ]=obj ;return nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_ada *_dg .ImageBase ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ee .Filter ,userPass ,ownerPass []byte ,perm _aa .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_be :=&PdfCrypt {_ege :make (map[PdfObject ]bool ),_gfe :make (cryptFilters ),_dcga :_aa .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _aee Version ;if cf !=nil {_dac :=cf .PDFVersion ();_aee .Major ,_aee .Minor =_dac [0],_dac [1];V ,R :=cf .HandlerVersion ();_be ._gfg .V =V ;_be ._dcga .R =R ;_be ._gfg .Length =cf .KeyLength ()*8;};const (_adg =_ggaa ;);_be ._gfe [_adg ]=cf ;if _be ._gfg .V >=4{_be ._fbf =_adg ;_be ._aac =_adg ;};_deag :=_be .newEncryptDict ();_fabc :=_gg .Sum ([]byte (_f .Now ().Format (_f .RFC850 )));_gea :=string (_fabc [:]);_cdg :=make ([]byte ,100);_adc .Read (_cdg );_fabc =_gg .Sum (_cdg );_fge :=string (_fabc [:]);_ge .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_cdg );_ge .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_gea );_be ._fbg =_gea ;_afa :=_be .generateParams (userPass ,ownerPass );if _afa !=nil {return nil ,nil ,_afa ;};_eae (&_be ._dcga ,_deag );if _be ._gfg .V >=4{if _cee :=_be .saveCryptFilters (_deag );_cee !=nil {return nil ,nil ,_cee ;};};return _be ,&EncryptInfo {Version :_aee ,Encrypt :_deag ,ID0 :_gea ,ID1 :_fge },nil ;};type objectStreams map[int ]objectStream ;

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_gabf :=PdfObjectInteger (val );return &_gabf };

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _fffg ,_bbffa :=obj .(*PdfObjectReference );_bbffa {return _fffg .Resolve ();};return obj ;};

// Remove removes an element specified by key.
func (_fade *PdfObjectDictionary )Remove (key PdfObjectName ){_fffa :=-1;for _efgf ,_aada :=range _fade ._cbg {if _aada ==key {_fffa =_efgf ;break ;};};if _fffa >=0{_fade ._cbg =append (_fade ._cbg [:_fffa ],_fade ._cbg [_fffa +1:]...);delete (_fade ._bfea ,key );};};func _geda (_dafd *PdfObjectStream ,_abgce *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _cfba ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_bfab :=&JBIG2Encoder {};_fege :=_dafd .PdfObjectDictionary ;if _fege ==nil {return _bfab ,nil ;};if _abgce ==nil {_caef :=_fege .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _caef !=nil {switch _afcg :=_caef .(type ){case *PdfObjectDictionary :_abgce =_afcg ;case *PdfObjectArray :if _afcg .Len ()==1{if _ebgg ,_ffgb :=GetDict (_afcg .Get (0));_ffgb {_abgce =_ebgg ;};};default:_ge .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_caef );return nil ,_ag .Errorf (_cfba ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_afcg );};};};if _abgce ==nil {return _bfab ,nil ;};_bfab .UpdateParams (_abgce );_efcf :=_abgce .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _efcf ==nil {return _bfab ,nil ;};var _bfabg error ;_baee ,_fggc :=_efcf .(*PdfObjectStream );if !_fggc {_bfabg =_ag .Error (_cfba ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfabg );return nil ,_bfabg ;};_bfab .Globals ,_bfabg =_fe .DecodeGlobals (_baee .Stream );if _bfabg !=nil {_bfabg =_ag .Wrap (_bfabg ,_cfba ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfabg );return nil ,_bfabg ;};return _bfab ,nil ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_cddg :=MakeArray ();for _ ,_adge :=range vals {_cddg .Append (MakeFloat (_adge ));};return _cddg ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_cfaa :=PdfObjectString {_bdcaa :s ,_egcg :true };return &_cfaa ;};func (_efaa *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_efaa ._aeff )};func (_gfeg *FlateEncoder )cleanImageData (_gfcg []byte )([]byte ,error ){if _gfeg ._ada ==nil {return _gfcg ,nil ;};if _gfeg ._ada .BitsPerComponent >=8{return _gfcg ,nil ;};_fcgb :=_gfeg ._ada .BitsPerComponent *_gfeg ._ada .Width *_gfeg ._ada .ColorComponents *_gfeg ._ada .Height /8;_gfcg =_gfcg [:_fcgb ];var _bdd error ;_gfcg ,_bdd =_dg .AddDataPadding (_gfeg ._ada .Width ,_gfeg ._ada .Height ,_gfeg ._ada .BitsPerComponent ,_gfeg ._ada .ColorComponents ,_gfcg );if _bdd !=nil {return nil ,_bdd ;};return _gfcg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fadg *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_cdcd *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cdcd .DecodeBytes (streamObj .Stream );};func _cdb (_eda *_aa .StdEncryptDict ,_fdb *PdfObjectDictionary )error {R ,_deb :=_fdb .Get ("\u0052").(*PdfObjectInteger );if !_deb {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_eda .R =int (*R );O ,_deb :=_fdb .GetString ("\u004f");if !_deb {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _eda .R ==5||_eda .R ==6{if len (O )< 48{return _gf .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _gf .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_eda .O =[]byte (O );U ,_deb :=_fdb .GetString ("\u0055");if !_deb {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _eda .R ==5||_eda .R ==6{if len (U )< 48{return _gf .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_ge .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_eda .U =[]byte (U );if _eda .R >=5{OE ,_ga :=_fdb .GetString ("\u004f\u0045");if !_ga {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _gf .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_eda .OE =[]byte (OE );UE ,_ga :=_fdb .GetString ("\u0055\u0045");if !_ga {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _gf .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_eda .UE =[]byte (UE );};P ,_deb :=_fdb .Get ("\u0050").(*PdfObjectInteger );if !_deb {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_eda .P =_aa .Permissions (*P );if _eda .R ==6{Perms ,_gag :=_fdb .GetString ("\u0050\u0065\u0072m\u0073");if !_gag {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _gf .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_eda .Perms =[]byte (Perms );};if _gae ,_dgf :=_fdb .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_dgf {_eda .EncryptMetadata =bool (*_gae );}else {_eda .EncryptMetadata =true ;};return nil ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_bcadc :objects }};

// GetParser returns the parser for lazy-loading or compare references.
func (_bbbd *PdfObjectReference )GetParser ()*PdfParser {return _bbbd ._efgg };

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_fceae *PdfParser )GetObjectNums ()[]int {var _caeb []int ;for _ ,_eaccc :=range _fceae ._bgc .ObjectMap {_caeb =append (_caeb ,_eaccc .ObjectNumber );};_ad .Ints (_caeb );return _caeb ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func _gfa (_faab *PdfObjectStream ,_cdeg *MultiEncoder )(*DCTEncoder ,error ){_bfae :=NewDCTEncoder ();_dcdd :=_faab .PdfObjectDictionary ;if _dcdd ==nil {return _bfae ,nil ;};_geaf :=_faab .Stream ;if _cdeg !=nil {_beec ,_bcb :=_cdeg .DecodeBytes (_geaf );if _bcb !=nil {return nil ,_bcb ;};_geaf =_beec ;};_afef :=_ggf .NewReader (_geaf );_fbbf ,_dce :=_caf .DecodeConfig (_afef );if _dce !=nil {_ge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dce );return nil ,_dce ;};switch _fbbf .ColorModel {case _g .RGBAModel :_bfae .BitsPerComponent =8;_bfae .ColorComponents =3;case _g .RGBA64Model :_bfae .BitsPerComponent =16;_bfae .ColorComponents =3;case _g .GrayModel :_bfae .BitsPerComponent =8;_bfae .ColorComponents =1;case _g .Gray16Model :_bfae .BitsPerComponent =16;_bfae .ColorComponents =1;case _g .CMYKModel :_bfae .BitsPerComponent =8;_bfae .ColorComponents =4;case _g .YCbCrModel :_bfae .BitsPerComponent =8;_bfae .ColorComponents =3;default:return nil ,_c .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_bfae .Width =_fbbf .Width ;_bfae .Height =_fbbf .Height ;_ge .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_bfae );_bfae .Quality =DefaultJPEGQuality ;return _bfae ,nil ;};

// String returns a string describing `ind`.
func (_bbfc *PdfIndirectObject )String ()string {return _gf .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_bbfc ).ObjectNumber );};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gadg *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_ffea :=data ;var _bcdac error ;for _cffeb :=len (_gadg ._effbe )-1;_cffeb >=0;_cffeb --{_efead :=_gadg ._effbe [_cffeb ];_ffea ,_bcdac =_efead .EncodeBytes (_ffea );if _bcdac !=nil {return nil ,_bcdac ;};};return _ffea ,nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_agca *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ge .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_feaee :=_ggf .NewReader (encoded );_bgbb ,_dbba :=_db .NewReader (_feaee );if _dbba !=nil {_ge .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_dbba );_ge .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_dbba ;};defer _bgbb .Close ();var _fda _ggf .Buffer ;_fda .ReadFrom (_bgbb );return _fda .Bytes (),nil ;};type objectStream struct{N int ;_cg []byte ;_ce map[int ]int64 ;};func _edeg (_fgb *PdfObjectStream )(*MultiEncoder ,error ){_cdbe :=NewMultiEncoder ();_bedg :=_fgb .PdfObjectDictionary ;if _bedg ==nil {return _cdbe ,nil ;};var _acgcc *PdfObjectDictionary ;var _dgdba []PdfObject ;_adec :=_bedg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _adec !=nil {_eacdcb ,_dgda :=_adec .(*PdfObjectDictionary );if _dgda {_acgcc =_eacdcb ;};_aab ,_cgdc :=_adec .(*PdfObjectArray );if _cgdc {for _ ,_fcgf :=range _aab .Elements (){_fcgf =TraceToDirectObject (_fcgf );if _bccf ,_fefc :=_fcgf .(*PdfObjectDictionary );_fefc {_dgdba =append (_dgdba ,_bccf );}else {_dgdba =append (_dgdba ,MakeDict ());};};};};_adec =_bedg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _adec ==nil {return nil ,_gf .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_cdcc ,_cgda :=_adec .(*PdfObjectArray );if !_cgda {return nil ,_gf .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _deefc ,_cbae :=range _cdcc .Elements (){_ccgdg ,_agde :=_cbae .(*PdfObjectName );if !_agde {return nil ,_gf .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _agbe PdfObject ;if _acgcc !=nil {_agbe =_acgcc ;}else {if len (_dgdba )> 0{if _deefc >=len (_dgdba ){return nil ,_gf .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_agbe =_dgdba [_deefc ];};};var _dgae *PdfObjectDictionary ;if _fee ,_bfdg :=_agbe .(*PdfObjectDictionary );_bfdg {_dgae =_fee ;};_ge .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_ccgdg ,_agbe ,_dgae );if *_ccgdg ==StreamEncodingFilterNameFlate {_bcad ,_fgdd :=_ceb (_fgb ,_dgae );if _fgdd !=nil {return nil ,_fgdd ;};_cdbe .AddEncoder (_bcad );}else if *_ccgdg ==StreamEncodingFilterNameLZW {_cgac ,_acdf :=_cdgf (_fgb ,_dgae );if _acdf !=nil {return nil ,_acdf ;};_cdbe .AddEncoder (_cgac );}else if *_ccgdg ==StreamEncodingFilterNameASCIIHex {_aagaf :=NewASCIIHexEncoder ();_cdbe .AddEncoder (_aagaf );}else if *_ccgdg ==StreamEncodingFilterNameASCII85 {_edaa :=NewASCII85Encoder ();_cdbe .AddEncoder (_edaa );}else if *_ccgdg ==StreamEncodingFilterNameDCT {_bdcc ,_dabb :=_gfa (_fgb ,_cdbe );if _dabb !=nil {return nil ,_dabb ;};_cdbe .AddEncoder (_bdcc );_ge .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_ge .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_cdbe );}else {_ge .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_ccgdg );return nil ,_gf .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _cdbe ,nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_daea *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_daea ._bcadc ){return _c .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_daea ._bcadc [i ]=obj ;return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gcceb *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_gdaacf int ,_fedc bool ){_fgbg ,_fedc :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _fedc &&_fgbg !=nil {return int (*_fgbg ),true ;};return 0,false ;};

// UpdateParams updates the parameter values of the encoder.
func (_fcbe *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ffdd *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_aadda *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fgde :=encoded ;var _agef error ;for _ ,_ffcg :=range _aadda ._effbe {_ge .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_ffcg ,_ffcg );_fgde ,_agef =_ffcg .DecodeBytes (_fgde );if _agef !=nil {return nil ,_agef ;};};return _fgde ,nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _gb .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _edg ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ag .Error (_edg ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_decg uint8 ;_dbdg _dg .Image ;_fdee error ;);if bwThreshold ==JB2ImageAutoThreshold {_dbdg ,_fdee =_dg .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ag .Error (_edg ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_decg =uint8 (255*bwThreshold );_dbdg ,_fdee =_dg .MonochromeThresholdConverter (_decg ).Convert (i );};if _fdee !=nil {return nil ,_fdee ;};return _bgfcgb (_dbdg ),nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_cecf *PdfObjectName ,_cfagg bool ){_cecf ,_cfagg =TraceToDirectObject (obj ).(*PdfObjectName );return _cecf ,_cfagg ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_caag *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_baeb ,_fgfc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fgfc ==nil {_caag .BitsPerComponent =int (_baeb );};_ecbg ,_fgfc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fgfc ==nil {_caag .Width =int (_ecbg );};_fca ,_fgfc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fgfc ==nil {_caag .Height =int (_fca );};_dabf ,_fgfc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fgfc ==nil {_caag .ColorComponents =int (_dabf );};};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_gfg encryptDict ;_dcga _aa .StdEncryptDict ;_fbg string ;_bfc []byte ;_agc map[PdfObject ]bool ;_ege map[PdfObject ]bool ;_agcd bool ;_gfe cryptFilters ;_fbf string ;_aac string ;_abd *PdfParser ;_aea map[int ]struct{};};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_fffc *PdfParser )GetFileOffset ()int64 {_fafa ,_ :=_fffc ._bbfa .Seek (0,_de .SeekCurrent );_fafa -=int64 (_fffc ._aeff .Buffered ());return _fafa ;};func (_ddge *PdfParser )rebuildXrefTable ()error {_dcedd :=XrefTable {};_dcedd .ObjectMap =map[int ]XrefObject {};_decd :=make ([]int ,0,len (_ddge ._bgc .ObjectMap ));for _dbdd :=range _ddge ._bgc .ObjectMap {_decd =append (_decd ,_dbdd );};_ad .Ints (_decd );for _ ,_edea :=range _decd {_ggcd :=_ddge ._bgc .ObjectMap [_edea ];_fagec ,_ ,_gffe :=_ddge .lookupByNumberWrapper (_edea ,false );if _gffe !=nil {_ge .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_gffe );_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_gbbbf ,_baca :=_ddge .repairRebuildXrefsTopDown ();if _baca !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_baca );return _baca ;};_ddge ._bgc =*_gbbbf ;_ge .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_cbab ,_efad ,_gffe :=_dgd (_fagec );if _gffe !=nil {return _gffe ;};_ggcd .ObjectNumber =int (_cbab );_ggcd .Generation =int (_efad );_dcedd .ObjectMap [int (_cbab )]=_ggcd ;};_ddge ._bgc =_dcedd ;_ge .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_gdc (_ddge ._bgc );return nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_fece *PdfParser )GetXrefType ()*xrefType {return _fece ._aaaf };

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_gaefd float64 ,_ffbfg bool ){_cdgeeg ,_ffbfg :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _ffbfg {return float64 (*_cdgeeg ),true ;};return 0,false ;};

// DecodeStream implements ASCII85 stream decoding.
func (_fdeg *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fdeg .DecodeBytes (streamObj .Stream );};func (_gcfbf *PdfParser )seekToEOFMarker (_fgbd int64 )error {var _ceed int64 ;var _cfggc int64 =2048;for _ceed < _fgbd -4{if _fgbd <=(_cfggc +_ceed ){_cfggc =_fgbd -_ceed ;};_ ,_ccbf :=_gcfbf ._bbfa .Seek (-_ceed -_cfggc ,_de .SeekEnd );if _ccbf !=nil {return _ccbf ;};_egdc :=make ([]byte ,_cfggc );_gcfbf ._bbfa .Read (_egdc );_ge .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_egdc ));_gbe :=_edaab .FindAllStringIndex (string (_egdc ),-1);if _gbe !=nil {_begf :=_gbe [len (_gbe )-1];_ge .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gbe );_gcfbf ._bbfa .Seek (-_ceed -_cfggc +int64 (_begf [0]),_de .SeekEnd );return nil ;};_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ceed +=_cfggc -4;};_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _c .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_egbd *PdfObjectDictionary )Keys ()[]PdfObjectName {if _egbd ==nil {return nil ;};return _egbd ._cbg ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_gfebe :=MakeArray ();for _ ,_aaae :=range vals {_gfebe .Append (MakeInteger (_aaae ));};return _gfebe ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_ebacf *PdfObjectArray )Elements ()[]PdfObject {if _ebacf ==nil {return nil ;};return _ebacf ._bcadc ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_ccf *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_egee :=_ccf .GetFileOffset ();_ ,_cdaa :=_ccf ._bbfa .Seek (offset ,_de .SeekStart );if _cdaa !=nil {return nil ,_cdaa ;};_ecee :=make ([]byte ,len );_ ,_cdaa =_de .ReadAtLeast (_ccf ._bbfa ,_ecee ,int (len ));if _cdaa !=nil {return nil ,_cdaa ;};_ccf .SetFileOffset (_egee );return _ecee ,nil ;};const JB2ImageAutoThreshold =-1.0;

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _accgb ,_dffb :=obj .(*PdfObjectReference );_dffb {obj =_accgb .Resolve ();};_edcd ,_ggdab :=obj .(*PdfIndirectObject );_bfbe :=0;for _ggdab {obj =_edcd .PdfObject ;_edcd ,_ggdab =GetIndirect (obj );_bfbe ++;if _bfbe > _dedg {_ge .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_dedg );return nil ;};};return obj ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_adbcg *PdfObjectString )Decoded ()string {if _adbcg ==nil {return "";};_cfdec :=[]byte (_adbcg ._bdcaa );if len (_cfdec )>=2&&_cfdec [0]==0xFE&&_cfdec [1]==0xFF{return _fgf .UTF16ToString (_cfdec [2:]);};return _fgf .PDFDocEncodingToString (_cfdec );};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ebcdb *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ebee []int ;for _ ,_adfb :=range _ebcdb .Elements (){if _eegaab ,_aacc :=_adfb .(*PdfObjectInteger );_aacc {_ebee =append (_ebee ,int (*_eegaab ));}else {return nil ,ErrTypeError ;};};return _ebee ,nil ;};func (_dagdc *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_dagdc ._bgc .ObjectMap =make (map[int ]XrefObject );_dagdc ._aba =make (objectStreams );_fdfge ,_gcdf :=_dagdc ._bbfa .Seek (0,_de .SeekEnd );if _gcdf !=nil {return nil ,_gcdf ;};_ge .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_fdfge );_dagdc ._feea =_fdfge ;_gcdf =_dagdc .seekToEOFMarker (_fdfge );if _gcdf !=nil {_ge .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_gcdf );return nil ,_gcdf ;};_cged ,_gcdf :=_dagdc ._bbfa .Seek (0,_de .SeekCurrent );if _gcdf !=nil {return nil ,_gcdf ;};var _faag int64 =64;_bcfd :=_cged -_faag ;if _bcfd < 0{_bcfd =0;};_ ,_gcdf =_dagdc ._bbfa .Seek (_bcfd ,_de .SeekStart );if _gcdf !=nil {return nil ,_gcdf ;};_ceg :=make ([]byte ,_faag );_ ,_gcdf =_dagdc ._bbfa .Read (_ceg );if _gcdf !=nil {_ge .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_gcdf );return nil ,_gcdf ;};_eaacc :=_cfggb .FindStringSubmatch (string (_ceg ));if len (_eaacc )< 2{_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_c .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_eaacc )> 2{_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ceg );return nil ,_c .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_bgcd ,_ :=_ca .ParseInt (_eaacc [1],10,64);_ge .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_bgcd );if _bgcd > _fdfge {_ge .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_ge .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_bgcd ,_gcdf =_dagdc .repairLocateXref ();if _gcdf !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_gcdf ;};};_dagdc ._bbfa .Seek (_bgcd ,_de .SeekStart );_dagdc ._aeff =_b .NewReader (_dagdc ._bbfa );_agagd ,_gcdf :=_dagdc .parseXref ();if _gcdf !=nil {return nil ,_gcdf ;};_aceb :=_agagd .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _aceb !=nil {_begdc ,_dfac :=_aceb .(*PdfObjectInteger );if !_dfac {return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_gcdf =_dagdc .parseXrefStream (_begdc );if _gcdf !=nil {return nil ,_gcdf ;};};var _bbfaa []int64 ;_fdcb :=func (_gaef int64 ,_aced []int64 )bool {for _ ,_gcded :=range _aced {if _gcded ==_gaef {return true ;};};return false ;};_aceb =_agagd .Get ("\u0050\u0072\u0065\u0076");for _aceb !=nil {_cdgff ,_fbae :=_aceb .(*PdfObjectInteger );if !_fbae {_ge .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_aceb );return _agagd ,nil ;};_afaaa :=*_cdgff ;_ge .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_afaaa );_dagdc ._bbfa .Seek (int64 (_afaaa ),_de .SeekStart );_dagdc ._aeff =_b .NewReader (_dagdc ._bbfa );_gcab ,_egeee :=_dagdc .parseXref ();if _egeee !=nil {_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_ge .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_aceb =_gcab .Get ("\u0050\u0072\u0065\u0076");if _aceb !=nil {_eefdb :=*(_aceb .(*PdfObjectInteger ));if _fdcb (int64 (_eefdb ),_bbfaa ){_ge .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_bbfaa =append (_bbfaa ,int64 (_eefdb ));};};return _agagd ,nil ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_ggdd *PdfParser )CheckAccessRights (password []byte )(bool ,_aa .Permissions ,error ){if _ggdd ._fbcbf ==nil {return true ,_aa .PermOwner ,nil ;};return _ggdd ._fbcbf .checkAccessRights (password );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ebdde *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_fafe :=MakeDict ();_fafe .Set ("\u004b",MakeInteger (int64 (_ebdde .K )));_fafe .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ebdde .Columns )));if _ebdde .BlackIs1 {_fafe .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_ebdde .BlackIs1 ));};if _ebdde .EncodedByteAlign {_fafe .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_ebdde .EncodedByteAlign ));};if _ebdde .EndOfLine &&_ebdde .K >=0{_fafe .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_ebdde .EndOfLine ));};if _ebdde .Rows !=0&&!_ebdde .EndOfBlock {_fafe .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_ebdde .Rows )));};if !_ebdde .EndOfBlock {_fafe .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_ebdde .EndOfBlock ));};if _ebdde .DamagedRowsBeforeError !=0{_fafe .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_ebdde .DamagedRowsBeforeError )));};return _fafe ;};func _gdc (_eed XrefTable ){_ge .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_ge .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bgdc :=0;for _ ,_ageb :=range _eed .ObjectMap {_ge .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_bgdc +1,_ageb .ObjectNumber ,_ageb .Generation ,_ageb .Offset );_bgdc ++;};};

// String returns a string describing `ref`.
func (_fdcfg *PdfObjectReference )String ()string {return _gf .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_fdcfg .ObjectNumber ,_fdcfg .GenerationNumber );};func _fcebf (_eceg ,_fbcb ,_cgcd uint8 )uint8 {_bdb :=int (_cgcd );_aefe :=int (_fbcb )-_bdb ;_gbcg :=int (_eceg )-_bdb ;_bdb =_fbcc (_aefe +_gbcg );_aefe =_fbcc (_aefe );_gbcg =_fbcc (_gbcg );if _aefe <=_gbcg &&_aefe <=_bdb {return _eceg ;}else if _gbcg <=_bdb {return _fbcb ;};return _cgcd ;};type offsetReader struct{_dddd _de .ReadSeeker ;_cbbf int64 ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_fga :=&FlateEncoder {};_fga .Predictor =1;_fga .BitsPerComponent =8;_fga .Colors =1;_fga .Columns =1;return _fga ;};

// LookupByReference looks up a PdfObject by a reference.
func (_fbd *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_ge .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _fbd .LookupByNumber (int (ref .ObjectNumber ));};func _fbcc (_bcae int )int {_edgg :=_bcae >>(_gaceb -1);return (_bcae ^_edgg )-_edgg };

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fdacb *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _bgga []float64 ;for _ ,_bdcce :=range _fdacb .Elements (){switch _gded :=_bdcce .(type ){case *PdfObjectInteger :_bgga =append (_bgga ,float64 (*_gded ));case *PdfObjectFloat :_bgga =append (_bgga ,float64 (*_gded ));default:return nil ,ErrTypeError ;};};return _bgga ,nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_gcc *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fafg :=_ggf .NewReader (encoded );_bcdf ,_dab :=_caf .Decode (_fafg );if _dab !=nil {_ge .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dab );return nil ,_dab ;};_edfa :=_bcdf .Bounds ();var _ffe =make ([]byte ,_edfa .Dx ()*_edfa .Dy ()*_gcc .ColorComponents *_gcc .BitsPerComponent /8);_fgga :=0;for _eefb :=_edfa .Min .Y ;_eefb < _edfa .Max .Y ;_eefb ++{for _efdd :=_edfa .Min .X ;_efdd < _edfa .Max .X ;_efdd ++{_bcbc :=_bcdf .At (_efdd ,_eefb );if _gcc .ColorComponents ==1{if _gcc .BitsPerComponent ==16{_aefa ,_dcgc :=_bcbc .(_g .Gray16 );if !_dcgc {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffe [_fgga ]=byte ((_aefa .Y >>8)&0xff);_fgga ++;_ffe [_fgga ]=byte (_aefa .Y &0xff);_fgga ++;}else {_bbe ,_acfd :=_bcbc .(_g .Gray );if !_acfd {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffe [_fgga ]=_bbe .Y &0xff;_fgga ++;};}else if _gcc .ColorComponents ==3{if _gcc .BitsPerComponent ==16{_dacg ,_fcec :=_bcbc .(_g .RGBA64 );if !_fcec {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffe [_fgga ]=byte ((_dacg .R >>8)&0xff);_fgga ++;_ffe [_fgga ]=byte (_dacg .R &0xff);_fgga ++;_ffe [_fgga ]=byte ((_dacg .G >>8)&0xff);_fgga ++;_ffe [_fgga ]=byte (_dacg .G &0xff);_fgga ++;_ffe [_fgga ]=byte ((_dacg .B >>8)&0xff);_fgga ++;_ffe [_fgga ]=byte (_dacg .B &0xff);_fgga ++;}else {_accb ,_afcd :=_bcbc .(_g .RGBA );if _afcd {_ffe [_fgga ]=_accb .R &0xff;_fgga ++;_ffe [_fgga ]=_accb .G &0xff;_fgga ++;_ffe [_fgga ]=_accb .B &0xff;_fgga ++;}else {_gdcc ,_abgd :=_bcbc .(_g .YCbCr );if !_abgd {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bbb ,_bcaa ,_gad ,_ :=_gdcc .RGBA ();_ffe [_fgga ]=byte (_bbb >>8);_fgga ++;_ffe [_fgga ]=byte (_bcaa >>8);_fgga ++;_ffe [_fgga ]=byte (_gad >>8);_fgga ++;};};}else if _gcc .ColorComponents ==4{_aafg ,_gcbe :=_bcbc .(_g .CMYK );if !_gcbe {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffe [_fgga ]=255-_aafg .C &0xff;_fgga ++;_ffe [_fgga ]=255-_aafg .M &0xff;_fgga ++;_ffe [_fgga ]=255-_aafg .Y &0xff;_fgga ++;_ffe [_fgga ]=255-_aafg .K &0xff;_fgga ++;};};};return _ffe ,nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gbcb *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gbcb ._effbe =append (_gbcb ._effbe ,encoder );};

// PdfVersion returns version of the PDF file.
func (_fffbf *PdfParser )PdfVersion ()Version {return _fffbf ._egega };

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _ffggf (obj ,0)};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_bge *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_ge .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bge .Predictor );_fbgb ,_eega :=_bge .DecodeBytes (streamObj .Stream );if _eega !=nil {return nil ,_eega ;};_ge .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_ge .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_fbgb ),_fbgb );if _bge .Predictor > 1{if _bge .Predictor ==2{_ge .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_daad :=_bge .Columns *_bge .Colors ;if _daad < 1{return []byte {},nil ;};_cebb :=len (_fbgb )/_daad ;if len (_fbgb )%_daad !=0{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fbgb ),_daad );};if _daad %_bge .Colors !=0{return nil ,_gf .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_daad ,_bge .Colors );};if _daad > len (_fbgb ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_daad ,len (_fbgb ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ge .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fbgb ),_fbgb );_dga :=_ggf .NewBuffer (nil );for _bbfb :=0;_bbfb < _cebb ;_bbfb ++{_gebe :=_fbgb [_daad *_bbfb :_daad *(_bbfb +1)];for _dff :=_bge .Colors ;_dff < _daad ;_dff ++{_gebe [_dff ]=byte (int (_gebe [_dff ]+_gebe [_dff -_bge .Colors ])%256);};_dga .Write (_gebe );};_bcc :=_dga .Bytes ();_ge .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bcc ),_bcc );return _bcc ,nil ;}else if _bge .Predictor >=10&&_bge .Predictor <=15{_ge .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bca :=_bge .Columns *_bge .Colors +1;if _bca < 1{return []byte {},nil ;};_caab :=len (_fbgb )/_bca ;if len (_fbgb )%_bca !=0{return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fbgb ),_bca );};if _bca > len (_fbgb ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bca ,len (_fbgb ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eec :=_ggf .NewBuffer (nil );_ge .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bge .Columns );_ge .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fbgb ),_bca ,_caab );_bcf :=make ([]byte ,_bca );for _fcebd :=0;_fcebd < _bca ;_fcebd ++{_bcf [_fcebd ]=0;};for _bebf :=0;_bebf < _caab ;_bebf ++{_affe :=_fbgb [_bca *_bebf :_bca *(_bebf +1)];_bba :=_affe [0];switch _bba {case 0:case 1:for _bffa :=2;_bffa < _bca ;_bffa ++{_affe [_bffa ]=byte (int (_affe [_bffa ]+_affe [_bffa -1])%256);};case 2:for _bcee :=1;_bcee < _bca ;_bcee ++{_affe [_bcee ]=byte (int (_affe [_bcee ]+_bcf [_bcee ])%256);};default:_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bba );return nil ,_gf .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bba );};for _agfcd :=0;_agfcd < _bca ;_agfcd ++{_bcf [_agfcd ]=_affe [_agfcd ];};_eec .Write (_affe [1:]);};_gbc :=_eec .Bytes ();return _gbc ,nil ;}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bge .Predictor );return nil ,_gf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bge .Predictor );};};return _fbgb ,nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_effbe []StreamEncoder };var _cggg =_d .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_deeb *PdfObjectFloat ,_dced bool ){_deeb ,_dced =TraceToDirectObject (obj ).(*PdfObjectFloat );return _deeb ,_dced ;};func _dcde (_ddee *PdfObjectStream ,_eede *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_abb :=NewCCITTFaxEncoder ();_bdfb :=_ddee .PdfObjectDictionary ;if _bdfb ==nil {return _abb ,nil ;};if _eede ==nil {_fdeb :=TraceToDirectObject (_bdfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fdeb !=nil {switch _bga :=_fdeb .(type ){case *PdfObjectDictionary :_eede =_bga ;case *PdfObjectArray :if _bga .Len ()==1{if _bae ,_fbbc :=GetDict (_bga .Get (0));_fbbc {_eede =_bae ;};};default:_ge .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fdeb );return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _eede ==nil {_ge .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_fdeb );return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cgbd ,_cbfgc :=GetNumberAsInt64 (_eede .Get ("\u004b"));_cbfgc ==nil {_abb .K =int (_cgbd );};if _agcg ,_agcb :=GetNumberAsInt64 (_eede .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_agcb ==nil {_abb .Columns =int (_agcg );}else {_abb .Columns =1728;};if _aadc ,_eag :=GetNumberAsInt64 (_eede .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eag ==nil {_abb .BlackIs1 =_aadc > 0;}else {if _bcaf ,_baef :=GetBoolVal (_eede .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_baef {_abb .BlackIs1 =_bcaf ;}else {if _cac ,_ffcd :=GetArray (_eede .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ffcd {_aggc ,_aebb :=_cac .ToIntegerArray ();if _aebb ==nil {_abb .BlackIs1 =_aggc [0]==1&&_aggc [1]==0;};};};};if _dfgb ,_dbfae :=GetNumberAsInt64 (_eede .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dbfae ==nil {_abb .EncodedByteAlign =_dfgb > 0;}else {if _dfef ,_dgde :=GetBoolVal (_eede .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dgde {_abb .EncodedByteAlign =_dfef ;};};if _ebcb ,_cbaf :=GetNumberAsInt64 (_eede .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cbaf ==nil {_abb .EndOfLine =_ebcb > 0;}else {if _ebf ,_bdcg :=GetBoolVal (_eede .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bdcg {_abb .EndOfLine =_ebf ;};};if _cbeg ,_agdg :=GetNumberAsInt64 (_eede .Get ("\u0052\u006f\u0077\u0073"));_agdg ==nil {_abb .Rows =int (_cbeg );};_abb .EndOfBlock =true ;if _egd ,_fbce :=GetNumberAsInt64 (_eede .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fbce ==nil {_abb .EndOfBlock =_egd > 0;}else {if _gdbd ,_fced :=GetBoolVal (_eede .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fced {_abb .EndOfBlock =_gdbd ;};};if _gaag ,_dagf :=GetNumberAsInt64 (_eede .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_dagf !=nil {_abb .DamagedRowsBeforeError =int (_gaag );};_ge .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_eede .String ());return _abb ,nil ;};func (_eead *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _afbg *PdfObjectDictionary ;_fgddc ,_eage :=_eead .readTextLine ();if _eage !=nil {return nil ,_eage ;};_ge .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fgddc );_ccbc :=-1;_cbced :=0;_bbcf :=false ;_gefbb :="";for {_eead .skipSpaces ();_ ,_geee :=_eead ._aeff .Peek (1);if _geee !=nil {return nil ,_geee ;};_fgddc ,_geee =_eead .readTextLine ();if _geee !=nil {return nil ,_geee ;};_bgac :=_fdcf .FindStringSubmatch (_fgddc );if len (_bgac )==0{_dadb :=len (_gefbb )> 0;_gefbb +=_fgddc +"\u000a";if _dadb {_bgac =_fdcf .FindStringSubmatch (_gefbb );};};if len (_bgac )==3{_afbe ,_ :=_ca .Atoi (_bgac [1]);_baed ,_ :=_ca .Atoi (_bgac [2]);_ccbc =_afbe ;_cbced =_baed ;_bbcf =true ;_gefbb ="";_ge .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ccbc ,_cbced );continue ;};_gbgf :=_gdbgf .FindStringSubmatch (_fgddc );if len (_gbgf )==4{if !_bbcf {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_c .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_fadb ,_ :=_ca .ParseInt (_gbgf [1],10,64);_fecc ,_ :=_ca .Atoi (_gbgf [2]);_fceeb :=_gbgf [3];_gefbb ="";if _ggg .ToLower (_fceeb )=="\u006e"&&_fadb > 1{_agfd ,_bfcc :=_eead ._bgc .ObjectMap [_ccbc ];if !_bfcc ||_fecc > _agfd .Generation {_bgda :=XrefObject {ObjectNumber :_ccbc ,XType :XrefTypeTableEntry ,Offset :_fadb ,Generation :_fecc };_eead ._bgc .ObjectMap [_ccbc ]=_bgda ;};};_ccbc ++;continue ;};if (len (_fgddc )> 6)&&(_fgddc [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_ge .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_fgddc );if len (_fgddc )> 9{_bedc :=_eead .GetFileOffset ();_eead .SetFileOffset (_bedc -int64 (len (_fgddc ))+7);};_eead .skipSpaces ();_eead .skipComments ();_ge .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_ge .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_fgddc );_afbg ,_geee =_eead .ParseDict ();_ge .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _geee !=nil {_ge .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_geee );return nil ,_geee ;};break ;};if _fgddc =="\u0025\u0025\u0045O\u0046"{_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_c .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_ge .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_fgddc );};_ge .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _eead ._aaaf ==nil {_ccgca :=XrefTypeTableEntry ;_eead ._aaaf =&_ccgca ;};return _afbg ,nil ;};

// String returns a string representation of `name`.
func (_cfafa *PdfObjectName )String ()string {return string (*_cfafa )};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_dfcc :=&ASCII85Encoder {};return _dfcc };

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_dbdea []byte ,_eagf bool ){_cggde ,_eagf :=TraceToDirectObject (obj ).(*PdfObjectString );if _eagf {return _cggde .Bytes (),true ;};return ;};

// String returns the state of the bool as "true" or "false".
func (_dceg *PdfObjectBool )String ()string {if *_dceg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_cege *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_fcecb :=_cege ._bfea [key ];if !_fcecb {_cege ._cbg =append (_cege ._cbg ,key );};_cege ._bfea [key ]=val ;};func _abcb (_ageaa *PdfObjectDictionary )(_bacf *_dg .ImageBase ){var (_efec *PdfObjectInteger ;_aacce bool ;);if _efec ,_aacce =_ageaa .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_aacce {_bacf =&_dg .ImageBase {Width :int (*_efec )};}else {return nil ;};if _efec ,_aacce =_ageaa .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_aacce {_bacf .Height =int (*_efec );};if _efec ,_aacce =_ageaa .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_aacce {_bacf .BitsPerComponent =int (*_efec );};if _efec ,_aacce =_ageaa .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_aacce {_bacf .ColorComponents =int (*_efec );};return _bacf ;};func (_ebaa *PdfCrypt )isDecrypted (_cbde PdfObject )bool {_ ,_bdc :=_ebaa ._agc [_cbde ];if _bdc {_ge .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _cgf :=_cbde .(type ){case *PdfObjectStream :if _ebaa ._dcga .R !=5{if _adff ,_aeb :=_cgf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aeb &&*_adff =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_bdc =_ebaa ._aea [int (_cgf .ObjectNumber )];_bdc {return true ;};switch _cdce :=_cgf .PdfObject .(type ){case *PdfObjectDictionary :_babf :=true ;for _ ,_effa :=range _bfgf {if _cdce .Get (_effa )==nil {_babf =false ;break ;};};if _babf {return true ;};};};_ge .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};type objectCache map[int ]PdfObject ;func _bfdacf (_cfdb ,_ecbec PdfObject ,_eeda int )bool {if _eeda > _dedg {_ge .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_dedg );return false ;};if _cfdb ==nil &&_ecbec ==nil {return true ;}else if _cfdb ==nil ||_ecbec ==nil {return false ;};if _cd .TypeOf (_cfdb )!=_cd .TypeOf (_ecbec ){return false ;};switch _adbe :=_cfdb .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_adbe ==*(_ecbec .(*PdfObjectName ));case *PdfObjectString :return *_adbe ==*(_ecbec .(*PdfObjectString ));case *PdfObjectInteger :return *_adbe ==*(_ecbec .(*PdfObjectInteger ));case *PdfObjectBool :return *_adbe ==*(_ecbec .(*PdfObjectBool ));case *PdfObjectFloat :return *_adbe ==*(_ecbec .(*PdfObjectFloat ));case *PdfIndirectObject :return _bfdacf (TraceToDirectObject (_cfdb ),TraceToDirectObject (_ecbec ),_eeda +1);case *PdfObjectArray :_aca :=_ecbec .(*PdfObjectArray );if len ((*_adbe )._bcadc )!=len ((*_aca )._bcadc ){return false ;};for _abbg ,_gbdg :=range (*_adbe )._bcadc {if !_bfdacf (_gbdg ,(*_aca )._bcadc [_abbg ],_eeda +1){return false ;};};return true ;case *PdfObjectDictionary :_aabbe :=_ecbec .(*PdfObjectDictionary );_cfac ,_eabc :=(*_adbe )._bfea ,(*_aabbe )._bfea ;if len (_cfac )!=len (_eabc ){return false ;};for _dedc ,_bbbf :=range _cfac {_faccb ,_fffe :=_eabc [_dedc ];if !_fffe ||!_bfdacf (_bbbf ,_faccb ,_eeda +1){return false ;};};return true ;case *PdfObjectStream :_efcd :=_ecbec .(*PdfObjectStream );return _bfdacf ((*_adbe ).PdfObjectDictionary ,(*_efcd ).PdfObjectDictionary ,_eeda +1);default:_ge .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_cfdb );};return false ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_afee *PdfObjectReference )Resolve ()PdfObject {if _afee ._efgg ==nil {return MakeNull ();};_gaec ,_ ,_gdcb :=_afee ._efgg .resolveReference (_afee );if _gdcb !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_gdcb );return MakeNull ();};if _gaec ==nil {_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _gaec ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ffdeb *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bbg []int64 ;for _ ,_dcgae :=range _ffdeb .Elements (){if _bcfb ,_adgd :=_dcgae .(*PdfObjectInteger );_adgd {_bbg =append (_bbg ,int64 (*_bcfb ));}else {return nil ,ErrTypeError ;};};return _bbg ,nil ;};func (_efc *PdfCrypt )decryptBytes (_afgb []byte ,_cdeb string ,_adeg []byte )([]byte ,error ){_ge .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_effac ,_ggb :=_efc ._gfe [_cdeb ];if !_ggb {return nil ,_gf .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cdeb );};return _effac .DecryptBytes (_afgb ,_adeg );};func (_bece *PdfParser )parseHexString ()(*PdfObjectString ,error ){_bece ._aeff .ReadByte ();var _cdagf _ggf .Buffer ;for {_dcec ,_ffeae :=_bece ._aeff .Peek (1);if _ffeae !=nil {return MakeString (""),_ffeae ;};if _dcec [0]=='>'{_bece ._aeff .ReadByte ();break ;};_bbc ,_ :=_bece ._aeff .ReadByte ();if !IsWhiteSpace (_bbc ){_cdagf .WriteByte (_bbc );};};if _cdagf .Len ()%2==1{_cdagf .WriteRune ('0');};_bagd ,_ :=_dc .DecodeString (_cdagf .String ());return MakeHexString (string (_bagd )),nil ;};func _agcbf ()string {return _ge .Version };

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_degg *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _ecfd []float64 ;for _ ,_agbb :=range _degg .Elements (){_efbe ,_bbfg :=GetNumberAsFloat (TraceToDirectObject (_agbb ));if _bbfg !=nil {return nil ,_gf .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_ecfd =append (_ecfd ,_efbe );};return _ecfd ,nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_febdb *PdfObjectInteger ,_feff bool ){_febdb ,_feff =TraceToDirectObject (obj ).(*PdfObjectInteger );return _febdb ,_feff ;};

// String returns a string describing `stream`.
func (_bdgb *PdfObjectStream )String ()string {return _gf .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_bdgb .ObjectNumber ,_bdgb .PdfObjectDictionary );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ffgg *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// WriteString outputs the object as it is to be written to file.
func (_dbde *PdfObjectString )WriteString ()string {var _cgec _ggf .Buffer ;if _dbde ._egcg {_aeae :=_dc .EncodeToString (_dbde .Bytes ());_cgec .WriteString ("\u003c");_cgec .WriteString (_aeae );_cgec .WriteString ("\u003e");return _cgec .String ();};_cbbfdf :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_cgec .WriteString ("\u0028");for _feef :=0;_feef < len (_dbde ._bdcaa );_feef ++{_feged :=_dbde ._bdcaa [_feef ];if _ggddg ,_bdab :=_cbbfdf [_feged ];_bdab {_cgec .WriteString (_ggddg );}else {_cgec .WriteByte (_feged );};};_cgec .WriteString ("\u0029");return _cgec .String ();};var _bfgf =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_efd *PdfCrypt )GetAccessPermissions ()_aa .Permissions {return _efd ._dcga .P };

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_dgce *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _cfcab :=val .(type ){case *PdfObjectName :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectDictionary :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectStream :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectString :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectNull :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectInteger :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectArray :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectBool :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectFloat :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfObjectReference :if _cfcab !=nil {_dgce .Set (key ,val );};case *PdfIndirectObject :if _cfcab !=nil {_dgce .Set (key ,val );};default:_ge .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};const _ggaa ="\u0053\u0074\u0064C\u0046";

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func (_gccc *PdfParser )parseXrefStream (_eafd *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _eafd !=nil {_ge .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_eafd );_gccc ._bbfa .Seek (int64 (*_eafd ),_de .SeekStart );_gccc ._aeff =_b .NewReader (_gccc ._bbfa );};_fcda :=_gccc .GetFileOffset ();_cfcd ,_afac :=_gccc .ParseIndirectObject ();if _afac !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_ge .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_cfcd );_bgaf ,_abbd :=_cfcd .(*PdfObjectStream );if !_abbd {_ge .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_afae :=_bgaf .PdfObjectDictionary ;_fgge ,_abbd :=_bgaf .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_abbd {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_c .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_fgge )> 8388607{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_fgge );return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ffbe :=_bgaf .PdfObjectDictionary .Get ("\u0057");_caca ,_abbd :=_ffbe .(*PdfObjectArray );if !_abbd {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_fedd :=_caca .Len ();if _fedd !=3{_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_fedd );return nil ,_c .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _gade []int64 ;for _ggaaf :=0;_ggaaf < 3;_ggaaf ++{_gaac ,_dcef :=GetInt (_caca .Get (_ggaaf ));if !_dcef {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_gade =append (_gade ,int64 (*_gaac ));};_cbbc ,_afac :=DecodeStream (_bgaf );if _afac !=nil {_ge .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_afac );return nil ,_afac ;};_fddc :=int (_gade [0]);_gffd :=int (_gade [0]+_gade [1]);_abfb :=int (_gade [0]+_gade [1]+_gade [2]);_dbdc :=int (_gade [0]+_gade [1]+_gade [2]);if _fddc < 0||_gffd < 0||_abfb < 0{_ge .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_fddc ,_gffd ,_abfb );return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _dbdc ==0{_ge .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _afae ,nil ;};_ccgbc :=len (_cbbc )/_dbdc ;_ccdb :=0;_geada :=_bgaf .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _aebf []int ;if _geada !=nil {_ge .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_geada );_edce ,_feag :=_geada .(*PdfObjectArray );if !_feag {_ge .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_c .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _edce .Len ()%2!=0{_ge .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ccdb =0;_bgecc ,_addd :=_edce .ToIntegerArray ();if _addd !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_addd );return nil ,_addd ;};for _gfbb :=0;_gfbb < len (_bgecc );_gfbb +=2{_egbe :=_bgecc [_gfbb ];_facae :=_bgecc [_gfbb +1];for _dffeb :=0;_dffeb < _facae ;_dffeb ++{_aebf =append (_aebf ,_egbe +_dffeb );};_ccdb +=_facae ;};}else {for _cddf :=0;_cddf < int (*_fgge );_cddf ++{_aebf =append (_aebf ,_cddf );};_ccdb =int (*_fgge );};if _ccgbc ==_ccdb +1{_ge .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_gccf :=_ccdb -1;for _ ,_gcec :=range _aebf {if _gcec > _gccf {_gccf =_gcec ;};};_aebf =append (_aebf ,_gccf +1);_ccdb ++;};if _ccgbc !=len (_aebf ){_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_ccgbc ,len (_aebf ));return nil ,_c .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_ge .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ccdb );_ge .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_aebf );_affba :=func (_cgcc []byte )int64 {var _gdee int64 ;for _fdfg :=0;_fdfg < len (_cgcc );_fdfg ++{_gdee +=int64 (_cgcc [_fdfg ])*(1<<uint (8*(len (_cgcc )-_fdfg -1)));};return _gdee ;};_ge .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_cbbc ));_fdeec :=0;for _aedb :=0;_aedb < len (_cbbc );_aedb +=_dbdc {_cgcda :=_dbga (len (_cbbc ),_aedb ,_aedb +_fddc );if _cgcda !=nil {_ge .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cgcda );return nil ,_cgcda ;};_ggga :=_cbbc [_aedb :_aedb +_fddc ];_cgcda =_dbga (len (_cbbc ),_aedb +_fddc ,_aedb +_gffd );if _cgcda !=nil {_ge .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cgcda );return nil ,_cgcda ;};_gdde :=_cbbc [_aedb +_fddc :_aedb +_gffd ];_cgcda =_dbga (len (_cbbc ),_aedb +_gffd ,_aedb +_abfb );if _cgcda !=nil {_ge .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cgcda );return nil ,_cgcda ;};_bfec :=_cbbc [_aedb +_gffd :_aedb +_abfb ];_cgee :=_affba (_ggga );_cbfgd :=_affba (_gdde );_ebbb :=_affba (_bfec );if _gade [0]==0{_cgee =1;};if _fdeec >=len (_aebf ){_ge .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_gcge :=_aebf [_fdeec ];_fdeec ++;_ge .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_gcge ,_ggga );_ge .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_gcge ,_gdde );_ge .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_gcge ,_bfec );_ge .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_gcge ,_cgee ,_cbfgd ,_ebbb );if _cgee ==0{_ge .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _cgee ==1{_ge .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_gdde );if _cbfgd ==_fcda {_ge .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_gcge ,_bgaf .ObjectNumber );_gcge =int (_bgaf .ObjectNumber );};if _dcae ,_ceaf :=_gccc ._bgc .ObjectMap [_gcge ];!_ceaf ||int (_ebbb )> _dcae .Generation {_cbbfd :=XrefObject {ObjectNumber :_gcge ,XType :XrefTypeTableEntry ,Offset :_cbfgd ,Generation :int (_ebbb )};_gccc ._bgc .ObjectMap [_gcge ]=_cbbfd ;};}else if _cgee ==2{_ge .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_ffag :=_gccc ._bgc .ObjectMap [_gcge ];!_ffag {_bfdc :=XrefObject {ObjectNumber :_gcge ,XType :XrefTypeObjectStream ,OsObjNumber :int (_cbfgd ),OsObjIndex :int (_ebbb )};_gccc ._bgc .ObjectMap [_gcge ]=_bfdc ;_ge .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_bfdc );};}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _gccc ._aaaf ==nil {_gcde :=XrefTypeObjectStream ;_gccc ._aaaf =&_gcde ;};return _afae ,nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_cedf :=PdfObjectString {_bdcaa :s };return &_cedf };const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// WriteString outputs the object as it is to be written to file.
func (_abgf *PdfObjectDictionary )WriteString ()string {var _dece _ggg .Builder ;_dece .WriteString ("\u003c\u003c");for _ ,_febeb :=range _abgf ._cbg {_dfec :=_abgf ._bfea [_febeb ];_dece .WriteString (_febeb .WriteString ());_dece .WriteString ("\u0020");_dece .WriteString (_dfec .WriteString ());};_dece .WriteString ("\u003e\u003e");return _dece .String ();};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _bfdacf (obj1 ,obj2 ,0)};func _gbgfg (_bccfe string )(int ,int ,error ){_dddg :=_fage .FindStringSubmatch (_bccfe );if len (_dddg )< 3{return 0,0,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_eaee ,_ :=_ca .Atoi (_dddg [1]);_faeb ,_ :=_ca .Atoi (_dddg [2]);return _eaee ,_faeb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aeec *FlateEncoder )MakeDecodeParams ()PdfObject {if _aeec .Predictor > 1{_dfc :=MakeDict ();_dfc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_aeec .Predictor )));if _aeec .BitsPerComponent !=8{_dfc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_aeec .BitsPerComponent )));};if _aeec .Columns !=1{_dfc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_aeec .Columns )));};if _aeec .Colors !=1{_dfc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_aeec .Colors )));};return _dfc ;};return nil ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dfeb *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };func (_gecc *PdfParser )parseString ()(*PdfObjectString ,error ){_gecc ._aeff .ReadByte ();var _fcbf _ggf .Buffer ;_defd :=1;for {_gceec ,_eacf :=_gecc ._aeff .Peek (1);if _eacf !=nil {return MakeString (_fcbf .String ()),_eacf ;};if _gceec [0]=='\\'{_gecc ._aeff .ReadByte ();_ecgb ,_feda :=_gecc ._aeff .ReadByte ();if _feda !=nil {return MakeString (_fcbf .String ()),_feda ;};if IsOctalDigit (_ecgb ){_badbgf ,_deae :=_gecc ._aeff .Peek (2);if _deae !=nil {return MakeString (_fcbf .String ()),_deae ;};var _ffab []byte ;_ffab =append (_ffab ,_ecgb );for _ ,_gfea :=range _badbgf {if IsOctalDigit (_gfea ){_ffab =append (_ffab ,_gfea );}else {break ;};};_gecc ._aeff .Discard (len (_ffab )-1);_ge .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_ffab );_efeg ,_deae :=_ca .ParseUint (string (_ffab ),8,32);if _deae !=nil {return MakeString (_fcbf .String ()),_deae ;};_fcbf .WriteByte (byte (_efeg ));continue ;};switch _ecgb {case 'n':_fcbf .WriteRune ('\n');case 'r':_fcbf .WriteRune ('\r');case 't':_fcbf .WriteRune ('\t');case 'b':_fcbf .WriteRune ('\b');case 'f':_fcbf .WriteRune ('\f');case '(':_fcbf .WriteRune ('(');case ')':_fcbf .WriteRune (')');case '\\':_fcbf .WriteRune ('\\');};continue ;}else if _gceec [0]=='('{_defd ++;}else if _gceec [0]==')'{_defd --;if _defd ==0{_gecc ._aeff .ReadByte ();break ;};};_egga ,_ :=_gecc ._aeff .ReadByte ();_fcbf .WriteByte (_egga );};return MakeString (_fcbf .String ()),nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_faaa *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _faaa .isEncrypted (obj ){return nil ;};switch _acg :=obj .(type ){case *PdfIndirectObject :_faaa ._ege [_acg ]=true ;_ge .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_acg .ObjectNumber ,_acg .GenerationNumber );_acd :=_acg .ObjectNumber ;_cfdc :=_acg .GenerationNumber ;_acb :=_faaa .Encrypt (_acg .PdfObject ,_acd ,_cfdc );if _acb !=nil {return _acb ;};return nil ;case *PdfObjectStream :_faaa ._ege [_acg ]=true ;_cfag :=_acg .PdfObjectDictionary ;if _gab ,_bfb :=_cfag .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bfb &&*_gab =="\u0058\u0052\u0065\u0066"{return nil ;};_dbbg :=_acg .ObjectNumber ;_dfd :=_acg .GenerationNumber ;_ge .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dbbg ,_dfd );_fgeg :=_ggaa ;if _faaa ._gfg .V >=4{_fgeg =_faaa ._fbf ;_ge .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_faaa ._fbf );if _eggd ,_gaba :=_cfag .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_gaba {if _ebdab ,_ffbd :=GetName (_eggd .Get (0));_ffbd {if *_ebdab =="\u0043\u0072\u0079p\u0074"{_fgeg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gafc ,_acf :=_cfag .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_acf {if _gaad ,_bda :=_gafc .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bda {if _ ,_cddb :=_faaa ._gfe [string (*_gaad )];_cddb {_ge .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gaad );_fgeg =string (*_gaad );};};};};};};_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fgeg );if _fgeg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bdcb :=_faaa .Encrypt (_acg .PdfObjectDictionary ,_dbbg ,_dfd );if _bdcb !=nil {return _bdcb ;};_agee ,_bdcb :=_faaa .makeKey (_fgeg ,uint32 (_dbbg ),uint32 (_dfd ),_faaa ._bfc );if _bdcb !=nil {return _bdcb ;};_acg .Stream ,_bdcb =_faaa .encryptBytes (_acg .Stream ,_fgeg ,_agee );if _bdcb !=nil {return _bdcb ;};_cfag .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_acg .Stream ))));return nil ;case *PdfObjectString :_ge .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_bcg :=_ggaa ;if _faaa ._gfg .V >=4{_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_faaa ._aac );if _faaa ._aac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_bcg =_faaa ._aac ;};_eafe ,_dfa :=_faaa .makeKey (_bcg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_faaa ._bfc );if _dfa !=nil {return _dfa ;};_cff :=_acg .Str ();_fae :=make ([]byte ,len (_cff ));for _dba :=0;_dba < len (_cff );_dba ++{_fae [_dba ]=_cff [_dba ];};_ge .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_fae ,_fae );_fae ,_dfa =_faaa .encryptBytes (_fae ,_bcg ,_eafe );if _dfa !=nil {return _dfa ;};_acg ._bdcaa =string (_fae );return nil ;case *PdfObjectArray :for _ ,_egeg :=range _acg .Elements (){_afd :=_faaa .Encrypt (_egeg ,parentObjNum ,parentGenNum );if _afd !=nil {return _afd ;};};return nil ;case *PdfObjectDictionary :_bac :=false ;if _fdd :=_acg .Get ("\u0054\u0079\u0070\u0065");_fdd !=nil {_dbbf ,_bgbd :=_fdd .(*PdfObjectName );if _bgbd &&*_dbbf =="\u0053\u0069\u0067"{_bac =true ;};};for _ ,_abde :=range _acg .Keys (){_dde :=_acg .Get (_abde );if _bac &&string (_abde )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_abde )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_abde )!="\u0050\u0072\u0065\u0076"&&string (_abde )!="\u004c\u0061\u0073\u0074"{_cce :=_faaa .Encrypt (_dde ,parentObjNum ,parentGenNum );if _cce !=nil {return _cce ;};};};return nil ;};return nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_bagag *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _faca ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _gbfb :=_bagag .AddPageImage (img ,&_bagag .DefaultPageSettings );_gbfb !=nil {return nil ,_ag .Wrap (_gbfb ,_faca ,"");};return _bagag .Encode ();};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_bbff *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ceage :=&_fa .Encoder {K :_bbff .K ,Columns :_bbff .Columns ,EndOfLine :_bbff .EndOfLine ,EndOfBlock :_bbff .EndOfBlock ,BlackIs1 :_bbff .BlackIs1 ,DamagedRowsBeforeError :_bbff .DamagedRowsBeforeError ,Rows :_bbff .Rows ,EncodedByteAlign :_bbff .EncodedByteAlign };_cdcb ,_eacdc :=_ceage .Decode (encoded );if _eacdc !=nil {return nil ,_eacdc ;};var _ddg []byte ;_cggeb :=0;var _afb byte ;var _aagb byte ;for _gcf :=range _cdcb {if _afb !=0{_ddg =append (_ddg ,_aagb );_aagb =0;_cggeb ++;_afb =0;};for _ddb :=range _cdcb [_gcf ]{_aagb |=_cdcb [_gcf ][_ddb ]<<(7-_afb );_afb ++;if _afb ==8{_ddg =append (_ddg ,_aagb );_aagb =0;_cggeb ++;_afb =0;};};};if _afb > 0{_ddg =append (_ddg ,_aagb );};return _ddg ,nil ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_dca *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _dca .isDecrypted (obj ){return nil ;};switch _ebdd :=obj .(type ){case *PdfIndirectObject :_dca ._agc [_ebdd ]=true ;_ge .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_ebdd .ObjectNumber ,_ebdd .GenerationNumber );_ffb :=_ebdd .ObjectNumber ;_fef :=_ebdd .GenerationNumber ;_adca :=_dca .Decrypt (_ebdd .PdfObject ,_ffb ,_fef );if _adca !=nil {return _adca ;};return nil ;case *PdfObjectStream :_dca ._agc [_ebdd ]=true ;_aef :=_ebdd .PdfObjectDictionary ;if _dca ._dcga .R !=5{if _ccb ,_eab :=_aef .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eab &&*_ccb =="\u0058\u0052\u0065\u0066"{return nil ;};};_bde :=_ebdd .ObjectNumber ;_add :=_ebdd .GenerationNumber ;_ge .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_bde ,_add );_fdf :=_ggaa ;if _dca ._gfg .V >=4{_fdf =_dca ._fbf ;_ge .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_dca ._fbf );if _bbf ,_fdbd :=_aef .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_fdbd {if _dcgb ,_cdfe :=GetName (_bbf .Get (0));_cdfe {if *_dcgb =="\u0043\u0072\u0079p\u0074"{_fdf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ggeg ,_eaed :=_aef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_eaed {if _acca ,_dcb :=_ggeg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_dcb {if _ ,_dbc :=_dca ._gfe [string (*_acca )];_dbc {_ge .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_acca );_fdf =string (*_acca );};};};};};};_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fdf );if _fdf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_gbg :=_dca .Decrypt (_aef ,_bde ,_add );if _gbg !=nil {return _gbg ;};_gee ,_gbg :=_dca .makeKey (_fdf ,uint32 (_bde ),uint32 (_add ),_dca ._bfc );if _gbg !=nil {return _gbg ;};_ebdd .Stream ,_gbg =_dca .decryptBytes (_ebdd .Stream ,_fdf ,_gee );if _gbg !=nil {return _gbg ;};_aef .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ebdd .Stream ))));return nil ;case *PdfObjectString :_ge .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_bce :=_ggaa ;if _dca ._gfg .V >=4{_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dca ._aac );if _dca ._aac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_bce =_dca ._aac ;};_egg ,_eaf :=_dca .makeKey (_bce ,uint32 (parentObjNum ),uint32 (parentGenNum ),_dca ._bfc );if _eaf !=nil {return _eaf ;};_gbb :=_ebdd .Str ();_fdg :=make ([]byte ,len (_gbb ));for _gfb :=0;_gfb < len (_gbb );_gfb ++{_fdg [_gfb ]=_gbb [_gfb ];};_ge .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_fdg ,_fdg );_fdg ,_eaf =_dca .decryptBytes (_fdg ,_bce ,_egg );if _eaf !=nil {return _eaf ;};_ebdd ._bdcaa =string (_fdg );return nil ;case *PdfObjectArray :for _ ,_aad :=range _ebdd .Elements (){_bgb :=_dca .Decrypt (_aad ,parentObjNum ,parentGenNum );if _bgb !=nil {return _bgb ;};};return nil ;case *PdfObjectDictionary :_ebda :=false ;if _eafg :=_ebdd .Get ("\u0054\u0079\u0070\u0065");_eafg !=nil {_gcb ,_gcad :=_eafg .(*PdfObjectName );if _gcad &&*_gcb =="\u0053\u0069\u0067"{_ebda =true ;};};for _ ,_feb :=range _ebdd .Keys (){_gcac :=_ebdd .Get (_feb );if _ebda &&string (_feb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_feb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_feb )!="\u0050\u0072\u0065\u0076"&&string (_feb )!="\u004c\u0061\u0073\u0074"{_ffd :=_dca .Decrypt (_gcac ,parentObjNum ,parentGenNum );if _ffd !=nil {return _ffd ;};};};return nil ;};return nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func (_gcbb *PdfParser )readComment ()(string ,error ){var _gebea _ggf .Buffer ;_ ,_gebc :=_gcbb .skipSpaces ();if _gebc !=nil {return _gebea .String (),_gebc ;};_gabg :=true ;for {_fdac ,_geba :=_gcbb ._aeff .Peek (1);if _geba !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_geba .Error ());return _gebea .String (),_geba ;};if _gabg &&_fdac [0]!='%'{return _gebea .String (),_c .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_gabg =false ;if (_fdac [0]!='\r')&&(_fdac [0]!='\n'){_bffcb ,_ :=_gcbb ._aeff .ReadByte ();_gebea .WriteByte (_bffcb );}else {break ;};};return _gebea .String (),nil ;};

// String returns a string describing `array`.
func (_cbfbb *PdfObjectArray )String ()string {_cbfd :="\u005b";for _bdffg ,_ebgf :=range _cbfbb .Elements (){_cbfd +=_ebgf .String ();if _bdffg < (_cbfbb .Len ()-1){_cbfd +="\u002c\u0020";};};_cbfd +="\u005d";return _cbfd ;};func _dbga (_cdegf ,_dbgad ,_abgfd int )error {if _dbgad < 0||_dbgad > _cdegf {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _abgfd < _dbgad {return _c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _abgfd > _cdegf {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_afefe :=PdfObjectNull {};return &_afefe };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_fbbd *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_dge :=MakeDict ();_dge .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fbbd .GetFilterName ()));return _dge ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_ccad :=&PdfIndirectObject {};_ccad .PdfObject =obj ;return _ccad ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_affg *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dcfb _ggf .Buffer ;for _ ,_ecbb :=range data {_dcfb .WriteString (_gf .Sprintf ("\u0025\u002e\u0032X\u0020",_ecbb ));};_dcfb .WriteByte ('>');return _dcfb .Bytes (),nil ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_aegb *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_afaa :=_ggf .NewReader (encoded );var _dfea []byte ;for {_dgac ,_caaag :=_afaa .ReadByte ();if _caaag !=nil {return nil ,_caaag ;};if _dgac =='>'{break ;};if IsWhiteSpace (_dgac ){continue ;};if (_dgac >='a'&&_dgac <='f')||(_dgac >='A'&&_dgac <='F')||(_dgac >='0'&&_dgac <='9'){_dfea =append (_dfea ,_dgac );}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_dgac );return nil ,_gf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_dgac );};};if len (_dfea )%2==1{_dfea =append (_dfea ,'0');};_ge .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dfea );_afdd :=make ([]byte ,_dc .DecodedLen (len (_dfea )));_ ,_agcc :=_dc .Decode (_afdd ,_dfea );if _agcc !=nil {return nil ,_agcc ;};return _afdd ,nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_afea :=PdfObjectFloat (val );return &_afea };

// GetFilterName returns the name of the encoding filter.
func (_fadc *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };func (_dbad *PdfParser )skipComments ()error {if _ ,_cgab :=_dbad .skipSpaces ();_cgab !=nil {return _cgab ;};_bccff :=true ;for {_befd ,_dbff :=_dbad ._aeff .Peek (1);if _dbff !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_dbff .Error ());return _dbff ;};if _bccff &&_befd [0]!='%'{return nil ;};_bccff =false ;if (_befd [0]!='\r')&&(_befd [0]!='\n'){_dbad ._aeff .ReadByte ();}else {break ;};};return _dbad .skipComments ();};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_efgg *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// GetFilterName returns the name of the encoding filter.
func (_edfe *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };func (_gdb *PdfCrypt )checkAccessRights (_gca []byte )(bool ,_aa .Permissions ,error ){_defb :=_gdb .securityHandler ();_gaf ,_efe ,_dag :=_defb .Authenticate (&_gdb ._dcga ,_gca );if _dag !=nil {return false ,0,_dag ;}else if _efe ==0||len (_gaf )==0{return false ,0,nil ;};return true ,_efe ,nil ;};func (_gfgb *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ffeac :=_gfgb ._aeff .Discard (4);return PdfObjectNull {},_ffeac ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_gfbba *PdfParser )Inspect ()(map[string ]int ,error ){return _gfbba .inspect ()};

// Bytes returns the PdfObjectString content as a []byte array.
func (_edcce *PdfObjectString )Bytes ()[]byte {return []byte (_edcce ._bdcaa )};